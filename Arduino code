 /*
 *final.pde - Ultrasonic sensor obstacle detection for visually impaired
 *@Author: M-sq
 *@Project: Show my way
 *@Team: Kenneth<<Leader>>, Ihsan, Nigel, Sothearith, Victoria, Muneer
 */
#include <Ultrasonic.h>
#include <Servo.h>

int trigpin = 2;//appoint trigger pin
int echopin = 3;//appoint echo pin
int flexsensorPin= A0;//appoint flex sensor to analog pin A0
int trigpin_2 = 6;
int echopin_2 = 5;

Servo myservo;  // create servo object to control a servo 
Servo myservo_2; // create servo object to control a servo
int pos = 0;    // variable to store the servo position 
int pos2=0;
Ultrasonic ultrasonic(trigpin,echopin);
Ultrasonic ultrasonic_2(trigpin_2,echopin_2);

void setup()
{
  Serial.begin(9600);//set Serial Baud rate
  myservo.attach(4);// attaches the servo on pin 9 to the servo object 
  myservo_2.attach(9);
  Serial.println("System is starting!!!\n");

}

void loop()
{           
  int output_mode; // 0 = raw data, 1 = filtered data, 2 = raw data and filtered data
  float old_cmdistance;
  int flexsensorReading= analogRead(flexsensorReading);
  
  Serial.println(flexsensorReading);
  int flex0to10 = map(flexsensorReading,498,520 , 0 , 10);
  
  Serial.println(flex0to10);
  
  if (flex0to10>8)
 {
          return;
 }       
 else
   if (flex0to10<=5)        
   {  
      float cmdistance; //left
      float cmdistance_2; //right
      old_cmdistance=cmdistance;
      long microsec = ultrasonic.timing();
      long microsec_2 = ultrasonic_2.timing();
      cmdistance = ultrasonic.CalcDistance(microsec,Ultrasonic::CM);//this result unit is centimeter
      cmdistance_2 = ultrasonic_2.CalcDistance(microsec_2,Ultrasonic::CM);//this result unit is centimeter
      if(output_mode == 0)
     { 
       ;
     } 
     if(output_mode == 1)
     { 
       cmdistance = Filter(cmdistance, old_cmdistance, 8); 
     } 
    if(output_mode == 2)
     { 
      Serial.print(cmdistance); 
      Serial.print(" "); 
      cmdistance = Filter(cmdistance, old_cmdistance, 4); 
      Serial.print(cmdistance); 
      Serial.print("\n"); 
    } 
    delay(60); 

  //             //if (cmdistance >=300 || cmdistance <= 0){
  ////                Serial.print("Out of range");
  ////            }
  ////            else
      Serial.print(" cmdistance_1: ");
      Serial.println(cmdistance);
      Serial.print ("cmdistance_2: ");
      Serial.println(cmdistance_2);
  ////left sonar
  //          {
  //              if(cmdistance>40 && cmdistance<60)
  //             {
  //                pos=180;
  //               myservo.write(pos);
  //                delay(300);
  //                 pos=0;
  //                 myservo.write(pos);
  //                 delay(300);             
  //               }  
  //             else
  //                if (cmdistance<40)
  //                {
  //                    pos=180;
  //                   myservo.write(pos);
  //                  delay(100);
  //                   pos=0;
  //                    myservo.write(pos);
  //                    delay(100);
  //                 }
  //		  else
  //		    pos=0; 
  //		    myservo.write(pos);
  //         }
  ////	//right sonar
  ////      { 
  ////        if(cmdistance_2 < 60)
  ////       {
  ////           digitalWrite(red_led,HIGH);
  ////       }else
  ////          digitalWrite(red_led,LOW);
  ////      }
  //        // right sonar
  //        {
  //          if(cmdistance_2>40 && cmdistance_2<60)
  //            {
  //              pos2=180;
  //              myservo_2.write(pos2);
  //              delay(300);
  //              pos2=0;
  //              myservo_2.write(pos2);
  //              delay(300);
  //            }
  //          else
  //            if (cmdistance_2<40)
  //              {
  //                pos2=180;
  //                myservo_2.write(pos2);
  //                pos2=0;
  //                myservo_2.write(pos2);
  //                delay(100);
  //               }
  //            else
  //              pos2=0;
  //              myservo_2.write(pos2);
  //         }
  delay(500);
}


// This filter limits the max difference between readings and also apply an average filter 
int Filter(int new_value, int old_value, int max_diff) 
{ 
  int diff_values; 
  int result; 
  if (old_value == 0) 
  { // Filter is not initialized (no old value) 
    return(new_value); 
  } 
  diff_values = new_value - old_value; 
  // Difference with old reading 
  if (diff_values > max_diff) 
  { 
    result = old_value + max_diff; 
    // We limit the max difference between readings 
  } 
  else 
  { 
    if (diff_values < -max_diff) 
    { 
      result = old_value - max_diff; 
      // We limit the max difference between readings 
    } 
    else 
    { 
      result = (new_value + old_value) >> 1; 
      // Small filtering (average filter) 
    } 
  } 
  return(result); 
}

