
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000086  00800200  00003602  00003696  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003602  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a36  00800286  00800286  0000371c  2**0
                  ALLOC
  3 .stab         000025b0  00000000  00000000  0000371c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a8f  00000000  00000000  00005ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  0000675b  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000858  00000000  00000000  0000678a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000c394  00000000  00000000  00006fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002cf6  00000000  00000000  00013376  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000055c6  00000000  00000000  0001606c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001cf4  00000000  00000000  0001b634  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002fca  00000000  00000000  0001d328  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00009b1b  00000000  00000000  000202f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000009b0  00000000  00000000  00029e0d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	04 c1       	rjmp	.+520    	; 0x20a <__dtors_end>
       2:	00 00       	nop
       4:	32 c1       	rjmp	.+612    	; 0x26a <__bad_interrupt>
       6:	00 00       	nop
       8:	30 c1       	rjmp	.+608    	; 0x26a <__bad_interrupt>
       a:	00 00       	nop
       c:	2e c1       	rjmp	.+604    	; 0x26a <__bad_interrupt>
       e:	00 00       	nop
      10:	2c c1       	rjmp	.+600    	; 0x26a <__bad_interrupt>
      12:	00 00       	nop
      14:	2a c1       	rjmp	.+596    	; 0x26a <__bad_interrupt>
      16:	00 00       	nop
      18:	28 c1       	rjmp	.+592    	; 0x26a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	26 c1       	rjmp	.+588    	; 0x26a <__bad_interrupt>
      1e:	00 00       	nop
      20:	24 c1       	rjmp	.+584    	; 0x26a <__bad_interrupt>
      22:	00 00       	nop
      24:	22 c1       	rjmp	.+580    	; 0x26a <__bad_interrupt>
      26:	00 00       	nop
      28:	20 c1       	rjmp	.+576    	; 0x26a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	1e c1       	rjmp	.+572    	; 0x26a <__bad_interrupt>
      2e:	00 00       	nop
      30:	1c c1       	rjmp	.+568    	; 0x26a <__bad_interrupt>
      32:	00 00       	nop
      34:	e1 c6       	rjmp	.+3522   	; 0xdf8 <__vector_13>
      36:	00 00       	nop
      38:	18 c1       	rjmp	.+560    	; 0x26a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	16 c1       	rjmp	.+556    	; 0x26a <__bad_interrupt>
      3e:	00 00       	nop
      40:	14 c1       	rjmp	.+552    	; 0x26a <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__vector_17>
      48:	10 c1       	rjmp	.+544    	; 0x26a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	0e c1       	rjmp	.+540    	; 0x26a <__bad_interrupt>
      4e:	00 00       	nop
      50:	0c c1       	rjmp	.+536    	; 0x26a <__bad_interrupt>
      52:	00 00       	nop
      54:	0a c1       	rjmp	.+532    	; 0x26a <__bad_interrupt>
      56:	00 00       	nop
      58:	08 c1       	rjmp	.+528    	; 0x26a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <__vector_23>
      60:	04 c1       	rjmp	.+520    	; 0x26a <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 25 13 	jmp	0x264a	; 0x264a <__vector_25>
      68:	0c 94 25 14 	jmp	0x284a	; 0x284a <__vector_26>
      6c:	fe c0       	rjmp	.+508    	; 0x26a <__bad_interrupt>
      6e:	00 00       	nop
      70:	fc c0       	rjmp	.+504    	; 0x26a <__bad_interrupt>
      72:	00 00       	nop
      74:	fa c0       	rjmp	.+500    	; 0x26a <__bad_interrupt>
      76:	00 00       	nop
      78:	f8 c0       	rjmp	.+496    	; 0x26a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f6 c0       	rjmp	.+492    	; 0x26a <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 6f 09 	jmp	0x12de	; 0x12de <__vector_32>
      84:	f2 c0       	rjmp	.+484    	; 0x26a <__bad_interrupt>
      86:	00 00       	nop
      88:	f0 c0       	rjmp	.+480    	; 0x26a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	ee c0       	rjmp	.+476    	; 0x26a <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 65 13 	jmp	0x26ca	; 0x26ca <__vector_36>
      94:	0c 94 64 14 	jmp	0x28c8	; 0x28c8 <__vector_37>
      98:	e8 c0       	rjmp	.+464    	; 0x26a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	e6 c0       	rjmp	.+460    	; 0x26a <__bad_interrupt>
      9e:	00 00       	nop
      a0:	e4 c0       	rjmp	.+456    	; 0x26a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	e2 c0       	rjmp	.+452    	; 0x26a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 46 0a 	jmp	0x148c	; 0x148c <__vector_42>
      ac:	de c0       	rjmp	.+444    	; 0x26a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	dc c0       	rjmp	.+440    	; 0x26a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	da c0       	rjmp	.+436    	; 0x26a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	d8 c0       	rjmp	.+432    	; 0x26a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 1d 0b 	jmp	0x163a	; 0x163a <__vector_47>
      c0:	d4 c0       	rjmp	.+424    	; 0x26a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	d2 c0       	rjmp	.+420    	; 0x26a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	d0 c0       	rjmp	.+416    	; 0x26a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 a5 13 	jmp	0x274a	; 0x274a <__vector_51>
      d0:	0c 94 a3 14 	jmp	0x2946	; 0x2946 <__vector_52>
      d4:	ca c0       	rjmp	.+404    	; 0x26a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 e5 13 	jmp	0x27ca	; 0x27ca <__vector_54>
      dc:	0c 94 e2 14 	jmp	0x29c4	; 0x29c4 <__vector_55>
      e0:	c4 c0       	rjmp	.+392    	; 0x26a <__bad_interrupt>
	...

000000e4 <digital_pin_to_timer_PGM>:
      e4:	00 00 09 0a 02 08 0b 0c 0d 07 06 03 04 01 00 00     ................
	...
     110:	11 10 0f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

0000012a <digital_pin_to_bit_mask_PGM>:
     12a:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     13a:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     14a:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     15a:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     16a:	04 08 10 20 40 80                                   ... @.

00000170 <digital_pin_to_port_PGM>:
     170:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     180:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     190:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     1a0:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     1b0:	0b 0b 0b 0b 0b 0b                                   ......

000001b6 <port_to_input_PGM>:
     1b6:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     1c6:	00 01 00 00 03 01 06 01 09 01                       ..........

000001d0 <port_to_output_PGM>:
     1d0:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     1e0:	02 01 00 00 05 01 08 01 0b 01                       ..........

000001ea <port_to_mode_PGM>:
     1ea:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     1fa:	01 01 00 00 04 01 07 01 0a 01                       ..........

00000204 <__ctors_start>:
     204:	8f 04       	cpc	r8, r15
     206:	e8 15       	cp	r30, r8

00000208 <__ctors_end>:
     208:	94 04       	cpc	r9, r4

0000020a <__dtors_end>:
     20a:	11 24       	eor	r1, r1
     20c:	1f be       	out	0x3f, r1	; 63
     20e:	cf ef       	ldi	r28, 0xFF	; 255
     210:	d1 e2       	ldi	r29, 0x21	; 33
     212:	de bf       	out	0x3e, r29	; 62
     214:	cd bf       	out	0x3d, r28	; 61
     216:	00 e0       	ldi	r16, 0x00	; 0
     218:	0c bf       	out	0x3c, r16	; 60

0000021a <__do_copy_data>:
     21a:	12 e0       	ldi	r17, 0x02	; 2
     21c:	a0 e0       	ldi	r26, 0x00	; 0
     21e:	b2 e0       	ldi	r27, 0x02	; 2
     220:	e2 e0       	ldi	r30, 0x02	; 2
     222:	f6 e3       	ldi	r31, 0x36	; 54
     224:	00 e0       	ldi	r16, 0x00	; 0
     226:	0b bf       	out	0x3b, r16	; 59
     228:	02 c0       	rjmp	.+4      	; 0x22e <__do_copy_data+0x14>
     22a:	07 90       	elpm	r0, Z+
     22c:	0d 92       	st	X+, r0
     22e:	a6 38       	cpi	r26, 0x86	; 134
     230:	b1 07       	cpc	r27, r17
     232:	d9 f7       	brne	.-10     	; 0x22a <__do_copy_data+0x10>

00000234 <__do_clear_bss>:
     234:	2c e0       	ldi	r18, 0x0C	; 12
     236:	a6 e8       	ldi	r26, 0x86	; 134
     238:	b2 e0       	ldi	r27, 0x02	; 2
     23a:	01 c0       	rjmp	.+2      	; 0x23e <.do_clear_bss_start>

0000023c <.do_clear_bss_loop>:
     23c:	1d 92       	st	X+, r1

0000023e <.do_clear_bss_start>:
     23e:	ac 3b       	cpi	r26, 0xBC	; 188
     240:	b2 07       	cpc	r27, r18
     242:	e1 f7       	brne	.-8      	; 0x23c <.do_clear_bss_loop>

00000244 <__do_global_ctors>:
     244:	12 e0       	ldi	r17, 0x02	; 2
     246:	c8 e0       	ldi	r28, 0x08	; 8
     248:	d2 e0       	ldi	r29, 0x02	; 2
     24a:	00 e0       	ldi	r16, 0x00	; 0
     24c:	06 c0       	rjmp	.+12     	; 0x25a <__do_global_ctors+0x16>
     24e:	22 97       	sbiw	r28, 0x02	; 2
     250:	01 09       	sbc	r16, r1
     252:	fe 01       	movw	r30, r28
     254:	0b bf       	out	0x3b, r16	; 59
     256:	0e 94 cf 1a 	call	0x359e	; 0x359e <__tablejump_elpm__>
     25a:	c4 30       	cpi	r28, 0x04	; 4
     25c:	d1 07       	cpc	r29, r17
     25e:	80 e0       	ldi	r24, 0x00	; 0
     260:	08 07       	cpc	r16, r24
     262:	a9 f7       	brne	.-22     	; 0x24e <__do_global_ctors+0xa>
     264:	e8 d2       	rcall	.+1488   	; 0x836 <main>
     266:	0c 94 f0 1a 	jmp	0x35e0	; 0x35e0 <__do_global_dtors>

0000026a <__bad_interrupt>:
     26a:	ca ce       	rjmp	.-620    	; 0x0 <__vectors>

0000026c <_Z19delayInMilliSecondsi>:
     26c:	8f 92       	push	r8
     26e:	9f 92       	push	r9
     270:	af 92       	push	r10
     272:	bf 92       	push	r11
	if(num > 10)
	printInt(num/10);
	Serial.print(last_digit, DEC);
}

void delayInMilliSeconds(int milliseconds) {
     274:	cf 92       	push	r12
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	6c 01       	movw	r12, r24
	long start = millis();
     27e:	0e 94 0d 18 	call	0x301a	; 0x301a <millis>
     282:	4b 01       	movw	r8, r22
     284:	5c 01       	movw	r10, r24
	while (millis() - start < milliseconds);
     286:	ee 24       	eor	r14, r14
     288:	d7 fc       	sbrc	r13, 7
     28a:	e0 94       	com	r14
     28c:	fe 2c       	mov	r15, r14
     28e:	0e 94 0d 18 	call	0x301a	; 0x301a <millis>
     292:	ab 01       	movw	r20, r22
     294:	bc 01       	movw	r22, r24
     296:	48 19       	sub	r20, r8
     298:	59 09       	sbc	r21, r9
     29a:	6a 09       	sbc	r22, r10
     29c:	7b 09       	sbc	r23, r11
     29e:	4c 15       	cp	r20, r12
     2a0:	5d 05       	cpc	r21, r13
     2a2:	6e 05       	cpc	r22, r14
     2a4:	7f 05       	cpc	r23, r15
     2a6:	98 f3       	brcs	.-26     	; 0x28e <_Z19delayInMilliSecondsi+0x22>
}
     2a8:	ff 90       	pop	r15
     2aa:	ef 90       	pop	r14
     2ac:	df 90       	pop	r13
     2ae:	cf 90       	pop	r12
     2b0:	bf 90       	pop	r11
     2b2:	af 90       	pop	r10
     2b4:	9f 90       	pop	r9
     2b6:	8f 90       	pop	r8
     2b8:	08 95       	ret

000002ba <_Z41__static_initialization_and_destruction_0ii>:
		vTaskDelay(1000);
	}
}

void vApplicationIdleHook()
{
     2ba:	81 30       	cpi	r24, 0x01	; 1
     2bc:	91 05       	cpc	r25, r1
     2be:	f1 f4       	brne	.+60     	; 0x2fc <_Z41__static_initialization_and_destruction_0ii+0x42>
     2c0:	6f 3f       	cpi	r22, 0xFF	; 255
     2c2:	7f 4f       	sbci	r23, 0xFF	; 255
     2c4:	19 f5       	brne	.+70     	; 0x30c <_Z41__static_initialization_and_destruction_0ii+0x52>
     2c6:	40 91 12 02 	lds	r20, 0x0212
     2ca:	50 91 13 02 	lds	r21, 0x0213
     2ce:	60 91 14 02 	lds	r22, 0x0214
     2d2:	70 91 15 02 	lds	r23, 0x0215
     2d6:	84 e2       	ldi	r24, 0x24	; 36
     2d8:	93 e0       	ldi	r25, 0x03	; 3
     2da:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <_ZN10UltrasonicC1Eii>
     2de:	40 91 0e 02 	lds	r20, 0x020E
     2e2:	50 91 0f 02 	lds	r21, 0x020F
     2e6:	60 91 10 02 	lds	r22, 0x0210
     2ea:	70 91 11 02 	lds	r23, 0x0211
     2ee:	88 e1       	ldi	r24, 0x18	; 24
     2f0:	93 e0       	ldi	r25, 0x03	; 3
     2f2:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <_ZN10UltrasonicC1Eii>
     2f6:	89 e8       	ldi	r24, 0x89	; 137
     2f8:	92 e0       	ldi	r25, 0x02	; 2
     2fa:	80 c5       	rjmp	.+2816   	; 0xdfc <_ZN3QueC1Ev>
     2fc:	89 2b       	or	r24, r25
     2fe:	31 f4       	brne	.+12     	; 0x30c <_Z41__static_initialization_and_destruction_0ii+0x52>
     300:	6f 3f       	cpi	r22, 0xFF	; 255
     302:	7f 4f       	sbci	r23, 0xFF	; 255
     304:	19 f4       	brne	.+6      	; 0x30c <_Z41__static_initialization_and_destruction_0ii+0x52>
     306:	89 e8       	ldi	r24, 0x89	; 137
     308:	92 e0       	ldi	r25, 0x02	; 2
     30a:	8f c5       	rjmp	.+2846   	; 0xe2a <_ZN3QueD1Ev>
     30c:	08 95       	ret

0000030e <_Z8xbeeTaskPv>:
     30e:	cf 93       	push	r28
     310:	df 93       	push	r29
     312:	cd b7       	in	r28, 0x3d	; 61
     314:	de b7       	in	r29, 0x3e	; 62
     316:	c2 57       	subi	r28, 0x72	; 114
     318:	d1 40       	sbci	r29, 0x01	; 1
     31a:	0f b6       	in	r0, 0x3f	; 63
     31c:	f8 94       	cli
     31e:	de bf       	out	0x3e, r29	; 62
     320:	0f be       	out	0x3f, r0	; 63
     322:	cd bf       	out	0x3d, r28	; 61
     324:	6b e1       	ldi	r22, 0x1B	; 27
     326:	72 e0       	ldi	r23, 0x02	; 2
     328:	81 e7       	ldi	r24, 0x71	; 113
     32a:	9a e0       	ldi	r25, 0x0A	; 10
     32c:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     330:	ce 01       	movw	r24, r28
     332:	87 58       	subi	r24, 0x87	; 135
     334:	9f 4f       	sbci	r25, 0xFF	; 255
     336:	c2 59       	subi	r28, 0x92	; 146
     338:	de 4f       	sbci	r29, 0xFE	; 254
     33a:	99 83       	std	Y+1, r25	; 0x01
     33c:	88 83       	st	Y, r24
     33e:	ce 56       	subi	r28, 0x6E	; 110
     340:	d1 40       	sbci	r29, 0x01	; 1
     342:	fe 01       	movw	r30, r28
     344:	e7 59       	subi	r30, 0x97	; 151
     346:	fe 4f       	sbci	r31, 0xFE	; 254
     348:	c0 59       	subi	r28, 0x90	; 144
     34a:	de 4f       	sbci	r29, 0xFE	; 254
     34c:	f9 83       	std	Y+1, r31	; 0x01
     34e:	e8 83       	st	Y, r30
     350:	c0 57       	subi	r28, 0x70	; 112
     352:	d1 40       	sbci	r29, 0x01	; 1
     354:	0f 2e       	mov	r0, r31
     356:	f1 e4       	ldi	r31, 0x41	; 65
     358:	4f 2e       	mov	r4, r31
     35a:	f3 e4       	ldi	r31, 0x43	; 67
     35c:	5f 2e       	mov	r5, r31
     35e:	fb e4       	ldi	r31, 0x4B	; 75
     360:	6f 2e       	mov	r6, r31
     362:	f0 2d       	mov	r31, r0
     364:	c2 59       	subi	r28, 0x92	; 146
     366:	de 4f       	sbci	r29, 0xFE	; 254
     368:	78 80       	ld	r7, Y
     36a:	ce 56       	subi	r28, 0x6E	; 110
     36c:	d1 40       	sbci	r29, 0x01	; 1
     36e:	c1 59       	subi	r28, 0x91	; 145
     370:	de 4f       	sbci	r29, 0xFE	; 254
     372:	38 80       	ld	r3, Y
     374:	cf 56       	subi	r28, 0x6F	; 111
     376:	d1 40       	sbci	r29, 0x01	; 1
     378:	c0 59       	subi	r28, 0x90	; 144
     37a:	de 4f       	sbci	r29, 0xFE	; 254
     37c:	28 80       	ld	r2, Y
     37e:	c0 57       	subi	r28, 0x70	; 112
     380:	d1 40       	sbci	r29, 0x01	; 1
     382:	ce 58       	subi	r28, 0x8E	; 142
     384:	de 4f       	sbci	r29, 0xFE	; 254
     386:	f8 83       	st	Y, r31
     388:	c2 57       	subi	r28, 0x72	; 114
     38a:	d1 40       	sbci	r29, 0x01	; 1
     38c:	12 c0       	rjmp	.+36     	; 0x3b2 <_Z8xbeeTaskPv+0xa4>
     38e:	8f e4       	ldi	r24, 0x4F	; 79
     390:	9a e0       	ldi	r25, 0x0A	; 10
     392:	0e 94 ac 12 	call	0x2558	; 0x2558 <_ZN14HardwareSerial4readEv>
     396:	18 2f       	mov	r17, r24
     398:	40 e1       	ldi	r20, 0x10	; 16
     39a:	50 e0       	ldi	r21, 0x00	; 0
     39c:	68 2f       	mov	r22, r24
     39e:	81 e7       	ldi	r24, 0x71	; 113
     3a0:	9a e0       	ldi	r25, 0x0A	; 10
     3a2:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <_ZN5Print7printlnEhi>
     3a6:	61 2f       	mov	r22, r17
     3a8:	89 e8       	ldi	r24, 0x89	; 137
     3aa:	92 e0       	ldi	r25, 0x02	; 2
     3ac:	46 d5       	rcall	.+2700   	; 0xe3a <_ZN3Que7EnqueueEh>
     3ae:	88 23       	and	r24, r24
     3b0:	39 f0       	breq	.+14     	; 0x3c0 <_Z8xbeeTaskPv+0xb2>
     3b2:	8f e4       	ldi	r24, 0x4F	; 79
     3b4:	9a e0       	ldi	r25, 0x0A	; 10
     3b6:	0e 94 6e 12 	call	0x24dc	; 0x24dc <_ZN14HardwareSerial9availableEv>
     3ba:	18 16       	cp	r1, r24
     3bc:	19 06       	cpc	r1, r25
     3be:	3c f3       	brlt	.-50     	; 0x38e <_Z8xbeeTaskPv+0x80>
     3c0:	e5 e0       	ldi	r30, 0x05	; 5
     3c2:	f3 e0       	ldi	r31, 0x03	; 3
     3c4:	c0 80       	ld	r12, Z
     3c6:	d1 80       	ldd	r13, Z+1	; 0x01
     3c8:	1c 14       	cp	r1, r12
     3ca:	1d 04       	cpc	r1, r13
     3cc:	0c f0       	brlt	.+2      	; 0x3d0 <_Z8xbeeTaskPv+0xc2>
     3ce:	a9 c0       	rjmp	.+338    	; 0x522 <_Z8xbeeTaskPv+0x214>
     3d0:	e1 2c       	mov	r14, r1
     3d2:	f1 2c       	mov	r15, r1
     3d4:	00 e0       	ldi	r16, 0x00	; 0
     3d6:	10 e0       	ldi	r17, 0x00	; 0
     3d8:	0f 2e       	mov	r0, r31
     3da:	f3 e0       	ldi	r31, 0x03	; 3
     3dc:	8f 2e       	mov	r8, r31
     3de:	91 2c       	mov	r9, r1
     3e0:	f0 2d       	mov	r31, r0
     3e2:	b7 01       	movw	r22, r14
     3e4:	89 e8       	ldi	r24, 0x89	; 137
     3e6:	92 e0       	ldi	r25, 0x02	; 2
     3e8:	67 d5       	rcall	.+2766   	; 0xeb8 <_ZN3Que4PeekEj>
     3ea:	8e 37       	cpi	r24, 0x7E	; 126
     3ec:	09 f0       	breq	.+2      	; 0x3f0 <_Z8xbeeTaskPv+0xe2>
     3ee:	91 c0       	rjmp	.+290    	; 0x512 <_Z8xbeeTaskPv+0x204>
     3f0:	a7 01       	movw	r20, r14
     3f2:	be 01       	movw	r22, r28
     3f4:	6f 50       	subi	r22, 0x0F	; 15
     3f6:	7f 4f       	sbci	r23, 0xFF	; 255
     3f8:	89 e8       	ldi	r24, 0x89	; 137
     3fa:	92 e0       	ldi	r25, 0x02	; 2
     3fc:	97 d5       	rcall	.+2862   	; 0xf2c <_ZN3Que4CopyEPhi>
     3fe:	27 2d       	mov	r18, r7
     400:	33 2d       	mov	r19, r3
     402:	ac 01       	movw	r20, r24
     404:	be 01       	movw	r22, r28
     406:	6f 50       	subi	r22, 0x0F	; 15
     408:	7f 4f       	sbci	r23, 0xFF	; 255
     40a:	87 e0       	ldi	r24, 0x07	; 7
     40c:	93 e0       	ldi	r25, 0x03	; 3
     40e:	0e 94 b2 10 	call	0x2164	; 0x2164 <_ZN4XBee7ReceiveEPhiS0_>
     412:	5c 01       	movw	r10, r24
     414:	18 16       	cp	r1, r24
     416:	19 06       	cpc	r1, r25
     418:	0c f0       	brlt	.+2      	; 0x41c <_Z8xbeeTaskPv+0x10e>
     41a:	75 c0       	rjmp	.+234    	; 0x506 <_Z8xbeeTaskPv+0x1f8>
     41c:	cf 57       	subi	r28, 0x7F	; 127
     41e:	df 4f       	sbci	r29, 0xFF	; 255
     420:	88 81       	ld	r24, Y
     422:	c1 58       	subi	r28, 0x81	; 129
     424:	d0 40       	sbci	r29, 0x00	; 0
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	c0 97       	sbiw	r24, 0x30	; 48
     42a:	81 30       	cpi	r24, 0x01	; 1
     42c:	91 05       	cpc	r25, r1
     42e:	b9 f0       	breq	.+46     	; 0x45e <_Z8xbeeTaskPv+0x150>
     430:	1c f4       	brge	.+6      	; 0x438 <_Z8xbeeTaskPv+0x12a>
     432:	89 2b       	or	r24, r25
     434:	41 f0       	breq	.+16     	; 0x446 <_Z8xbeeTaskPv+0x138>
     436:	4a c0       	rjmp	.+148    	; 0x4cc <_Z8xbeeTaskPv+0x1be>
     438:	82 30       	cpi	r24, 0x02	; 2
     43a:	91 05       	cpc	r25, r1
     43c:	e1 f0       	breq	.+56     	; 0x476 <_Z8xbeeTaskPv+0x168>
     43e:	03 97       	sbiw	r24, 0x03	; 3
     440:	09 f0       	breq	.+2      	; 0x444 <_Z8xbeeTaskPv+0x136>
     442:	44 c0       	rjmp	.+136    	; 0x4cc <_Z8xbeeTaskPv+0x1be>
     444:	25 c0       	rjmp	.+74     	; 0x490 <_Z8xbeeTaskPv+0x182>
     446:	c7 59       	subi	r28, 0x97	; 151
     448:	de 4f       	sbci	r29, 0xFE	; 254
     44a:	48 82       	st	Y, r4
     44c:	59 82       	std	Y+1, r5	; 0x01
     44e:	6a 82       	std	Y+2, r6	; 0x02
     450:	c9 56       	subi	r28, 0x69	; 105
     452:	d1 40       	sbci	r29, 0x01	; 1
     454:	f1 e0       	ldi	r31, 0x01	; 1
     456:	f0 93 87 02 	sts	0x0287, r31
     45a:	a4 01       	movw	r20, r8
     45c:	39 c0       	rjmp	.+114    	; 0x4d0 <_Z8xbeeTaskPv+0x1c2>
     45e:	c7 59       	subi	r28, 0x97	; 151
     460:	de 4f       	sbci	r29, 0xFE	; 254
     462:	48 82       	st	Y, r4
     464:	59 82       	std	Y+1, r5	; 0x01
     466:	6a 82       	std	Y+2, r6	; 0x02
     468:	c9 56       	subi	r28, 0x69	; 105
     46a:	d1 40       	sbci	r29, 0x01	; 1
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	80 93 86 02 	sts	0x0286, r24
     472:	a4 01       	movw	r20, r8
     474:	2d c0       	rjmp	.+90     	; 0x4d0 <_Z8xbeeTaskPv+0x1c2>
     476:	c7 59       	subi	r28, 0x97	; 151
     478:	de 4f       	sbci	r29, 0xFE	; 254
     47a:	48 82       	st	Y, r4
     47c:	59 82       	std	Y+1, r5	; 0x01
     47e:	6a 82       	std	Y+2, r6	; 0x02
     480:	c9 56       	subi	r28, 0x69	; 105
     482:	d1 40       	sbci	r29, 0x01	; 1
     484:	10 92 86 02 	sts	0x0286, r1
     488:	10 92 87 02 	sts	0x0287, r1
     48c:	a4 01       	movw	r20, r8
     48e:	20 c0       	rjmp	.+64     	; 0x4d0 <_Z8xbeeTaskPv+0x1c2>
     490:	c7 59       	subi	r28, 0x97	; 151
     492:	de 4f       	sbci	r29, 0xFE	; 254
     494:	48 82       	st	Y, r4
     496:	59 82       	std	Y+1, r5	; 0x01
     498:	6a 82       	std	Y+2, r6	; 0x02
     49a:	c9 56       	subi	r28, 0x69	; 105
     49c:	d1 40       	sbci	r29, 0x01	; 1
     49e:	ce 57       	subi	r28, 0x7E	; 126
     4a0:	df 4f       	sbci	r29, 0xFF	; 255
     4a2:	88 81       	ld	r24, Y
     4a4:	c2 58       	subi	r28, 0x82	; 130
     4a6:	d0 40       	sbci	r29, 0x00	; 0
     4a8:	8c 34       	cpi	r24, 0x4C	; 76
     4aa:	41 f4       	brne	.+16     	; 0x4bc <_Z8xbeeTaskPv+0x1ae>
     4ac:	68 e2       	ldi	r22, 0x28	; 40
     4ae:	72 e0       	ldi	r23, 0x02	; 2
     4b0:	81 e7       	ldi	r24, 0x71	; 113
     4b2:	9a e0       	ldi	r25, 0x0A	; 10
     4b4:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     4b8:	a4 01       	movw	r20, r8
     4ba:	0a c0       	rjmp	.+20     	; 0x4d0 <_Z8xbeeTaskPv+0x1c2>
     4bc:	6d e2       	ldi	r22, 0x2D	; 45
     4be:	72 e0       	ldi	r23, 0x02	; 2
     4c0:	81 e7       	ldi	r24, 0x71	; 113
     4c2:	9a e0       	ldi	r25, 0x0A	; 10
     4c4:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     4c8:	a4 01       	movw	r20, r8
     4ca:	02 c0       	rjmp	.+4      	; 0x4d0 <_Z8xbeeTaskPv+0x1c2>
     4cc:	40 e0       	ldi	r20, 0x00	; 0
     4ce:	50 e0       	ldi	r21, 0x00	; 0
     4d0:	00 e0       	ldi	r16, 0x00	; 0
     4d2:	10 e0       	ldi	r17, 0x00	; 0
     4d4:	9e 01       	movw	r18, r28
     4d6:	2f 5f       	subi	r18, 0xFF	; 255
     4d8:	3f 4f       	sbci	r19, 0xFF	; 255
     4da:	62 2d       	mov	r22, r2
     4dc:	ce 58       	subi	r28, 0x8E	; 142
     4de:	de 4f       	sbci	r29, 0xFE	; 254
     4e0:	78 81       	ld	r23, Y
     4e2:	c2 57       	subi	r28, 0x72	; 114
     4e4:	d1 40       	sbci	r29, 0x01	; 1
     4e6:	87 e0       	ldi	r24, 0x07	; 7
     4e8:	93 e0       	ldi	r25, 0x03	; 3
     4ea:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN4XBee4SendEPhiS0_i>
     4ee:	ac 01       	movw	r20, r24
     4f0:	be 01       	movw	r22, r28
     4f2:	6f 5f       	subi	r22, 0xFF	; 255
     4f4:	7f 4f       	sbci	r23, 0xFF	; 255
     4f6:	8f e4       	ldi	r24, 0x4F	; 79
     4f8:	9a e0       	ldi	r25, 0x0A	; 10
     4fa:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <_ZN5Print5writeEPKhj>
     4fe:	ea 0c       	add	r14, r10
     500:	fb 1c       	adc	r15, r11
     502:	87 01       	movw	r16, r14
     504:	06 c0       	rjmp	.+12     	; 0x512 <_Z8xbeeTaskPv+0x204>
     506:	1e 14       	cp	r1, r14
     508:	1f 04       	cpc	r1, r15
     50a:	1c f4       	brge	.+6      	; 0x512 <_Z8xbeeTaskPv+0x204>
     50c:	87 01       	movw	r16, r14
     50e:	01 50       	subi	r16, 0x01	; 1
     510:	11 09       	sbc	r17, r1
     512:	9f ef       	ldi	r25, 0xFF	; 255
     514:	e9 1a       	sub	r14, r25
     516:	f9 0a       	sbc	r15, r25
     518:	ec 14       	cp	r14, r12
     51a:	fd 04       	cpc	r15, r13
     51c:	0c f4       	brge	.+2      	; 0x520 <_Z8xbeeTaskPv+0x212>
     51e:	61 cf       	rjmp	.-318    	; 0x3e2 <_Z8xbeeTaskPv+0xd4>
     520:	02 c0       	rjmp	.+4      	; 0x526 <_Z8xbeeTaskPv+0x218>
     522:	00 e0       	ldi	r16, 0x00	; 0
     524:	10 e0       	ldi	r17, 0x00	; 0
     526:	b8 01       	movw	r22, r16
     528:	89 e8       	ldi	r24, 0x89	; 137
     52a:	92 e0       	ldi	r25, 0x02	; 2
     52c:	68 d5       	rcall	.+2768   	; 0xffe <_ZN3Que5ClearEj>
     52e:	88 ec       	ldi	r24, 0xC8	; 200
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vTaskDelay>
     536:	3d cf       	rjmp	.-390    	; 0x3b2 <_Z8xbeeTaskPv+0xa4>

00000538 <_Z8flexTaskPv>:
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	cd b7       	in	r28, 0x3d	; 61
     53e:	de b7       	in	r29, 0x3e	; 62
     540:	ca 57       	subi	r28, 0x7A	; 122
     542:	d1 09       	sbc	r29, r1
     544:	0f b6       	in	r0, 0x3f	; 63
     546:	f8 94       	cli
     548:	de bf       	out	0x3e, r29	; 62
     54a:	0f be       	out	0x3f, r0	; 63
     54c:	cd bf       	out	0x3d, r28	; 61
     54e:	63 e3       	ldi	r22, 0x33	; 51
     550:	72 e0       	ldi	r23, 0x02	; 2
     552:	81 e7       	ldi	r24, 0x71	; 113
     554:	9a e0       	ldi	r25, 0x0A	; 10
     556:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     55a:	0f 2e       	mov	r0, r31
     55c:	f6 e1       	ldi	r31, 0x16	; 22
     55e:	af 2e       	mov	r10, r31
     560:	f2 e0       	ldi	r31, 0x02	; 2
     562:	bf 2e       	mov	r11, r31
     564:	f0 2d       	mov	r31, r0
     566:	0f 2e       	mov	r0, r31
     568:	f4 e3       	ldi	r31, 0x34	; 52
     56a:	9f 2e       	mov	r9, r31
     56c:	f0 2d       	mov	r31, r0
     56e:	0f 2e       	mov	r0, r31
     570:	f0 e3       	ldi	r31, 0x30	; 48
     572:	ef 2e       	mov	r14, r31
     574:	f3 e0       	ldi	r31, 0x03	; 3
     576:	ff 2e       	mov	r15, r31
     578:	f0 2d       	mov	r31, r0
     57a:	0f 2e       	mov	r0, r31
     57c:	f2 e3       	ldi	r31, 0x32	; 50
     57e:	cf 2e       	mov	r12, r31
     580:	f3 e0       	ldi	r31, 0x03	; 3
     582:	df 2e       	mov	r13, r31
     584:	f0 2d       	mov	r31, r0
     586:	0f 2e       	mov	r0, r31
     588:	f0 e3       	ldi	r31, 0x30	; 48
     58a:	6f 2e       	mov	r6, r31
     58c:	f0 2d       	mov	r31, r0
     58e:	77 24       	eor	r7, r7
     590:	73 94       	inc	r7
     592:	0f 2e       	mov	r0, r31
     594:	f1 e3       	ldi	r31, 0x31	; 49
     596:	8f 2e       	mov	r8, r31
     598:	f0 2d       	mov	r31, r0
     59a:	80 91 87 02 	lds	r24, 0x0287
     59e:	88 23       	and	r24, r24
     5a0:	09 f4       	brne	.+2      	; 0x5a4 <_Z8flexTaskPv+0x6c>
     5a2:	82 c0       	rjmp	.+260    	; 0x6a8 <_Z8flexTaskPv+0x170>
     5a4:	f5 01       	movw	r30, r10
     5a6:	80 81       	ld	r24, Z
     5a8:	0e 94 8d 18 	call	0x311a	; 0x311a <analogRead>
     5ac:	ea 96       	adiw	r28, 0x3a	; 58
     5ae:	9f ae       	std	Y+63, r9	; 0x3f
     5b0:	ea 97       	sbiw	r28, 0x3a	; 58
     5b2:	8a 3e       	cpi	r24, 0xEA	; 234
     5b4:	f1 e0       	ldi	r31, 0x01	; 1
     5b6:	9f 07       	cpc	r25, r31
     5b8:	bc f5       	brge	.+110    	; 0x628 <_Z8flexTaskPv+0xf0>
     5ba:	20 91 88 02 	lds	r18, 0x0288
     5be:	21 11       	cpse	r18, r1
     5c0:	33 c0       	rjmp	.+102    	; 0x628 <_Z8flexTaskPv+0xf0>
     5c2:	f7 01       	movw	r30, r14
     5c4:	80 81       	ld	r24, Z
     5c6:	91 81       	ldd	r25, Z+1	; 0x01
     5c8:	85 30       	cpi	r24, 0x05	; 5
     5ca:	91 05       	cpc	r25, r1
     5cc:	28 f1       	brcs	.+74     	; 0x618 <_Z8flexTaskPv+0xe0>
     5ce:	70 92 88 02 	sts	0x0288, r7
     5d2:	eb 96       	adiw	r28, 0x3b	; 59
     5d4:	8f ae       	std	Y+63, r8	; 0x3f
     5d6:	eb 97       	sbiw	r28, 0x3b	; 59
     5d8:	00 e0       	ldi	r16, 0x00	; 0
     5da:	10 e0       	ldi	r17, 0x00	; 0
     5dc:	9e 01       	movw	r18, r28
     5de:	2f 5f       	subi	r18, 0xFF	; 255
     5e0:	3f 4f       	sbci	r19, 0xFF	; 255
     5e2:	42 e0       	ldi	r20, 0x02	; 2
     5e4:	50 e0       	ldi	r21, 0x00	; 0
     5e6:	be 01       	movw	r22, r28
     5e8:	67 58       	subi	r22, 0x87	; 135
     5ea:	7f 4f       	sbci	r23, 0xFF	; 255
     5ec:	87 e0       	ldi	r24, 0x07	; 7
     5ee:	93 e0       	ldi	r25, 0x03	; 3
     5f0:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN4XBee4SendEPhiS0_i>
     5f4:	ac 01       	movw	r20, r24
     5f6:	be 01       	movw	r22, r28
     5f8:	6f 5f       	subi	r22, 0xFF	; 255
     5fa:	7f 4f       	sbci	r23, 0xFF	; 255
     5fc:	8f e4       	ldi	r24, 0x4F	; 79
     5fe:	9a e0       	ldi	r25, 0x0A	; 10
     600:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <_ZN5Print5writeEPKhj>
     604:	60 e4       	ldi	r22, 0x40	; 64
     606:	72 e0       	ldi	r23, 0x02	; 2
     608:	81 e7       	ldi	r24, 0x71	; 113
     60a:	9a e0       	ldi	r25, 0x0A	; 10
     60c:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     610:	f7 01       	movw	r30, r14
     612:	11 82       	std	Z+1, r1	; 0x01
     614:	10 82       	st	Z, r1
     616:	48 c0       	rjmp	.+144    	; 0x6a8 <_Z8flexTaskPv+0x170>
     618:	01 96       	adiw	r24, 0x01	; 1
     61a:	f7 01       	movw	r30, r14
     61c:	91 83       	std	Z+1, r25	; 0x01
     61e:	80 83       	st	Z, r24
     620:	f6 01       	movw	r30, r12
     622:	11 82       	std	Z+1, r1	; 0x01
     624:	10 82       	st	Z, r1
     626:	40 c0       	rjmp	.+128    	; 0x6a8 <_Z8flexTaskPv+0x170>
     628:	84 3f       	cpi	r24, 0xF4	; 244
     62a:	91 40       	sbci	r25, 0x01	; 1
     62c:	bc f1       	brlt	.+110    	; 0x69c <_Z8flexTaskPv+0x164>
     62e:	80 91 88 02 	lds	r24, 0x0288
     632:	88 23       	and	r24, r24
     634:	99 f1       	breq	.+102    	; 0x69c <_Z8flexTaskPv+0x164>
     636:	f6 01       	movw	r30, r12
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	85 30       	cpi	r24, 0x05	; 5
     63e:	91 05       	cpc	r25, r1
     640:	28 f1       	brcs	.+74     	; 0x68c <_Z8flexTaskPv+0x154>
     642:	10 92 88 02 	sts	0x0288, r1
     646:	eb 96       	adiw	r28, 0x3b	; 59
     648:	6f ae       	std	Y+63, r6	; 0x3f
     64a:	eb 97       	sbiw	r28, 0x3b	; 59
     64c:	00 e0       	ldi	r16, 0x00	; 0
     64e:	10 e0       	ldi	r17, 0x00	; 0
     650:	9e 01       	movw	r18, r28
     652:	2f 5f       	subi	r18, 0xFF	; 255
     654:	3f 4f       	sbci	r19, 0xFF	; 255
     656:	42 e0       	ldi	r20, 0x02	; 2
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	be 01       	movw	r22, r28
     65c:	67 58       	subi	r22, 0x87	; 135
     65e:	7f 4f       	sbci	r23, 0xFF	; 255
     660:	87 e0       	ldi	r24, 0x07	; 7
     662:	93 e0       	ldi	r25, 0x03	; 3
     664:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN4XBee4SendEPhiS0_i>
     668:	ac 01       	movw	r20, r24
     66a:	be 01       	movw	r22, r28
     66c:	6f 5f       	subi	r22, 0xFF	; 255
     66e:	7f 4f       	sbci	r23, 0xFF	; 255
     670:	8f e4       	ldi	r24, 0x4F	; 79
     672:	9a e0       	ldi	r25, 0x0A	; 10
     674:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <_ZN5Print5writeEPKhj>
     678:	63 e4       	ldi	r22, 0x43	; 67
     67a:	72 e0       	ldi	r23, 0x02	; 2
     67c:	81 e7       	ldi	r24, 0x71	; 113
     67e:	9a e0       	ldi	r25, 0x0A	; 10
     680:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     684:	f6 01       	movw	r30, r12
     686:	11 82       	std	Z+1, r1	; 0x01
     688:	10 82       	st	Z, r1
     68a:	0e c0       	rjmp	.+28     	; 0x6a8 <_Z8flexTaskPv+0x170>
     68c:	01 96       	adiw	r24, 0x01	; 1
     68e:	f6 01       	movw	r30, r12
     690:	91 83       	std	Z+1, r25	; 0x01
     692:	80 83       	st	Z, r24
     694:	f7 01       	movw	r30, r14
     696:	11 82       	std	Z+1, r1	; 0x01
     698:	10 82       	st	Z, r1
     69a:	06 c0       	rjmp	.+12     	; 0x6a8 <_Z8flexTaskPv+0x170>
     69c:	f7 01       	movw	r30, r14
     69e:	11 82       	std	Z+1, r1	; 0x01
     6a0:	10 82       	st	Z, r1
     6a2:	f6 01       	movw	r30, r12
     6a4:	11 82       	std	Z+1, r1	; 0x01
     6a6:	10 82       	st	Z, r1
     6a8:	88 ec       	ldi	r24, 0xC8	; 200
     6aa:	90 e0       	ldi	r25, 0x00	; 0
     6ac:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vTaskDelay>
     6b0:	74 cf       	rjmp	.-280    	; 0x59a <_Z8flexTaskPv+0x62>

000006b2 <_Z15writeToActuatorff>:
     6b2:	8f 92       	push	r8
     6b4:	9f 92       	push	r9
     6b6:	af 92       	push	r10
     6b8:	bf 92       	push	r11
     6ba:	cf 92       	push	r12
     6bc:	df 92       	push	r13
     6be:	ef 92       	push	r14
     6c0:	ff 92       	push	r15
     6c2:	cf 93       	push	r28
     6c4:	df 93       	push	r29
     6c6:	4b 01       	movw	r8, r22
     6c8:	5c 01       	movw	r10, r24
     6ca:	69 01       	movw	r12, r18
     6cc:	7a 01       	movw	r14, r20
     6ce:	80 91 86 02 	lds	r24, 0x0286
     6d2:	88 23       	and	r24, r24
     6d4:	09 f4       	brne	.+2      	; 0x6d8 <_Z15writeToActuatorff+0x26>
     6d6:	4c c0       	rjmp	.+152    	; 0x770 <_Z15writeToActuatorff+0xbe>
     6d8:	80 91 87 02 	lds	r24, 0x0287
     6dc:	88 23       	and	r24, r24
     6de:	09 f4       	brne	.+2      	; 0x6e2 <_Z15writeToActuatorff+0x30>
     6e0:	47 c0       	rjmp	.+142    	; 0x770 <_Z15writeToActuatorff+0xbe>
     6e2:	80 91 88 02 	lds	r24, 0x0288
     6e6:	88 23       	and	r24, r24
     6e8:	09 f4       	brne	.+2      	; 0x6ec <_Z15writeToActuatorff+0x3a>
     6ea:	42 c0       	rjmp	.+132    	; 0x770 <_Z15writeToActuatorff+0xbe>
     6ec:	20 e0       	ldi	r18, 0x00	; 0
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	40 e8       	ldi	r20, 0x80	; 128
     6f2:	5f e3       	ldi	r21, 0x3F	; 63
     6f4:	c5 01       	movw	r24, r10
     6f6:	b4 01       	movw	r22, r8
     6f8:	0e 94 07 12 	call	0x240e	; 0x240e <__gesf2>
     6fc:	18 16       	cp	r1, r24
     6fe:	bc f4       	brge	.+46     	; 0x72e <_Z15writeToActuatorff+0x7c>
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	40 e7       	ldi	r20, 0x70	; 112
     706:	52 e4       	ldi	r21, 0x42	; 66
     708:	c5 01       	movw	r24, r10
     70a:	b4 01       	movw	r22, r8
     70c:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <__cmpsf2>
     710:	18 16       	cp	r1, r24
     712:	6c f0       	brlt	.+26     	; 0x72e <_Z15writeToActuatorff+0x7c>
     714:	cc e0       	ldi	r28, 0x0C	; 12
     716:	d2 e0       	ldi	r29, 0x02	; 2
     718:	61 e0       	ldi	r22, 0x01	; 1
     71a:	88 81       	ld	r24, Y
     71c:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
     720:	84 ef       	ldi	r24, 0xF4	; 244
     722:	91 e0       	ldi	r25, 0x01	; 1
     724:	a3 dd       	rcall	.-1210   	; 0x26c <_Z19delayInMilliSecondsi>
     726:	60 e0       	ldi	r22, 0x00	; 0
     728:	88 81       	ld	r24, Y
     72a:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	40 e8       	ldi	r20, 0x80	; 128
     734:	5f e3       	ldi	r21, 0x3F	; 63
     736:	c7 01       	movw	r24, r14
     738:	b6 01       	movw	r22, r12
     73a:	0e 94 07 12 	call	0x240e	; 0x240e <__gesf2>
     73e:	18 16       	cp	r1, r24
     740:	bc f4       	brge	.+46     	; 0x770 <_Z15writeToActuatorff+0xbe>
     742:	20 e0       	ldi	r18, 0x00	; 0
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	40 e7       	ldi	r20, 0x70	; 112
     748:	52 e4       	ldi	r21, 0x42	; 66
     74a:	c7 01       	movw	r24, r14
     74c:	b6 01       	movw	r22, r12
     74e:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <__cmpsf2>
     752:	18 16       	cp	r1, r24
     754:	6c f0       	brlt	.+26     	; 0x770 <_Z15writeToActuatorff+0xbe>
     756:	ca e0       	ldi	r28, 0x0A	; 10
     758:	d2 e0       	ldi	r29, 0x02	; 2
     75a:	61 e0       	ldi	r22, 0x01	; 1
     75c:	88 81       	ld	r24, Y
     75e:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
     762:	84 ef       	ldi	r24, 0xF4	; 244
     764:	91 e0       	ldi	r25, 0x01	; 1
     766:	82 dd       	rcall	.-1276   	; 0x26c <_Z19delayInMilliSecondsi>
     768:	60 e0       	ldi	r22, 0x00	; 0
     76a:	88 81       	ld	r24, Y
     76c:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	ff 90       	pop	r15
     776:	ef 90       	pop	r14
     778:	df 90       	pop	r13
     77a:	cf 90       	pop	r12
     77c:	bf 90       	pop	r11
     77e:	af 90       	pop	r10
     780:	9f 90       	pop	r9
     782:	8f 90       	pop	r8
     784:	08 95       	ret

00000786 <_Z6ssTaskPv>:
     786:	67 e4       	ldi	r22, 0x47	; 71
     788:	72 e0       	ldi	r23, 0x02	; 2
     78a:	81 e7       	ldi	r24, 0x71	; 113
     78c:	9a e0       	ldi	r25, 0x0A	; 10
     78e:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
     792:	80 91 87 02 	lds	r24, 0x0287
     796:	88 23       	and	r24, r24
     798:	09 f4       	brne	.+2      	; 0x79c <_Z6ssTaskPv+0x16>
     79a:	48 c0       	rjmp	.+144    	; 0x82c <_Z6ssTaskPv+0xa6>
     79c:	80 91 88 02 	lds	r24, 0x0288
     7a0:	88 23       	and	r24, r24
     7a2:	09 f4       	brne	.+2      	; 0x7a6 <_Z6ssTaskPv+0x20>
     7a4:	43 c0       	rjmp	.+134    	; 0x82c <_Z6ssTaskPv+0xa6>
     7a6:	84 e2       	ldi	r24, 0x24	; 36
     7a8:	93 e0       	ldi	r25, 0x03	; 3
     7aa:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <_ZN10Ultrasonic6timingEv>
     7ae:	ab 01       	movw	r20, r22
     7b0:	bc 01       	movw	r22, r24
     7b2:	40 93 14 03 	sts	0x0314, r20
     7b6:	50 93 15 03 	sts	0x0315, r21
     7ba:	60 93 16 03 	sts	0x0316, r22
     7be:	70 93 17 03 	sts	0x0317, r23
     7c2:	21 e0       	ldi	r18, 0x01	; 1
     7c4:	30 e0       	ldi	r19, 0x00	; 0
     7c6:	84 e2       	ldi	r24, 0x24	; 36
     7c8:	93 e0       	ldi	r25, 0x03	; 3
     7ca:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_ZN10Ultrasonic12CalcDistanceEli>
     7ce:	60 93 0c 03 	sts	0x030C, r22
     7d2:	70 93 0d 03 	sts	0x030D, r23
     7d6:	80 93 0e 03 	sts	0x030E, r24
     7da:	90 93 0f 03 	sts	0x030F, r25
     7de:	88 e1       	ldi	r24, 0x18	; 24
     7e0:	93 e0       	ldi	r25, 0x03	; 3
     7e2:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <_ZN10Ultrasonic6timingEv>
     7e6:	ab 01       	movw	r20, r22
     7e8:	bc 01       	movw	r22, r24
     7ea:	40 93 10 03 	sts	0x0310, r20
     7ee:	50 93 11 03 	sts	0x0311, r21
     7f2:	60 93 12 03 	sts	0x0312, r22
     7f6:	70 93 13 03 	sts	0x0313, r23
     7fa:	21 e0       	ldi	r18, 0x01	; 1
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	88 e1       	ldi	r24, 0x18	; 24
     800:	93 e0       	ldi	r25, 0x03	; 3
     802:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_ZN10Ultrasonic12CalcDistanceEli>
     806:	9b 01       	movw	r18, r22
     808:	ac 01       	movw	r20, r24
     80a:	60 93 08 03 	sts	0x0308, r22
     80e:	70 93 09 03 	sts	0x0309, r23
     812:	80 93 0a 03 	sts	0x030A, r24
     816:	90 93 0b 03 	sts	0x030B, r25
     81a:	60 91 0c 03 	lds	r22, 0x030C
     81e:	70 91 0d 03 	lds	r23, 0x030D
     822:	80 91 0e 03 	lds	r24, 0x030E
     826:	90 91 0f 03 	lds	r25, 0x030F
     82a:	43 df       	rcall	.-378    	; 0x6b2 <_Z15writeToActuatorff>
     82c:	88 ec       	ldi	r24, 0xC8	; 200
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vTaskDelay>
     834:	ae cf       	rjmp	.-164    	; 0x792 <_Z6ssTaskPv+0xc>

00000836 <main>:
	// 	Do 	nothing.
}

int main()
{
     836:	af 92       	push	r10
     838:	bf 92       	push	r11
     83a:	cf 92       	push	r12
     83c:	df 92       	push	r13
     83e:	ef 92       	push	r14
     840:	ff 92       	push	r15
     842:	0f 93       	push	r16
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	00 d0       	rcall	.+0      	; 0x84a <main+0x14>
     84a:	00 d0       	rcall	.+0      	; 0x84c <main+0x16>
     84c:	cd b7       	in	r28, 0x3d	; 61
     84e:	de b7       	in	r29, 0x3e	; 62
	init();
     850:	0e 94 2b 18 	call	0x3056	; 0x3056 <init>
	//deviceRdy = 1; // for debugging w/o rpi
	//naviRdy = 1; // for debugging w/o rpi
	Serial1.begin(9600);
     854:	40 e8       	ldi	r20, 0x80	; 128
     856:	55 e2       	ldi	r21, 0x25	; 37
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	70 e0       	ldi	r23, 0x00	; 0
     85c:	8f e4       	ldi	r24, 0x4F	; 79
     85e:	9a e0       	ldi	r25, 0x0A	; 10
     860:	0e 94 65 15 	call	0x2aca	; 0x2aca <_ZN14HardwareSerial5beginEm>
	Serial.begin(9600);
     864:	40 e8       	ldi	r20, 0x80	; 128
     866:	55 e2       	ldi	r21, 0x25	; 37
     868:	60 e0       	ldi	r22, 0x00	; 0
     86a:	70 e0       	ldi	r23, 0x00	; 0
     86c:	81 e7       	ldi	r24, 0x71	; 113
     86e:	9a e0       	ldi	r25, 0x0A	; 10
     870:	0e 94 65 15 	call	0x2aca	; 0x2aca <_ZN14HardwareSerial5beginEm>
	Serial.println("START");
     874:	65 e5       	ldi	r22, 0x55	; 85
     876:	72 e0       	ldi	r23, 0x02	; 2
     878:	81 e7       	ldi	r24, 0x71	; 113
     87a:	9a e0       	ldi	r25, 0x0A	; 10
     87c:	0e 94 13 17 	call	0x2e26	; 0x2e26 <_ZN5Print7printlnEPKc>
	
	pinMode(7, OUTPUT);
     880:	61 e0       	ldi	r22, 0x01	; 1
     882:	87 e0       	ldi	r24, 0x07	; 7
     884:	0e 94 35 19 	call	0x326a	; 0x326a <pinMode>
	pinMode(8, OUTPUT);
     888:	61 e0       	ldi	r22, 0x01	; 1
     88a:	88 e0       	ldi	r24, 0x08	; 8
     88c:	0e 94 35 19 	call	0x326a	; 0x326a <pinMode>
	
	TaskHandle_t taskSS, taskFlex, taskXBee;
	xTaskCreate(ssTask, "ssTask", STACK_DEPTH, NULL, 5, &taskSS);
     890:	a1 2c       	mov	r10, r1
     892:	b1 2c       	mov	r11, r1
     894:	c1 2c       	mov	r12, r1
     896:	d1 2c       	mov	r13, r1
     898:	0f 2e       	mov	r0, r31
     89a:	f5 e0       	ldi	r31, 0x05	; 5
     89c:	ef 2e       	mov	r14, r31
     89e:	f1 2c       	mov	r15, r1
     8a0:	f0 2d       	mov	r31, r0
     8a2:	ec 0e       	add	r14, r28
     8a4:	fd 1e       	adc	r15, r29
     8a6:	05 e0       	ldi	r16, 0x05	; 5
     8a8:	20 e0       	ldi	r18, 0x00	; 0
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	40 e0       	ldi	r20, 0x00	; 0
     8ae:	51 e0       	ldi	r21, 0x01	; 1
     8b0:	6b e5       	ldi	r22, 0x5B	; 91
     8b2:	72 e0       	ldi	r23, 0x02	; 2
     8b4:	83 ec       	ldi	r24, 0xC3	; 195
     8b6:	93 e0       	ldi	r25, 0x03	; 3
     8b8:	e2 d7       	rcall	.+4036   	; 0x187e <xTaskGenericCreate>
	xTaskCreate(flexTask, "Flex", STACK_DEPTH, NULL, 5, &taskFlex);
     8ba:	0f 2e       	mov	r0, r31
     8bc:	f3 e0       	ldi	r31, 0x03	; 3
     8be:	ef 2e       	mov	r14, r31
     8c0:	f1 2c       	mov	r15, r1
     8c2:	f0 2d       	mov	r31, r0
     8c4:	ec 0e       	add	r14, r28
     8c6:	fd 1e       	adc	r15, r29
     8c8:	20 e0       	ldi	r18, 0x00	; 0
     8ca:	30 e0       	ldi	r19, 0x00	; 0
     8cc:	40 e0       	ldi	r20, 0x00	; 0
     8ce:	51 e0       	ldi	r21, 0x01	; 1
     8d0:	62 e6       	ldi	r22, 0x62	; 98
     8d2:	72 e0       	ldi	r23, 0x02	; 2
     8d4:	8c e9       	ldi	r24, 0x9C	; 156
     8d6:	92 e0       	ldi	r25, 0x02	; 2
     8d8:	d2 d7       	rcall	.+4004   	; 0x187e <xTaskGenericCreate>
	xTaskCreate(xbeeTask,"xbeeTask", STACK_DEPTH*2, NULL, 5, &taskXBee);
     8da:	ee 24       	eor	r14, r14
     8dc:	e3 94       	inc	r14
     8de:	f1 2c       	mov	r15, r1
     8e0:	ec 0e       	add	r14, r28
     8e2:	fd 1e       	adc	r15, r29
     8e4:	20 e0       	ldi	r18, 0x00	; 0
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	40 e0       	ldi	r20, 0x00	; 0
     8ea:	52 e0       	ldi	r21, 0x02	; 2
     8ec:	67 e6       	ldi	r22, 0x67	; 103
     8ee:	72 e0       	ldi	r23, 0x02	; 2
     8f0:	87 e8       	ldi	r24, 0x87	; 135
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	c4 d7       	rcall	.+3976   	; 0x187e <xTaskGenericCreate>
	//xTaskCreate(task2, "test", STACK_DEPTH, NULL, 5, NULL);

	vTaskStartScheduler();
     8f6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskStartScheduler>
     8fa:	80 e0       	ldi	r24, 0x00	; 0
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	26 96       	adiw	r28, 0x06	; 6
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	de bf       	out	0x3e, r29	; 62
     906:	0f be       	out	0x3f, r0	; 63
     908:	cd bf       	out	0x3d, r28	; 61
     90a:	df 91       	pop	r29
     90c:	cf 91       	pop	r28
     90e:	0f 91       	pop	r16
     910:	ff 90       	pop	r15
     912:	ef 90       	pop	r14
     914:	df 90       	pop	r13
     916:	cf 90       	pop	r12
     918:	bf 90       	pop	r11
     91a:	af 90       	pop	r10
     91c:	08 95       	ret

0000091e <_GLOBAL__sub_I_flexpin>:
     91e:	6f ef       	ldi	r22, 0xFF	; 255
     920:	7f ef       	ldi	r23, 0xFF	; 255
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	c9 cc       	rjmp	.-1646   	; 0x2ba <_Z41__static_initialization_and_destruction_0ii>

00000928 <_GLOBAL__sub_D_flexpin>:
     928:	6f ef       	ldi	r22, 0xFF	; 255
     92a:	7f ef       	ldi	r23, 0xFF	; 255
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	c4 cc       	rjmp	.-1656   	; 0x2ba <_Z41__static_initialization_and_destruction_0ii>

00000932 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     932:	cf 93       	push	r28
     934:	df 93       	push	r29
     936:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     938:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     93c:	80 91 34 03 	lds	r24, 0x0334
     940:	90 91 35 03 	lds	r25, 0x0335
     944:	89 2b       	or	r24, r25
     946:	31 f4       	brne	.+12     	; 0x954 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     948:	87 e3       	ldi	r24, 0x37	; 55
     94a:	93 e0       	ldi	r25, 0x03	; 3
     94c:	90 93 35 03 	sts	0x0335, r25
     950:	80 93 34 03 	sts	0x0334, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     954:	40 91 12 09 	lds	r20, 0x0912
     958:	50 91 13 09 	lds	r21, 0x0913
     95c:	9e 01       	movw	r18, r28
     95e:	24 0f       	add	r18, r20
     960:	35 1f       	adc	r19, r21
     962:	2b 3d       	cpi	r18, 0xDB	; 219
     964:	85 e0       	ldi	r24, 0x05	; 5
     966:	38 07       	cpc	r19, r24
     968:	70 f4       	brcc	.+28     	; 0x986 <pvPortMalloc+0x54>
     96a:	42 17       	cp	r20, r18
     96c:	53 07       	cpc	r21, r19
     96e:	70 f4       	brcc	.+28     	; 0x98c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     970:	c0 91 34 03 	lds	r28, 0x0334
     974:	d0 91 35 03 	lds	r29, 0x0335
     978:	c4 0f       	add	r28, r20
     97a:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     97c:	30 93 13 09 	sts	0x0913, r19
     980:	20 93 12 09 	sts	0x0912, r18
     984:	05 c0       	rjmp	.+10     	; 0x990 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     986:	c0 e0       	ldi	r28, 0x00	; 0
     988:	d0 e0       	ldi	r29, 0x00	; 0
     98a:	02 c0       	rjmp	.+4      	; 0x990 <pvPortMalloc+0x5e>
     98c:	c0 e0       	ldi	r28, 0x00	; 0
     98e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     990:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     994:	8c 2f       	mov	r24, r28
     996:	9d 2f       	mov	r25, r29
     998:	df 91       	pop	r29
     99a:	cf 91       	pop	r28
     99c:	08 95       	ret

0000099e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     99e:	08 95       	ret

000009a0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9a0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9a2:	03 96       	adiw	r24, 0x03	; 3
     9a4:	92 83       	std	Z+2, r25	; 0x02
     9a6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9a8:	2f ef       	ldi	r18, 0xFF	; 255
     9aa:	3f ef       	ldi	r19, 0xFF	; 255
     9ac:	34 83       	std	Z+4, r19	; 0x04
     9ae:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9b0:	96 83       	std	Z+6, r25	; 0x06
     9b2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9b4:	90 87       	std	Z+8, r25	; 0x08
     9b6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9b8:	10 82       	st	Z, r1
     9ba:	08 95       	ret

000009bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9bc:	fc 01       	movw	r30, r24
     9be:	11 86       	std	Z+9, r1	; 0x09
     9c0:	10 86       	std	Z+8, r1	; 0x08
     9c2:	08 95       	ret

000009c4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	9c 01       	movw	r18, r24
     9ca:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9cc:	dc 01       	movw	r26, r24
     9ce:	11 96       	adiw	r26, 0x01	; 1
     9d0:	cd 91       	ld	r28, X+
     9d2:	dc 91       	ld	r29, X
     9d4:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9d6:	d3 83       	std	Z+3, r29	; 0x03
     9d8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9da:	8c 81       	ldd	r24, Y+4	; 0x04
     9dc:	9d 81       	ldd	r25, Y+5	; 0x05
     9de:	95 83       	std	Z+5, r25	; 0x05
     9e0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9e2:	8c 81       	ldd	r24, Y+4	; 0x04
     9e4:	9d 81       	ldd	r25, Y+5	; 0x05
     9e6:	dc 01       	movw	r26, r24
     9e8:	13 96       	adiw	r26, 0x03	; 3
     9ea:	7c 93       	st	X, r23
     9ec:	6e 93       	st	-X, r22
     9ee:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9f0:	7d 83       	std	Y+5, r23	; 0x05
     9f2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9f4:	31 87       	std	Z+9, r19	; 0x09
     9f6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9f8:	f9 01       	movw	r30, r18
     9fa:	80 81       	ld	r24, Z
     9fc:	8f 5f       	subi	r24, 0xFF	; 255
     9fe:	80 83       	st	Z, r24
}
     a00:	df 91       	pop	r29
     a02:	cf 91       	pop	r28
     a04:	08 95       	ret

00000a06 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a0c:	48 81       	ld	r20, Y
     a0e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a10:	4f 3f       	cpi	r20, 0xFF	; 255
     a12:	2f ef       	ldi	r18, 0xFF	; 255
     a14:	52 07       	cpc	r21, r18
     a16:	21 f4       	brne	.+8      	; 0xa20 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a18:	fc 01       	movw	r30, r24
     a1a:	a7 81       	ldd	r26, Z+7	; 0x07
     a1c:	b0 85       	ldd	r27, Z+8	; 0x08
     a1e:	0d c0       	rjmp	.+26     	; 0xa3a <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a20:	dc 01       	movw	r26, r24
     a22:	13 96       	adiw	r26, 0x03	; 3
     a24:	01 c0       	rjmp	.+2      	; 0xa28 <vListInsert+0x22>
     a26:	df 01       	movw	r26, r30
     a28:	12 96       	adiw	r26, 0x02	; 2
     a2a:	ed 91       	ld	r30, X+
     a2c:	fc 91       	ld	r31, X
     a2e:	13 97       	sbiw	r26, 0x03	; 3
     a30:	20 81       	ld	r18, Z
     a32:	31 81       	ldd	r19, Z+1	; 0x01
     a34:	42 17       	cp	r20, r18
     a36:	53 07       	cpc	r21, r19
     a38:	b0 f7       	brcc	.-20     	; 0xa26 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a3a:	12 96       	adiw	r26, 0x02	; 2
     a3c:	ed 91       	ld	r30, X+
     a3e:	fc 91       	ld	r31, X
     a40:	13 97       	sbiw	r26, 0x03	; 3
     a42:	fb 83       	std	Y+3, r31	; 0x03
     a44:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a46:	d5 83       	std	Z+5, r29	; 0x05
     a48:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a4a:	bd 83       	std	Y+5, r27	; 0x05
     a4c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a4e:	13 96       	adiw	r26, 0x03	; 3
     a50:	dc 93       	st	X, r29
     a52:	ce 93       	st	-X, r28
     a54:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a56:	99 87       	std	Y+9, r25	; 0x09
     a58:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a5a:	fc 01       	movw	r30, r24
     a5c:	20 81       	ld	r18, Z
     a5e:	2f 5f       	subi	r18, 0xFF	; 255
     a60:	20 83       	st	Z, r18
}
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a6e:	a0 85       	ldd	r26, Z+8	; 0x08
     a70:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a72:	c2 81       	ldd	r28, Z+2	; 0x02
     a74:	d3 81       	ldd	r29, Z+3	; 0x03
     a76:	84 81       	ldd	r24, Z+4	; 0x04
     a78:	95 81       	ldd	r25, Z+5	; 0x05
     a7a:	9d 83       	std	Y+5, r25	; 0x05
     a7c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a7e:	c4 81       	ldd	r28, Z+4	; 0x04
     a80:	d5 81       	ldd	r29, Z+5	; 0x05
     a82:	82 81       	ldd	r24, Z+2	; 0x02
     a84:	93 81       	ldd	r25, Z+3	; 0x03
     a86:	9b 83       	std	Y+3, r25	; 0x03
     a88:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a8a:	11 96       	adiw	r26, 0x01	; 1
     a8c:	cd 91       	ld	r28, X+
     a8e:	dc 91       	ld	r29, X
     a90:	12 97       	sbiw	r26, 0x02	; 2
     a92:	ce 17       	cp	r28, r30
     a94:	df 07       	cpc	r29, r31
     a96:	31 f4       	brne	.+12     	; 0xaa4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a98:	8c 81       	ldd	r24, Y+4	; 0x04
     a9a:	9d 81       	ldd	r25, Y+5	; 0x05
     a9c:	12 96       	adiw	r26, 0x02	; 2
     a9e:	9c 93       	st	X, r25
     aa0:	8e 93       	st	-X, r24
     aa2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     aa4:	11 86       	std	Z+9, r1	; 0x09
     aa6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     aa8:	8c 91       	ld	r24, X
     aaa:	81 50       	subi	r24, 0x01	; 1
     aac:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	08 95       	ret

00000ab4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ab4:	31 e1       	ldi	r19, 0x11	; 17
     ab6:	fc 01       	movw	r30, r24
     ab8:	30 83       	st	Z, r19
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	22 e2       	ldi	r18, 0x22	; 34
     abe:	20 83       	st	Z, r18
     ac0:	fc 01       	movw	r30, r24
     ac2:	32 97       	sbiw	r30, 0x02	; 2
     ac4:	a3 e3       	ldi	r26, 0x33	; 51
     ac6:	a0 83       	st	Z, r26
     ac8:	fc 01       	movw	r30, r24
     aca:	33 97       	sbiw	r30, 0x03	; 3
     acc:	60 83       	st	Z, r22
     ace:	fc 01       	movw	r30, r24
     ad0:	34 97       	sbiw	r30, 0x04	; 4
     ad2:	70 83       	st	Z, r23
     ad4:	fc 01       	movw	r30, r24
     ad6:	35 97       	sbiw	r30, 0x05	; 5
     ad8:	10 82       	st	Z, r1
     ada:	fc 01       	movw	r30, r24
     adc:	36 97       	sbiw	r30, 0x06	; 6
     ade:	10 82       	st	Z, r1
     ae0:	fc 01       	movw	r30, r24
     ae2:	37 97       	sbiw	r30, 0x07	; 7
     ae4:	60 e8       	ldi	r22, 0x80	; 128
     ae6:	60 83       	st	Z, r22
     ae8:	fc 01       	movw	r30, r24
     aea:	38 97       	sbiw	r30, 0x08	; 8
     aec:	10 82       	st	Z, r1
     aee:	fc 01       	movw	r30, r24
     af0:	39 97       	sbiw	r30, 0x09	; 9
     af2:	10 82       	st	Z, r1
     af4:	fc 01       	movw	r30, r24
     af6:	3a 97       	sbiw	r30, 0x0a	; 10
     af8:	10 82       	st	Z, r1
     afa:	fc 01       	movw	r30, r24
     afc:	3b 97       	sbiw	r30, 0x0b	; 11
     afe:	62 e0       	ldi	r22, 0x02	; 2
     b00:	60 83       	st	Z, r22
     b02:	fc 01       	movw	r30, r24
     b04:	3c 97       	sbiw	r30, 0x0c	; 12
     b06:	63 e0       	ldi	r22, 0x03	; 3
     b08:	60 83       	st	Z, r22
     b0a:	fc 01       	movw	r30, r24
     b0c:	3d 97       	sbiw	r30, 0x0d	; 13
     b0e:	64 e0       	ldi	r22, 0x04	; 4
     b10:	60 83       	st	Z, r22
     b12:	fc 01       	movw	r30, r24
     b14:	3e 97       	sbiw	r30, 0x0e	; 14
     b16:	65 e0       	ldi	r22, 0x05	; 5
     b18:	60 83       	st	Z, r22
     b1a:	fc 01       	movw	r30, r24
     b1c:	3f 97       	sbiw	r30, 0x0f	; 15
     b1e:	66 e0       	ldi	r22, 0x06	; 6
     b20:	60 83       	st	Z, r22
     b22:	fc 01       	movw	r30, r24
     b24:	70 97       	sbiw	r30, 0x10	; 16
     b26:	67 e0       	ldi	r22, 0x07	; 7
     b28:	60 83       	st	Z, r22
     b2a:	fc 01       	movw	r30, r24
     b2c:	71 97       	sbiw	r30, 0x11	; 17
     b2e:	68 e0       	ldi	r22, 0x08	; 8
     b30:	60 83       	st	Z, r22
     b32:	fc 01       	movw	r30, r24
     b34:	72 97       	sbiw	r30, 0x12	; 18
     b36:	69 e0       	ldi	r22, 0x09	; 9
     b38:	60 83       	st	Z, r22
     b3a:	fc 01       	movw	r30, r24
     b3c:	73 97       	sbiw	r30, 0x13	; 19
     b3e:	60 e1       	ldi	r22, 0x10	; 16
     b40:	60 83       	st	Z, r22
     b42:	fc 01       	movw	r30, r24
     b44:	74 97       	sbiw	r30, 0x14	; 20
     b46:	30 83       	st	Z, r19
     b48:	fc 01       	movw	r30, r24
     b4a:	75 97       	sbiw	r30, 0x15	; 21
     b4c:	32 e1       	ldi	r19, 0x12	; 18
     b4e:	30 83       	st	Z, r19
     b50:	fc 01       	movw	r30, r24
     b52:	76 97       	sbiw	r30, 0x16	; 22
     b54:	33 e1       	ldi	r19, 0x13	; 19
     b56:	30 83       	st	Z, r19
     b58:	fc 01       	movw	r30, r24
     b5a:	77 97       	sbiw	r30, 0x17	; 23
     b5c:	34 e1       	ldi	r19, 0x14	; 20
     b5e:	30 83       	st	Z, r19
     b60:	fc 01       	movw	r30, r24
     b62:	78 97       	sbiw	r30, 0x18	; 24
     b64:	35 e1       	ldi	r19, 0x15	; 21
     b66:	30 83       	st	Z, r19
     b68:	fc 01       	movw	r30, r24
     b6a:	79 97       	sbiw	r30, 0x19	; 25
     b6c:	36 e1       	ldi	r19, 0x16	; 22
     b6e:	30 83       	st	Z, r19
     b70:	fc 01       	movw	r30, r24
     b72:	7a 97       	sbiw	r30, 0x1a	; 26
     b74:	37 e1       	ldi	r19, 0x17	; 23
     b76:	30 83       	st	Z, r19
     b78:	fc 01       	movw	r30, r24
     b7a:	7b 97       	sbiw	r30, 0x1b	; 27
     b7c:	38 e1       	ldi	r19, 0x18	; 24
     b7e:	30 83       	st	Z, r19
     b80:	fc 01       	movw	r30, r24
     b82:	7c 97       	sbiw	r30, 0x1c	; 28
     b84:	39 e1       	ldi	r19, 0x19	; 25
     b86:	30 83       	st	Z, r19
     b88:	fc 01       	movw	r30, r24
     b8a:	7d 97       	sbiw	r30, 0x1d	; 29
     b8c:	30 e2       	ldi	r19, 0x20	; 32
     b8e:	30 83       	st	Z, r19
     b90:	fc 01       	movw	r30, r24
     b92:	7e 97       	sbiw	r30, 0x1e	; 30
     b94:	31 e2       	ldi	r19, 0x21	; 33
     b96:	30 83       	st	Z, r19
     b98:	fc 01       	movw	r30, r24
     b9a:	7f 97       	sbiw	r30, 0x1f	; 31
     b9c:	20 83       	st	Z, r18
     b9e:	fc 01       	movw	r30, r24
     ba0:	b0 97       	sbiw	r30, 0x20	; 32
     ba2:	23 e2       	ldi	r18, 0x23	; 35
     ba4:	20 83       	st	Z, r18
     ba6:	fc 01       	movw	r30, r24
     ba8:	b1 97       	sbiw	r30, 0x21	; 33
     baa:	40 83       	st	Z, r20
     bac:	fc 01       	movw	r30, r24
     bae:	b2 97       	sbiw	r30, 0x22	; 34
     bb0:	50 83       	st	Z, r21
     bb2:	fc 01       	movw	r30, r24
     bb4:	b3 97       	sbiw	r30, 0x23	; 35
     bb6:	26 e2       	ldi	r18, 0x26	; 38
     bb8:	20 83       	st	Z, r18
     bba:	fc 01       	movw	r30, r24
     bbc:	b4 97       	sbiw	r30, 0x24	; 36
     bbe:	27 e2       	ldi	r18, 0x27	; 39
     bc0:	20 83       	st	Z, r18
     bc2:	fc 01       	movw	r30, r24
     bc4:	b5 97       	sbiw	r30, 0x25	; 37
     bc6:	28 e2       	ldi	r18, 0x28	; 40
     bc8:	20 83       	st	Z, r18
     bca:	fc 01       	movw	r30, r24
     bcc:	b6 97       	sbiw	r30, 0x26	; 38
     bce:	29 e2       	ldi	r18, 0x29	; 41
     bd0:	20 83       	st	Z, r18
     bd2:	fc 01       	movw	r30, r24
     bd4:	b7 97       	sbiw	r30, 0x27	; 39
     bd6:	20 e3       	ldi	r18, 0x30	; 48
     bd8:	20 83       	st	Z, r18
     bda:	fc 01       	movw	r30, r24
     bdc:	b8 97       	sbiw	r30, 0x28	; 40
     bde:	21 e3       	ldi	r18, 0x31	; 49
     be0:	20 83       	st	Z, r18
     be2:	9c 01       	movw	r18, r24
     be4:	29 52       	subi	r18, 0x29	; 41
     be6:	31 09       	sbc	r19, r1
     be8:	82 2f       	mov	r24, r18
     bea:	93 2f       	mov	r25, r19
     bec:	08 95       	ret

00000bee <xPortStartScheduler>:
     bee:	82 e0       	ldi	r24, 0x02	; 2
     bf0:	80 93 b0 00 	sts	0x00B0, r24
     bf4:	10 92 b2 00 	sts	0x00B2, r1
     bf8:	8a ef       	ldi	r24, 0xFA	; 250
     bfa:	80 93 b3 00 	sts	0x00B3, r24
     bfe:	e0 e7       	ldi	r30, 0x70	; 112
     c00:	f0 e0       	ldi	r31, 0x00	; 0
     c02:	80 81       	ld	r24, Z
     c04:	82 60       	ori	r24, 0x02	; 2
     c06:	80 83       	st	Z, r24
     c08:	83 e0       	ldi	r24, 0x03	; 3
     c0a:	80 93 b1 00 	sts	0x00B1, r24
     c0e:	a0 91 b7 09 	lds	r26, 0x09B7
     c12:	b0 91 b8 09 	lds	r27, 0x09B8
     c16:	cd 91       	ld	r28, X+
     c18:	cd bf       	out	0x3d, r28	; 61
     c1a:	dd 91       	ld	r29, X+
     c1c:	de bf       	out	0x3e, r29	; 62
     c1e:	ff 91       	pop	r31
     c20:	ef 91       	pop	r30
     c22:	df 91       	pop	r29
     c24:	cf 91       	pop	r28
     c26:	bf 91       	pop	r27
     c28:	af 91       	pop	r26
     c2a:	9f 91       	pop	r25
     c2c:	8f 91       	pop	r24
     c2e:	7f 91       	pop	r23
     c30:	6f 91       	pop	r22
     c32:	5f 91       	pop	r21
     c34:	4f 91       	pop	r20
     c36:	3f 91       	pop	r19
     c38:	2f 91       	pop	r18
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	df 90       	pop	r13
     c44:	cf 90       	pop	r12
     c46:	bf 90       	pop	r11
     c48:	af 90       	pop	r10
     c4a:	9f 90       	pop	r9
     c4c:	8f 90       	pop	r8
     c4e:	7f 90       	pop	r7
     c50:	6f 90       	pop	r6
     c52:	5f 90       	pop	r5
     c54:	4f 90       	pop	r4
     c56:	3f 90       	pop	r3
     c58:	2f 90       	pop	r2
     c5a:	1f 90       	pop	r1
     c5c:	0f 90       	pop	r0
     c5e:	0c be       	out	0x3c, r0	; 60
     c60:	0f 90       	pop	r0
     c62:	0b be       	out	0x3b, r0	; 59
     c64:	0f 90       	pop	r0
     c66:	0f be       	out	0x3f, r0	; 63
     c68:	0f 90       	pop	r0
     c6a:	08 95       	ret
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	08 95       	ret

00000c70 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c70:	0f 92       	push	r0
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	0f 92       	push	r0
     c78:	0c b6       	in	r0, 0x3c	; 60
     c7a:	0f 92       	push	r0
     c7c:	0b b6       	in	r0, 0x3b	; 59
     c7e:	0f 92       	push	r0
     c80:	1f 92       	push	r1
     c82:	11 24       	eor	r1, r1
     c84:	2f 92       	push	r2
     c86:	3f 92       	push	r3
     c88:	4f 92       	push	r4
     c8a:	5f 92       	push	r5
     c8c:	6f 92       	push	r6
     c8e:	7f 92       	push	r7
     c90:	8f 92       	push	r8
     c92:	9f 92       	push	r9
     c94:	af 92       	push	r10
     c96:	bf 92       	push	r11
     c98:	cf 92       	push	r12
     c9a:	df 92       	push	r13
     c9c:	ef 92       	push	r14
     c9e:	ff 92       	push	r15
     ca0:	0f 93       	push	r16
     ca2:	1f 93       	push	r17
     ca4:	2f 93       	push	r18
     ca6:	3f 93       	push	r19
     ca8:	4f 93       	push	r20
     caa:	5f 93       	push	r21
     cac:	6f 93       	push	r22
     cae:	7f 93       	push	r23
     cb0:	8f 93       	push	r24
     cb2:	9f 93       	push	r25
     cb4:	af 93       	push	r26
     cb6:	bf 93       	push	r27
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	ef 93       	push	r30
     cbe:	ff 93       	push	r31
     cc0:	a0 91 b7 09 	lds	r26, 0x09B7
     cc4:	b0 91 b8 09 	lds	r27, 0x09B8
     cc8:	0d b6       	in	r0, 0x3d	; 61
     cca:	0d 92       	st	X+, r0
     ccc:	0e b6       	in	r0, 0x3e	; 62
     cce:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cd0:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cd4:	a0 91 b7 09 	lds	r26, 0x09B7
     cd8:	b0 91 b8 09 	lds	r27, 0x09B8
     cdc:	cd 91       	ld	r28, X+
     cde:	cd bf       	out	0x3d, r28	; 61
     ce0:	dd 91       	ld	r29, X+
     ce2:	de bf       	out	0x3e, r29	; 62
     ce4:	ff 91       	pop	r31
     ce6:	ef 91       	pop	r30
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	bf 91       	pop	r27
     cee:	af 91       	pop	r26
     cf0:	9f 91       	pop	r25
     cf2:	8f 91       	pop	r24
     cf4:	7f 91       	pop	r23
     cf6:	6f 91       	pop	r22
     cf8:	5f 91       	pop	r21
     cfa:	4f 91       	pop	r20
     cfc:	3f 91       	pop	r19
     cfe:	2f 91       	pop	r18
     d00:	1f 91       	pop	r17
     d02:	0f 91       	pop	r16
     d04:	ff 90       	pop	r15
     d06:	ef 90       	pop	r14
     d08:	df 90       	pop	r13
     d0a:	cf 90       	pop	r12
     d0c:	bf 90       	pop	r11
     d0e:	af 90       	pop	r10
     d10:	9f 90       	pop	r9
     d12:	8f 90       	pop	r8
     d14:	7f 90       	pop	r7
     d16:	6f 90       	pop	r6
     d18:	5f 90       	pop	r5
     d1a:	4f 90       	pop	r4
     d1c:	3f 90       	pop	r3
     d1e:	2f 90       	pop	r2
     d20:	1f 90       	pop	r1
     d22:	0f 90       	pop	r0
     d24:	0c be       	out	0x3c, r0	; 60
     d26:	0f 90       	pop	r0
     d28:	0b be       	out	0x3b, r0	; 59
     d2a:	0f 90       	pop	r0
     d2c:	0f be       	out	0x3f, r0	; 63
     d2e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d30:	08 95       	ret

00000d32 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d32:	0f 92       	push	r0
     d34:	0f b6       	in	r0, 0x3f	; 63
     d36:	f8 94       	cli
     d38:	0f 92       	push	r0
     d3a:	0c b6       	in	r0, 0x3c	; 60
     d3c:	0f 92       	push	r0
     d3e:	0b b6       	in	r0, 0x3b	; 59
     d40:	0f 92       	push	r0
     d42:	1f 92       	push	r1
     d44:	11 24       	eor	r1, r1
     d46:	2f 92       	push	r2
     d48:	3f 92       	push	r3
     d4a:	4f 92       	push	r4
     d4c:	5f 92       	push	r5
     d4e:	6f 92       	push	r6
     d50:	7f 92       	push	r7
     d52:	8f 92       	push	r8
     d54:	9f 92       	push	r9
     d56:	af 92       	push	r10
     d58:	bf 92       	push	r11
     d5a:	cf 92       	push	r12
     d5c:	df 92       	push	r13
     d5e:	ef 92       	push	r14
     d60:	ff 92       	push	r15
     d62:	0f 93       	push	r16
     d64:	1f 93       	push	r17
     d66:	2f 93       	push	r18
     d68:	3f 93       	push	r19
     d6a:	4f 93       	push	r20
     d6c:	5f 93       	push	r21
     d6e:	6f 93       	push	r22
     d70:	7f 93       	push	r23
     d72:	8f 93       	push	r24
     d74:	9f 93       	push	r25
     d76:	af 93       	push	r26
     d78:	bf 93       	push	r27
     d7a:	cf 93       	push	r28
     d7c:	df 93       	push	r29
     d7e:	ef 93       	push	r30
     d80:	ff 93       	push	r31
     d82:	a0 91 b7 09 	lds	r26, 0x09B7
     d86:	b0 91 b8 09 	lds	r27, 0x09B8
     d8a:	0d b6       	in	r0, 0x3d	; 61
     d8c:	0d 92       	st	X+, r0
     d8e:	0e b6       	in	r0, 0x3e	; 62
     d90:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d92:	ae d6       	rcall	.+3420   	; 0x1af0 <xTaskIncrementTick>
     d94:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d96:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d9a:	a0 91 b7 09 	lds	r26, 0x09B7
     d9e:	b0 91 b8 09 	lds	r27, 0x09B8
     da2:	cd 91       	ld	r28, X+
     da4:	cd bf       	out	0x3d, r28	; 61
     da6:	dd 91       	ld	r29, X+
     da8:	de bf       	out	0x3e, r29	; 62
     daa:	ff 91       	pop	r31
     dac:	ef 91       	pop	r30
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	bf 91       	pop	r27
     db4:	af 91       	pop	r26
     db6:	9f 91       	pop	r25
     db8:	8f 91       	pop	r24
     dba:	7f 91       	pop	r23
     dbc:	6f 91       	pop	r22
     dbe:	5f 91       	pop	r21
     dc0:	4f 91       	pop	r20
     dc2:	3f 91       	pop	r19
     dc4:	2f 91       	pop	r18
     dc6:	1f 91       	pop	r17
     dc8:	0f 91       	pop	r16
     dca:	ff 90       	pop	r15
     dcc:	ef 90       	pop	r14
     dce:	df 90       	pop	r13
     dd0:	cf 90       	pop	r12
     dd2:	bf 90       	pop	r11
     dd4:	af 90       	pop	r10
     dd6:	9f 90       	pop	r9
     dd8:	8f 90       	pop	r8
     dda:	7f 90       	pop	r7
     ddc:	6f 90       	pop	r6
     dde:	5f 90       	pop	r5
     de0:	4f 90       	pop	r4
     de2:	3f 90       	pop	r3
     de4:	2f 90       	pop	r2
     de6:	1f 90       	pop	r1
     de8:	0f 90       	pop	r0
     dea:	0c be       	out	0x3c, r0	; 60
     dec:	0f 90       	pop	r0
     dee:	0b be       	out	0x3b, r0	; 59
     df0:	0f 90       	pop	r0
     df2:	0f be       	out	0x3f, r0	; 63
     df4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     df6:	08 95       	ret

00000df8 <__vector_13>:
		 * the context is saved at the start of the vPortYieldFromTick(). The tick
		 * count is incremented after the context is saved.
		 */
		ISR(TIMER2_COMPA_vect, ISR_NAKED)
		{
				vPortYieldFromTick();
     df8:	9c df       	rcall	.-200    	; 0xd32 <vPortYieldFromTick>
				asm volatile ( "reti" );
     dfa:	18 95       	reti

00000dfc <_ZN3QueC1Ev>:
            break;
        }
    }

    return sendlen;
}
     dfc:	fc 01       	movw	r30, r24
     dfe:	e8 58       	subi	r30, 0x88	; 136
     e00:	ff 4f       	sbci	r31, 0xFF	; 255
     e02:	11 82       	std	Z+1, r1	; 0x01
     e04:	10 82       	st	Z, r1
     e06:	fc 01       	movw	r30, r24
     e08:	e6 58       	subi	r30, 0x86	; 134
     e0a:	ff 4f       	sbci	r31, 0xFF	; 255
     e0c:	11 82       	std	Z+1, r1	; 0x01
     e0e:	10 82       	st	Z, r1
     e10:	fc 01       	movw	r30, r24
     e12:	e4 58       	subi	r30, 0x84	; 132
     e14:	ff 4f       	sbci	r31, 0xFF	; 255
     e16:	11 82       	std	Z+1, r1	; 0x01
     e18:	10 82       	st	Z, r1
     e1a:	e8 2f       	mov	r30, r24
     e1c:	f9 2f       	mov	r31, r25
     e1e:	88 e7       	ldi	r24, 0x78	; 120
     e20:	df 01       	movw	r26, r30
     e22:	1d 92       	st	X+, r1
     e24:	8a 95       	dec	r24
     e26:	e9 f7       	brne	.-6      	; 0xe22 <_ZN3QueC1Ev+0x26>
     e28:	08 95       	ret

00000e2a <_ZN3QueD1Ev>:
     e2a:	e8 2f       	mov	r30, r24
     e2c:	f9 2f       	mov	r31, r25
     e2e:	88 e7       	ldi	r24, 0x78	; 120
     e30:	df 01       	movw	r26, r30
     e32:	1d 92       	st	X+, r1
     e34:	8a 95       	dec	r24
     e36:	e9 f7       	brne	.-6      	; 0xe32 <_ZN3QueD1Ev+0x8>
     e38:	08 95       	ret

00000e3a <_ZN3Que7EnqueueEh>:
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	ac 01       	movw	r20, r24
     e44:	fc 01       	movw	r30, r24
     e46:	e4 58       	subi	r30, 0x84	; 132
     e48:	ff 4f       	sbci	r31, 0xFF	; 255
     e4a:	01 90       	ld	r0, Z+
     e4c:	f0 81       	ld	r31, Z
     e4e:	e0 2d       	mov	r30, r0
     e50:	e8 37       	cpi	r30, 0x78	; 120
     e52:	f1 05       	cpc	r31, r1
     e54:	59 f1       	breq	.+86     	; 0xeac <_ZN3Que7EnqueueEh+0x72>
     e56:	ec 01       	movw	r28, r24
     e58:	c6 58       	subi	r28, 0x86	; 134
     e5a:	df 4f       	sbci	r29, 0xFF	; 255
     e5c:	08 81       	ld	r16, Y
     e5e:	19 81       	ldd	r17, Y+1	; 0x01
     e60:	dc 01       	movw	r26, r24
     e62:	a0 0f       	add	r26, r16
     e64:	b1 1f       	adc	r27, r17
     e66:	6c 93       	st	X, r22
     e68:	0f 5f       	subi	r16, 0xFF	; 255
     e6a:	1f 4f       	sbci	r17, 0xFF	; 255
     e6c:	98 01       	movw	r18, r16
     e6e:	a9 e8       	ldi	r26, 0x89	; 137
     e70:	b8 e8       	ldi	r27, 0x88	; 136
     e72:	0e 94 c3 1a 	call	0x3586	; 0x3586 <__umulhisi3>
     e76:	00 24       	eor	r0, r0
     e78:	88 0f       	add	r24, r24
     e7a:	99 1f       	adc	r25, r25
     e7c:	00 1c       	adc	r0, r0
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	00 1c       	adc	r0, r0
     e84:	89 2f       	mov	r24, r25
     e86:	90 2d       	mov	r25, r0
     e88:	68 e7       	ldi	r22, 0x78	; 120
     e8a:	68 9f       	mul	r22, r24
     e8c:	90 01       	movw	r18, r0
     e8e:	69 9f       	mul	r22, r25
     e90:	30 0d       	add	r19, r0
     e92:	11 24       	eor	r1, r1
     e94:	02 1b       	sub	r16, r18
     e96:	13 0b       	sbc	r17, r19
     e98:	19 83       	std	Y+1, r17	; 0x01
     e9a:	08 83       	st	Y, r16
     e9c:	da 01       	movw	r26, r20
     e9e:	a4 58       	subi	r26, 0x84	; 132
     ea0:	bf 4f       	sbci	r27, 0xFF	; 255
     ea2:	31 96       	adiw	r30, 0x01	; 1
     ea4:	ed 93       	st	X+, r30
     ea6:	fc 93       	st	X, r31
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	01 c0       	rjmp	.+2      	; 0xeae <_ZN3Que7EnqueueEh+0x74>
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	0f 91       	pop	r16
     eb6:	08 95       	ret

00000eb8 <_ZN3Que4PeekEj>:

unsigned char Que::Peek(unsigned int pos){
     eb8:	0f 93       	push	r16
     eba:	1f 93       	push	r17
     ebc:	cf 93       	push	r28
     ebe:	df 93       	push	r29
     ec0:	fc 01       	movw	r30, r24
    unsigned char c = 0;

    pos += m_Head;
     ec2:	dc 01       	movw	r26, r24
     ec4:	a8 58       	subi	r26, 0x88	; 136
     ec6:	bf 4f       	sbci	r27, 0xFF	; 255
     ec8:	cd 91       	ld	r28, X+
     eca:	dc 91       	ld	r29, X
     ecc:	8b 01       	movw	r16, r22
     ece:	0c 0f       	add	r16, r28
     ed0:	1d 1f       	adc	r17, r29
    pos %= Q_SIZE;
     ed2:	98 01       	movw	r18, r16
     ed4:	a9 e8       	ldi	r26, 0x89	; 137
     ed6:	b8 e8       	ldi	r27, 0x88	; 136
     ed8:	0e 94 c3 1a 	call	0x3586	; 0x3586 <__umulhisi3>
     edc:	ac 01       	movw	r20, r24
     ede:	00 24       	eor	r0, r0
     ee0:	44 0f       	add	r20, r20
     ee2:	55 1f       	adc	r21, r21
     ee4:	00 1c       	adc	r0, r0
     ee6:	44 0f       	add	r20, r20
     ee8:	55 1f       	adc	r21, r21
     eea:	00 1c       	adc	r0, r0
     eec:	45 2f       	mov	r20, r21
     eee:	50 2d       	mov	r21, r0
     ef0:	28 e7       	ldi	r18, 0x78	; 120
     ef2:	24 9f       	mul	r18, r20
     ef4:	c0 01       	movw	r24, r0
     ef6:	25 9f       	mul	r18, r21
     ef8:	90 0d       	add	r25, r0
     efa:	11 24       	eor	r1, r1
     efc:	a8 01       	movw	r20, r16
     efe:	48 1b       	sub	r20, r24
     f00:	59 0b       	sbc	r21, r25

    if ((pos >= m_Head) || (pos < m_Tail)){
     f02:	4c 17       	cp	r20, r28
     f04:	5d 07       	cpc	r21, r29
     f06:	40 f4       	brcc	.+16     	; 0xf18 <_ZN3Que4PeekEj+0x60>
     f08:	df 01       	movw	r26, r30
     f0a:	a6 58       	subi	r26, 0x86	; 134
     f0c:	bf 4f       	sbci	r27, 0xFF	; 255
     f0e:	8d 91       	ld	r24, X+
     f10:	9c 91       	ld	r25, X
     f12:	48 17       	cp	r20, r24
     f14:	59 07       	cpc	r21, r25
     f16:	20 f4       	brcc	.+8      	; 0xf20 <_ZN3Que4PeekEj+0x68>
        c = m_Data[pos];
     f18:	e4 0f       	add	r30, r20
     f1a:	f5 1f       	adc	r31, r21
     f1c:	80 81       	ld	r24, Z
     f1e:	01 c0       	rjmp	.+2      	; 0xf22 <_ZN3Que4PeekEj+0x6a>

    return sendlen;
}

unsigned char Que::Peek(unsigned int pos){
    unsigned char c = 0;
     f20:	80 e0       	ldi	r24, 0x00	; 0
    if ((pos >= m_Head) || (pos < m_Tail)){
        c = m_Data[pos];
    }

    return c;
}
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	1f 91       	pop	r17
     f28:	0f 91       	pop	r16
     f2a:	08 95       	ret

00000f2c <_ZN3Que4CopyEPhi>:

int Que::Copy(unsigned char *outbuf, int start){
     f2c:	cf 92       	push	r12
     f2e:	df 92       	push	r13
     f30:	ef 92       	push	r14
     f32:	ff 92       	push	r15
     f34:	0f 93       	push	r16
     f36:	1f 93       	push	r17
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	ec 01       	movw	r28, r24
     f3e:	8b 01       	movw	r16, r22
    int i = 0;
    int pos = 0; 

    if (start >= m_Size)
     f40:	84 2f       	mov	r24, r20
     f42:	95 2f       	mov	r25, r21
     f44:	fe 01       	movw	r30, r28
     f46:	e4 58       	subi	r30, 0x84	; 132
     f48:	ff 4f       	sbci	r31, 0xFF	; 255
     f4a:	40 81       	ld	r20, Z
     f4c:	51 81       	ldd	r21, Z+1	; 0x01
     f4e:	84 17       	cp	r24, r20
     f50:	95 07       	cpc	r25, r21
     f52:	08 f0       	brcs	.+2      	; 0xf56 <_ZN3Que4CopyEPhi+0x2a>
     f54:	44 c0       	rjmp	.+136    	; 0xfde <_ZN3Que4CopyEPhi+0xb2>
        return false;

    pos = (m_Head + start) % Q_SIZE;
     f56:	fe 01       	movw	r30, r28
     f58:	e8 58       	subi	r30, 0x88	; 136
     f5a:	ff 4f       	sbci	r31, 0xFF	; 255
     f5c:	01 90       	ld	r0, Z+
     f5e:	f0 81       	ld	r31, Z
     f60:	e0 2d       	mov	r30, r0
     f62:	e8 0f       	add	r30, r24
     f64:	f9 1f       	adc	r31, r25
     f66:	9f 01       	movw	r18, r30
     f68:	a9 e8       	ldi	r26, 0x89	; 137
     f6a:	b8 e8       	ldi	r27, 0x88	; 136
     f6c:	0e 94 c3 1a 	call	0x3586	; 0x3586 <__umulhisi3>
     f70:	00 24       	eor	r0, r0
     f72:	88 0f       	add	r24, r24
     f74:	99 1f       	adc	r25, r25
     f76:	00 1c       	adc	r0, r0
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	00 1c       	adc	r0, r0
     f7e:	89 2f       	mov	r24, r25
     f80:	90 2d       	mov	r25, r0
     f82:	68 e7       	ldi	r22, 0x78	; 120
     f84:	68 9f       	mul	r22, r24
     f86:	90 01       	movw	r18, r0
     f88:	69 9f       	mul	r22, r25
     f8a:	30 0d       	add	r19, r0
     f8c:	11 24       	eor	r1, r1
     f8e:	cf 01       	movw	r24, r30
     f90:	82 1b       	sub	r24, r18
     f92:	93 0b       	sbc	r25, r19
    while(i < m_Size){
     f94:	45 2b       	or	r20, r21
     f96:	31 f1       	breq	.+76     	; 0xfe4 <_ZN3Que4CopyEPhi+0xb8>
     f98:	40 e0       	ldi	r20, 0x00	; 0
     f9a:	50 e0       	ldi	r21, 0x00	; 0

    return c;
}

int Que::Copy(unsigned char *outbuf, int start){
    int i = 0;
     f9c:	20 e0       	ldi	r18, 0x00	; 0
     f9e:	30 e0       	ldi	r19, 0x00	; 0
        return false;

    pos = (m_Head + start) % Q_SIZE;
    while(i < m_Size){
        outbuf[i++] = m_Data[pos++];
        pos %= Q_SIZE;
     fa0:	0f 2e       	mov	r0, r31
     fa2:	f8 e7       	ldi	r31, 0x78	; 120
     fa4:	cf 2e       	mov	r12, r31
     fa6:	d1 2c       	mov	r13, r1
     fa8:	f0 2d       	mov	r31, r0

    if (start >= m_Size)
        return false;

    pos = (m_Head + start) % Q_SIZE;
    while(i < m_Size){
     faa:	7e 01       	movw	r14, r28
     fac:	6c e7       	ldi	r22, 0x7C	; 124
     fae:	e6 0e       	add	r14, r22
     fb0:	f1 1c       	adc	r15, r1
        outbuf[i++] = m_Data[pos++];
     fb2:	fe 01       	movw	r30, r28
     fb4:	e8 0f       	add	r30, r24
     fb6:	f9 1f       	adc	r31, r25
     fb8:	60 81       	ld	r22, Z
     fba:	f8 01       	movw	r30, r16
     fbc:	e4 0f       	add	r30, r20
     fbe:	f5 1f       	adc	r31, r21
     fc0:	60 83       	st	Z, r22
     fc2:	2f 5f       	subi	r18, 0xFF	; 255
     fc4:	3f 4f       	sbci	r19, 0xFF	; 255
     fc6:	01 96       	adiw	r24, 0x01	; 1
        pos %= Q_SIZE;
     fc8:	b6 01       	movw	r22, r12
     fca:	0e 94 8e 1a 	call	0x351c	; 0x351c <__divmodhi4>

    if (start >= m_Size)
        return false;

    pos = (m_Head + start) % Q_SIZE;
    while(i < m_Size){
     fce:	a9 01       	movw	r20, r18
     fd0:	d7 01       	movw	r26, r14
     fd2:	ed 91       	ld	r30, X+
     fd4:	fc 91       	ld	r31, X
     fd6:	2e 17       	cp	r18, r30
     fd8:	3f 07       	cpc	r19, r31
     fda:	58 f3       	brcs	.-42     	; 0xfb2 <_ZN3Que4CopyEPhi+0x86>
     fdc:	05 c0       	rjmp	.+10     	; 0xfe8 <_ZN3Que4CopyEPhi+0xbc>
int Que::Copy(unsigned char *outbuf, int start){
    int i = 0;
    int pos = 0; 

    if (start >= m_Size)
        return false;
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	02 c0       	rjmp	.+4      	; 0xfe8 <_ZN3Que4CopyEPhi+0xbc>

    return c;
}

int Que::Copy(unsigned char *outbuf, int start){
    int i = 0;
     fe4:	20 e0       	ldi	r18, 0x00	; 0
     fe6:	30 e0       	ldi	r19, 0x00	; 0
    while(i < m_Size){
        outbuf[i++] = m_Data[pos++];
        pos %= Q_SIZE;
    }
	return i;
}
     fe8:	82 2f       	mov	r24, r18
     fea:	93 2f       	mov	r25, r19
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	ff 90       	pop	r15
     ff6:	ef 90       	pop	r14
     ff8:	df 90       	pop	r13
     ffa:	cf 90       	pop	r12
     ffc:	08 95       	ret

00000ffe <_ZN3Que5ClearEj>:


int Que::Clear(unsigned int pos){
     ffe:	bf 92       	push	r11
    1000:	cf 92       	push	r12
    1002:	df 92       	push	r13
    1004:	ef 92       	push	r14
    1006:	ff 92       	push	r15
    1008:	0f 93       	push	r16
    100a:	1f 93       	push	r17
    100c:	cf 93       	push	r28
    100e:	df 93       	push	r29
    1010:	8c 01       	movw	r16, r24
    int deleted = 0;
    pos += m_Head;
    1012:	fc 01       	movw	r30, r24
    1014:	e8 58       	subi	r30, 0x88	; 136
    1016:	ff 4f       	sbci	r31, 0xFF	; 255
    1018:	40 81       	ld	r20, Z
    101a:	51 81       	ldd	r21, Z+1	; 0x01
    101c:	fb 01       	movw	r30, r22
    101e:	e4 0f       	add	r30, r20
    1020:	f5 1f       	adc	r31, r21
    pos %= Q_SIZE;
    1022:	9f 01       	movw	r18, r30
    1024:	a9 e8       	ldi	r26, 0x89	; 137
    1026:	b8 e8       	ldi	r27, 0x88	; 136
    1028:	0e 94 c3 1a 	call	0x3586	; 0x3586 <__umulhisi3>
    102c:	7c 01       	movw	r14, r24
    102e:	00 24       	eor	r0, r0
    1030:	ee 0c       	add	r14, r14
    1032:	ff 1c       	adc	r15, r15
    1034:	00 1c       	adc	r0, r0
    1036:	ee 0c       	add	r14, r14
    1038:	ff 1c       	adc	r15, r15
    103a:	00 1c       	adc	r0, r0
    103c:	ef 2c       	mov	r14, r15
    103e:	f0 2c       	mov	r15, r0
    1040:	28 e7       	ldi	r18, 0x78	; 120
    1042:	2e 9d       	mul	r18, r14
    1044:	c0 01       	movw	r24, r0
    1046:	2f 9d       	mul	r18, r15
    1048:	90 0d       	add	r25, r0
    104a:	11 24       	eor	r1, r1
    104c:	7f 01       	movw	r14, r30
    104e:	e8 1a       	sub	r14, r24
    1050:	f9 0a       	sbc	r15, r25

    if (pos >= m_Tail){ 
    1052:	f8 01       	movw	r30, r16
    1054:	e6 58       	subi	r30, 0x86	; 134
    1056:	ff 4f       	sbci	r31, 0xFF	; 255
    1058:	80 81       	ld	r24, Z
    105a:	91 81       	ldd	r25, Z+1	; 0x01
    105c:	e8 16       	cp	r14, r24
    105e:	f9 06       	cpc	r15, r25
    1060:	30 f4       	brcc	.+12     	; 0x106e <_ZN3Que5ClearEj+0x70>
        m_Tail = 0;
        m_Size = 0;
        return Q_SIZE;
    }

    while(m_Head != pos){
    1062:	4e 15       	cp	r20, r14
    1064:	5f 05       	cpc	r21, r15
    1066:	f1 f4       	brne	.+60     	; 0x10a4 <_ZN3Que5ClearEj+0xa6>
    1068:	20 e0       	ldi	r18, 0x00	; 0
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	55 c0       	rjmp	.+170    	; 0x1118 <_ZN3Que5ClearEj+0x11a>
    106e:	f8 01       	movw	r30, r16
    }
	return i;
}


int Que::Clear(unsigned int pos){
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    pos %= Q_SIZE;

    if (pos >= m_Tail){ 
        // delete entire thing
        for (unsigned int i=0; i<Q_SIZE; i++) {
            m_Data[i] = 0;
    1074:	11 92       	st	Z+, r1
    pos += m_Head;
    pos %= Q_SIZE;

    if (pos >= m_Tail){ 
        // delete entire thing
        for (unsigned int i=0; i<Q_SIZE; i++) {
    1076:	2f 5f       	subi	r18, 0xFF	; 255
    1078:	3f 4f       	sbci	r19, 0xFF	; 255
    107a:	28 37       	cpi	r18, 0x78	; 120
    107c:	31 05       	cpc	r19, r1
    107e:	d1 f7       	brne	.-12     	; 0x1074 <_ZN3Que5ClearEj+0x76>
            m_Data[i] = 0;
        }

        m_Head = 0;
    1080:	f8 01       	movw	r30, r16
    1082:	e8 58       	subi	r30, 0x88	; 136
    1084:	ff 4f       	sbci	r31, 0xFF	; 255
    1086:	11 82       	std	Z+1, r1	; 0x01
    1088:	10 82       	st	Z, r1
        m_Tail = 0;
    108a:	f8 01       	movw	r30, r16
    108c:	e6 58       	subi	r30, 0x86	; 134
    108e:	ff 4f       	sbci	r31, 0xFF	; 255
    1090:	11 82       	std	Z+1, r1	; 0x01
    1092:	10 82       	st	Z, r1
        m_Size = 0;
    1094:	f8 01       	movw	r30, r16
    1096:	e4 58       	subi	r30, 0x84	; 132
    1098:	ff 4f       	sbci	r31, 0xFF	; 255
    109a:	11 82       	std	Z+1, r1	; 0x01
    109c:	10 82       	st	Z, r1
        return Q_SIZE;
    109e:	28 e7       	ldi	r18, 0x78	; 120
    10a0:	30 e0       	ldi	r19, 0x00	; 0
    10a2:	3a c0       	rjmp	.+116    	; 0x1118 <_ZN3Que5ClearEj+0x11a>
    10a4:	f8 01       	movw	r30, r16
    10a6:	e4 58       	subi	r30, 0x84	; 132
    10a8:	ff 4f       	sbci	r31, 0xFF	; 255
    10aa:	c0 80       	ld	r12, Z
    10ac:	d1 80       	ldd	r13, Z+1	; 0x01
    }

    while(m_Head != pos){
    10ae:	e1 e0       	ldi	r30, 0x01	; 1
    10b0:	f0 e0       	ldi	r31, 0x00	; 0
        m_Data[m_Head++] = 0;
        m_Head %= Q_SIZE;
    10b2:	0f 2e       	mov	r0, r31
    10b4:	f8 e7       	ldi	r31, 0x78	; 120
    10b6:	bf 2e       	mov	r11, r31
    10b8:	f0 2d       	mov	r31, r0
        m_Size = 0;
        return Q_SIZE;
    }

    while(m_Head != pos){
        m_Data[m_Head++] = 0;
    10ba:	d8 01       	movw	r26, r16
    10bc:	a4 0f       	add	r26, r20
    10be:	b5 1f       	adc	r27, r21
    10c0:	1c 92       	st	X, r1
    10c2:	ea 01       	movw	r28, r20
    10c4:	21 96       	adiw	r28, 0x01	; 1
        m_Head %= Q_SIZE;
    10c6:	9e 01       	movw	r18, r28
    10c8:	a9 e8       	ldi	r26, 0x89	; 137
    10ca:	b8 e8       	ldi	r27, 0x88	; 136
    10cc:	0e 94 c3 1a 	call	0x3586	; 0x3586 <__umulhisi3>
    10d0:	ac 01       	movw	r20, r24
    10d2:	00 24       	eor	r0, r0
    10d4:	44 0f       	add	r20, r20
    10d6:	55 1f       	adc	r21, r21
    10d8:	00 1c       	adc	r0, r0
    10da:	44 0f       	add	r20, r20
    10dc:	55 1f       	adc	r21, r21
    10de:	00 1c       	adc	r0, r0
    10e0:	45 2f       	mov	r20, r21
    10e2:	50 2d       	mov	r21, r0
    10e4:	b4 9e       	mul	r11, r20
    10e6:	c0 01       	movw	r24, r0
    10e8:	b5 9e       	mul	r11, r21
    10ea:	90 0d       	add	r25, r0
    10ec:	11 24       	eor	r1, r1
    10ee:	ae 01       	movw	r20, r28
    10f0:	48 1b       	sub	r20, r24
    10f2:	59 0b       	sbc	r21, r25
        m_Size--;
    10f4:	c6 01       	movw	r24, r12
    10f6:	8e 1b       	sub	r24, r30
    10f8:	9f 0b       	sbc	r25, r31
        deleted++;
    10fa:	9f 01       	movw	r18, r30
    10fc:	31 96       	adiw	r30, 0x01	; 1
        m_Tail = 0;
        m_Size = 0;
        return Q_SIZE;
    }

    while(m_Head != pos){
    10fe:	e4 16       	cp	r14, r20
    1100:	f5 06       	cpc	r15, r21
    1102:	d9 f6       	brne	.-74     	; 0x10ba <_ZN3Que5ClearEj+0xbc>
    1104:	f8 01       	movw	r30, r16
    1106:	e8 58       	subi	r30, 0x88	; 136
    1108:	ff 4f       	sbci	r31, 0xFF	; 255
    110a:	51 83       	std	Z+1, r21	; 0x01
    110c:	40 83       	st	Z, r20
    110e:	f8 01       	movw	r30, r16
    1110:	e4 58       	subi	r30, 0x84	; 132
    1112:	ff 4f       	sbci	r31, 0xFF	; 255
    1114:	91 83       	std	Z+1, r25	; 0x01
    1116:	80 83       	st	Z, r24
        m_Size--;
        deleted++;
    }

    return deleted;
}
    1118:	82 2f       	mov	r24, r18
    111a:	93 2f       	mov	r25, r19
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	1f 91       	pop	r17
    1122:	0f 91       	pop	r16
    1124:	ff 90       	pop	r15
    1126:	ef 90       	pop	r14
    1128:	df 90       	pop	r13
    112a:	cf 90       	pop	r12
    112c:	bf 90       	pop	r11
    112e:	08 95       	ret

00001130 <__vector_17>:

#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
// Interrupt handlers for Arduino 
#if defined(_useTimer1)
ISR(TIMER1_COMPA_vect) 
{ 
    1130:	1f 92       	push	r1
    1132:	0f 92       	push	r0
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	0f 92       	push	r0
    1138:	11 24       	eor	r1, r1
    113a:	0b b6       	in	r0, 0x3b	; 59
    113c:	0f 92       	push	r0
    113e:	2f 93       	push	r18
    1140:	3f 93       	push	r19
    1142:	4f 93       	push	r20
    1144:	5f 93       	push	r21
    1146:	6f 93       	push	r22
    1148:	7f 93       	push	r23
    114a:	8f 93       	push	r24
    114c:	9f 93       	push	r25
    114e:	af 93       	push	r26
    1150:	bf 93       	push	r27
    1152:	ef 93       	push	r30
    1154:	ff 93       	push	r31

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    1156:	80 91 16 09 	lds	r24, 0x0916
    115a:	88 23       	and	r24, r24
    115c:	2c f4       	brge	.+10     	; 0x1168 <__vector_17+0x38>
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
    115e:	10 92 85 00 	sts	0x0085, r1
    1162:	10 92 84 00 	sts	0x0084, r1
    1166:	1e c0       	rjmp	.+60     	; 0x11a4 <__vector_17+0x74>
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
    1168:	20 91 16 09 	lds	r18, 0x0916
    116c:	33 27       	eor	r19, r19
    116e:	27 fd       	sbrc	r18, 7
    1170:	30 95       	com	r19
    1172:	24 5f       	subi	r18, 0xF4	; 244
    1174:	3f 4f       	sbci	r19, 0xFF	; 255
    1176:	80 91 14 09 	lds	r24, 0x0914
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	28 17       	cp	r18, r24
    117e:	39 07       	cpc	r19, r25
    1180:	8c f4       	brge	.+34     	; 0x11a4 <__vector_17+0x74>
    1182:	80 91 16 09 	lds	r24, 0x0916
    1186:	99 27       	eor	r25, r25
    1188:	87 fd       	sbrc	r24, 7
    118a:	90 95       	com	r25
    118c:	0c 96       	adiw	r24, 0x0c	; 12
    118e:	fc 01       	movw	r30, r24
    1190:	ee 0f       	add	r30, r30
    1192:	ff 1f       	adc	r31, r31
    1194:	8e 0f       	add	r24, r30
    1196:	9f 1f       	adc	r25, r31
    1198:	fc 01       	movw	r30, r24
    119a:	e7 5e       	subi	r30, 0xE7	; 231
    119c:	f6 4f       	sbci	r31, 0xF6	; 246
    119e:	80 81       	ld	r24, Z
    11a0:	86 fd       	sbrc	r24, 6
    11a2:	40 c0       	rjmp	.+128    	; 0x1224 <__vector_17+0xf4>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
    11a4:	e6 e1       	ldi	r30, 0x16	; 22
    11a6:	f9 e0       	ldi	r31, 0x09	; 9
    11a8:	80 81       	ld	r24, Z
    11aa:	8f 5f       	subi	r24, 0xFF	; 255
    11ac:	80 83       	st	Z, r24
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    11ae:	20 81       	ld	r18, Z
    11b0:	33 27       	eor	r19, r19
    11b2:	27 fd       	sbrc	r18, 7
    11b4:	30 95       	com	r19
    11b6:	24 5f       	subi	r18, 0xF4	; 244
    11b8:	3f 4f       	sbci	r19, 0xFF	; 255
    11ba:	80 91 14 09 	lds	r24, 0x0914
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	28 17       	cp	r18, r24
    11c2:	39 07       	cpc	r19, r25
    11c4:	0c f0       	brlt	.+2      	; 0x11c8 <__vector_17+0x98>
    11c6:	42 c0       	rjmp	.+132    	; 0x124c <__vector_17+0x11c>
    11c8:	80 91 16 09 	lds	r24, 0x0916
    11cc:	8c 30       	cpi	r24, 0x0C	; 12
    11ce:	0c f4       	brge	.+2      	; 0x11d2 <__vector_17+0xa2>
    11d0:	46 c0       	rjmp	.+140    	; 0x125e <__vector_17+0x12e>
    11d2:	3c c0       	rjmp	.+120    	; 0x124c <__vector_17+0x11c>
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
    11d4:	80 91 16 09 	lds	r24, 0x0916
    11d8:	99 27       	eor	r25, r25
    11da:	87 fd       	sbrc	r24, 7
    11dc:	90 95       	com	r25
    11de:	0c 96       	adiw	r24, 0x0c	; 12
    11e0:	fc 01       	movw	r30, r24
    11e2:	ee 0f       	add	r30, r30
    11e4:	ff 1f       	adc	r31, r31
    11e6:	8e 0f       	add	r24, r30
    11e8:	9f 1f       	adc	r25, r31
    11ea:	fc 01       	movw	r30, r24
    11ec:	e7 5e       	subi	r30, 0xE7	; 231
    11ee:	f6 4f       	sbci	r31, 0xF6	; 246
    11f0:	80 81       	ld	r24, Z
    11f2:	61 e0       	ldi	r22, 0x01	; 1
    11f4:	8f 73       	andi	r24, 0x3F	; 63
    11f6:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    11fa:	5e c0       	rjmp	.+188    	; 0x12b8 <__vector_17+0x188>
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);  
    11fc:	80 e4       	ldi	r24, 0x40	; 64
    11fe:	9c e9       	ldi	r25, 0x9C	; 156
    1200:	90 93 89 00 	sts	0x0089, r25
    1204:	80 93 88 00 	sts	0x0088, r24
    1208:	09 c0       	rjmp	.+18     	; 0x121c <__vector_17+0xec>
    else 
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    120a:	80 91 84 00 	lds	r24, 0x0084
    120e:	90 91 85 00 	lds	r25, 0x0085
    1212:	04 96       	adiw	r24, 0x04	; 4
    1214:	90 93 89 00 	sts	0x0089, r25
    1218:	80 93 88 00 	sts	0x0088, r24
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    121c:	8f ef       	ldi	r24, 0xFF	; 255
    121e:	80 93 16 09 	sts	0x0916, r24
    1222:	4a c0       	rjmp	.+148    	; 0x12b8 <__vector_17+0x188>
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
    1224:	80 91 16 09 	lds	r24, 0x0916
    1228:	99 27       	eor	r25, r25
    122a:	87 fd       	sbrc	r24, 7
    122c:	90 95       	com	r25
    122e:	0c 96       	adiw	r24, 0x0c	; 12
    1230:	fc 01       	movw	r30, r24
    1232:	ee 0f       	add	r30, r30
    1234:	ff 1f       	adc	r31, r31
    1236:	8e 0f       	add	r24, r30
    1238:	9f 1f       	adc	r25, r31
    123a:	fc 01       	movw	r30, r24
    123c:	e7 5e       	subi	r30, 0xE7	; 231
    123e:	f6 4f       	sbci	r31, 0xF6	; 246
    1240:	80 81       	ld	r24, Z
    1242:	60 e0       	ldi	r22, 0x00	; 0
    1244:	8f 73       	andi	r24, 0x3F	; 63
    1246:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    124a:	ac cf       	rjmp	.-168    	; 0x11a4 <__vector_17+0x74>
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
    124c:	80 91 84 00 	lds	r24, 0x0084
    1250:	90 91 85 00 	lds	r25, 0x0085
    1254:	04 96       	adiw	r24, 0x04	; 4
    1256:	80 34       	cpi	r24, 0x40	; 64
    1258:	9c 49       	sbci	r25, 0x9C	; 156
    125a:	80 f2       	brcs	.-96     	; 0x11fc <__vector_17+0xcc>
    125c:	d6 cf       	rjmp	.-84     	; 0x120a <__vector_17+0xda>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    125e:	20 91 84 00 	lds	r18, 0x0084
    1262:	30 91 85 00 	lds	r19, 0x0085
    1266:	e6 e1       	ldi	r30, 0x16	; 22
    1268:	f9 e0       	ldi	r31, 0x09	; 9
    126a:	80 81       	ld	r24, Z
    126c:	99 27       	eor	r25, r25
    126e:	87 fd       	sbrc	r24, 7
    1270:	90 95       	com	r25
    1272:	0c 96       	adiw	r24, 0x0c	; 12
    1274:	dc 01       	movw	r26, r24
    1276:	aa 0f       	add	r26, r26
    1278:	bb 1f       	adc	r27, r27
    127a:	8a 0f       	add	r24, r26
    127c:	9b 1f       	adc	r25, r27
    127e:	dc 01       	movw	r26, r24
    1280:	a7 5e       	subi	r26, 0xE7	; 231
    1282:	b6 4f       	sbci	r27, 0xF6	; 246
    1284:	11 96       	adiw	r26, 0x01	; 1
    1286:	8d 91       	ld	r24, X+
    1288:	9c 91       	ld	r25, X
    128a:	12 97       	sbiw	r26, 0x02	; 2
    128c:	82 0f       	add	r24, r18
    128e:	93 1f       	adc	r25, r19
    1290:	90 93 89 00 	sts	0x0089, r25
    1294:	80 93 88 00 	sts	0x0088, r24
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
    1298:	80 81       	ld	r24, Z
    129a:	99 27       	eor	r25, r25
    129c:	87 fd       	sbrc	r24, 7
    129e:	90 95       	com	r25
    12a0:	0c 96       	adiw	r24, 0x0c	; 12
    12a2:	fc 01       	movw	r30, r24
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	8e 0f       	add	r24, r30
    12aa:	9f 1f       	adc	r25, r31
    12ac:	fc 01       	movw	r30, r24
    12ae:	e7 5e       	subi	r30, 0xE7	; 231
    12b0:	f6 4f       	sbci	r31, 0xF6	; 246
    12b2:	80 81       	ld	r24, Z
    12b4:	86 fd       	sbrc	r24, 6
    12b6:	8e cf       	rjmp	.-228    	; 0x11d4 <__vector_17+0xa4>
// Interrupt handlers for Arduino 
#if defined(_useTimer1)
ISR(TIMER1_COMPA_vect) 
{ 
  handle_interrupts(_timer1, &TCNT1, &OCR1A); 
}
    12b8:	ff 91       	pop	r31
    12ba:	ef 91       	pop	r30
    12bc:	bf 91       	pop	r27
    12be:	af 91       	pop	r26
    12c0:	9f 91       	pop	r25
    12c2:	8f 91       	pop	r24
    12c4:	7f 91       	pop	r23
    12c6:	6f 91       	pop	r22
    12c8:	5f 91       	pop	r21
    12ca:	4f 91       	pop	r20
    12cc:	3f 91       	pop	r19
    12ce:	2f 91       	pop	r18
    12d0:	0f 90       	pop	r0
    12d2:	0b be       	out	0x3b, r0	; 59
    12d4:	0f 90       	pop	r0
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	0f 90       	pop	r0
    12da:	1f 90       	pop	r1
    12dc:	18 95       	reti

000012de <__vector_32>:
#endif

#if defined(_useTimer3)
ISR(TIMER3_COMPA_vect) 
{ 
    12de:	1f 92       	push	r1
    12e0:	0f 92       	push	r0
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	0f 92       	push	r0
    12e6:	11 24       	eor	r1, r1
    12e8:	0b b6       	in	r0, 0x3b	; 59
    12ea:	0f 92       	push	r0
    12ec:	2f 93       	push	r18
    12ee:	3f 93       	push	r19
    12f0:	4f 93       	push	r20
    12f2:	5f 93       	push	r21
    12f4:	6f 93       	push	r22
    12f6:	7f 93       	push	r23
    12f8:	8f 93       	push	r24
    12fa:	9f 93       	push	r25
    12fc:	af 93       	push	r26
    12fe:	bf 93       	push	r27
    1300:	ef 93       	push	r30
    1302:	ff 93       	push	r31

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    1304:	80 91 17 09 	lds	r24, 0x0917
    1308:	88 23       	and	r24, r24
    130a:	2c f4       	brge	.+10     	; 0x1316 <__vector_32+0x38>
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
    130c:	10 92 95 00 	sts	0x0095, r1
    1310:	10 92 94 00 	sts	0x0094, r1
    1314:	1e c0       	rjmp	.+60     	; 0x1352 <__vector_32+0x74>
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
    1316:	20 91 17 09 	lds	r18, 0x0917
    131a:	33 27       	eor	r19, r19
    131c:	27 fd       	sbrc	r18, 7
    131e:	30 95       	com	r19
    1320:	28 5e       	subi	r18, 0xE8	; 232
    1322:	3f 4f       	sbci	r19, 0xFF	; 255
    1324:	80 91 14 09 	lds	r24, 0x0914
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	28 17       	cp	r18, r24
    132c:	39 07       	cpc	r19, r25
    132e:	8c f4       	brge	.+34     	; 0x1352 <__vector_32+0x74>
    1330:	80 91 17 09 	lds	r24, 0x0917
    1334:	99 27       	eor	r25, r25
    1336:	87 fd       	sbrc	r24, 7
    1338:	90 95       	com	r25
    133a:	48 96       	adiw	r24, 0x18	; 24
    133c:	fc 01       	movw	r30, r24
    133e:	ee 0f       	add	r30, r30
    1340:	ff 1f       	adc	r31, r31
    1342:	8e 0f       	add	r24, r30
    1344:	9f 1f       	adc	r25, r31
    1346:	fc 01       	movw	r30, r24
    1348:	e7 5e       	subi	r30, 0xE7	; 231
    134a:	f6 4f       	sbci	r31, 0xF6	; 246
    134c:	80 81       	ld	r24, Z
    134e:	86 fd       	sbrc	r24, 6
    1350:	40 c0       	rjmp	.+128    	; 0x13d2 <__vector_32+0xf4>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
    1352:	e7 e1       	ldi	r30, 0x17	; 23
    1354:	f9 e0       	ldi	r31, 0x09	; 9
    1356:	80 81       	ld	r24, Z
    1358:	8f 5f       	subi	r24, 0xFF	; 255
    135a:	80 83       	st	Z, r24
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    135c:	20 81       	ld	r18, Z
    135e:	33 27       	eor	r19, r19
    1360:	27 fd       	sbrc	r18, 7
    1362:	30 95       	com	r19
    1364:	28 5e       	subi	r18, 0xE8	; 232
    1366:	3f 4f       	sbci	r19, 0xFF	; 255
    1368:	80 91 14 09 	lds	r24, 0x0914
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	28 17       	cp	r18, r24
    1370:	39 07       	cpc	r19, r25
    1372:	0c f0       	brlt	.+2      	; 0x1376 <__vector_32+0x98>
    1374:	42 c0       	rjmp	.+132    	; 0x13fa <__vector_32+0x11c>
    1376:	80 91 17 09 	lds	r24, 0x0917
    137a:	8c 30       	cpi	r24, 0x0C	; 12
    137c:	0c f4       	brge	.+2      	; 0x1380 <__vector_32+0xa2>
    137e:	46 c0       	rjmp	.+140    	; 0x140c <__vector_32+0x12e>
    1380:	3c c0       	rjmp	.+120    	; 0x13fa <__vector_32+0x11c>
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
    1382:	80 91 17 09 	lds	r24, 0x0917
    1386:	99 27       	eor	r25, r25
    1388:	87 fd       	sbrc	r24, 7
    138a:	90 95       	com	r25
    138c:	48 96       	adiw	r24, 0x18	; 24
    138e:	fc 01       	movw	r30, r24
    1390:	ee 0f       	add	r30, r30
    1392:	ff 1f       	adc	r31, r31
    1394:	8e 0f       	add	r24, r30
    1396:	9f 1f       	adc	r25, r31
    1398:	fc 01       	movw	r30, r24
    139a:	e7 5e       	subi	r30, 0xE7	; 231
    139c:	f6 4f       	sbci	r31, 0xF6	; 246
    139e:	80 81       	ld	r24, Z
    13a0:	61 e0       	ldi	r22, 0x01	; 1
    13a2:	8f 73       	andi	r24, 0x3F	; 63
    13a4:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    13a8:	5e c0       	rjmp	.+188    	; 0x1466 <__vector_32+0x188>
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);  
    13aa:	80 e4       	ldi	r24, 0x40	; 64
    13ac:	9c e9       	ldi	r25, 0x9C	; 156
    13ae:	90 93 99 00 	sts	0x0099, r25
    13b2:	80 93 98 00 	sts	0x0098, r24
    13b6:	09 c0       	rjmp	.+18     	; 0x13ca <__vector_32+0xec>
    else 
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    13b8:	80 91 94 00 	lds	r24, 0x0094
    13bc:	90 91 95 00 	lds	r25, 0x0095
    13c0:	04 96       	adiw	r24, 0x04	; 4
    13c2:	90 93 99 00 	sts	0x0099, r25
    13c6:	80 93 98 00 	sts	0x0098, r24
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    13ca:	8f ef       	ldi	r24, 0xFF	; 255
    13cc:	80 93 17 09 	sts	0x0917, r24
    13d0:	4a c0       	rjmp	.+148    	; 0x1466 <__vector_32+0x188>
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
    13d2:	80 91 17 09 	lds	r24, 0x0917
    13d6:	99 27       	eor	r25, r25
    13d8:	87 fd       	sbrc	r24, 7
    13da:	90 95       	com	r25
    13dc:	48 96       	adiw	r24, 0x18	; 24
    13de:	fc 01       	movw	r30, r24
    13e0:	ee 0f       	add	r30, r30
    13e2:	ff 1f       	adc	r31, r31
    13e4:	8e 0f       	add	r24, r30
    13e6:	9f 1f       	adc	r25, r31
    13e8:	fc 01       	movw	r30, r24
    13ea:	e7 5e       	subi	r30, 0xE7	; 231
    13ec:	f6 4f       	sbci	r31, 0xF6	; 246
    13ee:	80 81       	ld	r24, Z
    13f0:	60 e0       	ldi	r22, 0x00	; 0
    13f2:	8f 73       	andi	r24, 0x3F	; 63
    13f4:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    13f8:	ac cf       	rjmp	.-168    	; 0x1352 <__vector_32+0x74>
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
    13fa:	80 91 94 00 	lds	r24, 0x0094
    13fe:	90 91 95 00 	lds	r25, 0x0095
    1402:	04 96       	adiw	r24, 0x04	; 4
    1404:	80 34       	cpi	r24, 0x40	; 64
    1406:	9c 49       	sbci	r25, 0x9C	; 156
    1408:	80 f2       	brcs	.-96     	; 0x13aa <__vector_32+0xcc>
    140a:	d6 cf       	rjmp	.-84     	; 0x13b8 <__vector_32+0xda>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    140c:	20 91 94 00 	lds	r18, 0x0094
    1410:	30 91 95 00 	lds	r19, 0x0095
    1414:	e7 e1       	ldi	r30, 0x17	; 23
    1416:	f9 e0       	ldi	r31, 0x09	; 9
    1418:	80 81       	ld	r24, Z
    141a:	99 27       	eor	r25, r25
    141c:	87 fd       	sbrc	r24, 7
    141e:	90 95       	com	r25
    1420:	48 96       	adiw	r24, 0x18	; 24
    1422:	dc 01       	movw	r26, r24
    1424:	aa 0f       	add	r26, r26
    1426:	bb 1f       	adc	r27, r27
    1428:	8a 0f       	add	r24, r26
    142a:	9b 1f       	adc	r25, r27
    142c:	dc 01       	movw	r26, r24
    142e:	a7 5e       	subi	r26, 0xE7	; 231
    1430:	b6 4f       	sbci	r27, 0xF6	; 246
    1432:	11 96       	adiw	r26, 0x01	; 1
    1434:	8d 91       	ld	r24, X+
    1436:	9c 91       	ld	r25, X
    1438:	12 97       	sbiw	r26, 0x02	; 2
    143a:	82 0f       	add	r24, r18
    143c:	93 1f       	adc	r25, r19
    143e:	90 93 99 00 	sts	0x0099, r25
    1442:	80 93 98 00 	sts	0x0098, r24
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
    1446:	80 81       	ld	r24, Z
    1448:	99 27       	eor	r25, r25
    144a:	87 fd       	sbrc	r24, 7
    144c:	90 95       	com	r25
    144e:	48 96       	adiw	r24, 0x18	; 24
    1450:	fc 01       	movw	r30, r24
    1452:	ee 0f       	add	r30, r30
    1454:	ff 1f       	adc	r31, r31
    1456:	8e 0f       	add	r24, r30
    1458:	9f 1f       	adc	r25, r31
    145a:	fc 01       	movw	r30, r24
    145c:	e7 5e       	subi	r30, 0xE7	; 231
    145e:	f6 4f       	sbci	r31, 0xF6	; 246
    1460:	80 81       	ld	r24, Z
    1462:	86 fd       	sbrc	r24, 6
    1464:	8e cf       	rjmp	.-228    	; 0x1382 <__vector_32+0xa4>

#if defined(_useTimer3)
ISR(TIMER3_COMPA_vect) 
{ 
  handle_interrupts(_timer3, &TCNT3, &OCR3A); 
}
    1466:	ff 91       	pop	r31
    1468:	ef 91       	pop	r30
    146a:	bf 91       	pop	r27
    146c:	af 91       	pop	r26
    146e:	9f 91       	pop	r25
    1470:	8f 91       	pop	r24
    1472:	7f 91       	pop	r23
    1474:	6f 91       	pop	r22
    1476:	5f 91       	pop	r21
    1478:	4f 91       	pop	r20
    147a:	3f 91       	pop	r19
    147c:	2f 91       	pop	r18
    147e:	0f 90       	pop	r0
    1480:	0b be       	out	0x3b, r0	; 59
    1482:	0f 90       	pop	r0
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	0f 90       	pop	r0
    1488:	1f 90       	pop	r1
    148a:	18 95       	reti

0000148c <__vector_42>:
#endif

#if defined(_useTimer4)
ISR(TIMER4_COMPA_vect) 
{
    148c:	1f 92       	push	r1
    148e:	0f 92       	push	r0
    1490:	0f b6       	in	r0, 0x3f	; 63
    1492:	0f 92       	push	r0
    1494:	11 24       	eor	r1, r1
    1496:	0b b6       	in	r0, 0x3b	; 59
    1498:	0f 92       	push	r0
    149a:	2f 93       	push	r18
    149c:	3f 93       	push	r19
    149e:	4f 93       	push	r20
    14a0:	5f 93       	push	r21
    14a2:	6f 93       	push	r22
    14a4:	7f 93       	push	r23
    14a6:	8f 93       	push	r24
    14a8:	9f 93       	push	r25
    14aa:	af 93       	push	r26
    14ac:	bf 93       	push	r27
    14ae:	ef 93       	push	r30
    14b0:	ff 93       	push	r31

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    14b2:	80 91 18 09 	lds	r24, 0x0918
    14b6:	88 23       	and	r24, r24
    14b8:	2c f4       	brge	.+10     	; 0x14c4 <__vector_42+0x38>
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
    14ba:	10 92 a5 00 	sts	0x00A5, r1
    14be:	10 92 a4 00 	sts	0x00A4, r1
    14c2:	1e c0       	rjmp	.+60     	; 0x1500 <__vector_42+0x74>
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
    14c4:	20 91 18 09 	lds	r18, 0x0918
    14c8:	33 27       	eor	r19, r19
    14ca:	27 fd       	sbrc	r18, 7
    14cc:	30 95       	com	r19
    14ce:	2c 5d       	subi	r18, 0xDC	; 220
    14d0:	3f 4f       	sbci	r19, 0xFF	; 255
    14d2:	80 91 14 09 	lds	r24, 0x0914
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	28 17       	cp	r18, r24
    14da:	39 07       	cpc	r19, r25
    14dc:	8c f4       	brge	.+34     	; 0x1500 <__vector_42+0x74>
    14de:	80 91 18 09 	lds	r24, 0x0918
    14e2:	99 27       	eor	r25, r25
    14e4:	87 fd       	sbrc	r24, 7
    14e6:	90 95       	com	r25
    14e8:	84 96       	adiw	r24, 0x24	; 36
    14ea:	fc 01       	movw	r30, r24
    14ec:	ee 0f       	add	r30, r30
    14ee:	ff 1f       	adc	r31, r31
    14f0:	8e 0f       	add	r24, r30
    14f2:	9f 1f       	adc	r25, r31
    14f4:	fc 01       	movw	r30, r24
    14f6:	e7 5e       	subi	r30, 0xE7	; 231
    14f8:	f6 4f       	sbci	r31, 0xF6	; 246
    14fa:	80 81       	ld	r24, Z
    14fc:	86 fd       	sbrc	r24, 6
    14fe:	40 c0       	rjmp	.+128    	; 0x1580 <__vector_42+0xf4>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
    1500:	e8 e1       	ldi	r30, 0x18	; 24
    1502:	f9 e0       	ldi	r31, 0x09	; 9
    1504:	80 81       	ld	r24, Z
    1506:	8f 5f       	subi	r24, 0xFF	; 255
    1508:	80 83       	st	Z, r24
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    150a:	20 81       	ld	r18, Z
    150c:	33 27       	eor	r19, r19
    150e:	27 fd       	sbrc	r18, 7
    1510:	30 95       	com	r19
    1512:	2c 5d       	subi	r18, 0xDC	; 220
    1514:	3f 4f       	sbci	r19, 0xFF	; 255
    1516:	80 91 14 09 	lds	r24, 0x0914
    151a:	90 e0       	ldi	r25, 0x00	; 0
    151c:	28 17       	cp	r18, r24
    151e:	39 07       	cpc	r19, r25
    1520:	0c f0       	brlt	.+2      	; 0x1524 <__vector_42+0x98>
    1522:	42 c0       	rjmp	.+132    	; 0x15a8 <__vector_42+0x11c>
    1524:	80 91 18 09 	lds	r24, 0x0918
    1528:	8c 30       	cpi	r24, 0x0C	; 12
    152a:	0c f4       	brge	.+2      	; 0x152e <__vector_42+0xa2>
    152c:	46 c0       	rjmp	.+140    	; 0x15ba <__vector_42+0x12e>
    152e:	3c c0       	rjmp	.+120    	; 0x15a8 <__vector_42+0x11c>
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
    1530:	80 91 18 09 	lds	r24, 0x0918
    1534:	99 27       	eor	r25, r25
    1536:	87 fd       	sbrc	r24, 7
    1538:	90 95       	com	r25
    153a:	84 96       	adiw	r24, 0x24	; 36
    153c:	fc 01       	movw	r30, r24
    153e:	ee 0f       	add	r30, r30
    1540:	ff 1f       	adc	r31, r31
    1542:	8e 0f       	add	r24, r30
    1544:	9f 1f       	adc	r25, r31
    1546:	fc 01       	movw	r30, r24
    1548:	e7 5e       	subi	r30, 0xE7	; 231
    154a:	f6 4f       	sbci	r31, 0xF6	; 246
    154c:	80 81       	ld	r24, Z
    154e:	61 e0       	ldi	r22, 0x01	; 1
    1550:	8f 73       	andi	r24, 0x3F	; 63
    1552:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    1556:	5e c0       	rjmp	.+188    	; 0x1614 <__vector_42+0x188>
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);  
    1558:	80 e4       	ldi	r24, 0x40	; 64
    155a:	9c e9       	ldi	r25, 0x9C	; 156
    155c:	90 93 a9 00 	sts	0x00A9, r25
    1560:	80 93 a8 00 	sts	0x00A8, r24
    1564:	09 c0       	rjmp	.+18     	; 0x1578 <__vector_42+0xec>
    else 
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    1566:	80 91 a4 00 	lds	r24, 0x00A4
    156a:	90 91 a5 00 	lds	r25, 0x00A5
    156e:	04 96       	adiw	r24, 0x04	; 4
    1570:	90 93 a9 00 	sts	0x00A9, r25
    1574:	80 93 a8 00 	sts	0x00A8, r24
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    1578:	8f ef       	ldi	r24, 0xFF	; 255
    157a:	80 93 18 09 	sts	0x0918, r24
    157e:	4a c0       	rjmp	.+148    	; 0x1614 <__vector_42+0x188>
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
    1580:	80 91 18 09 	lds	r24, 0x0918
    1584:	99 27       	eor	r25, r25
    1586:	87 fd       	sbrc	r24, 7
    1588:	90 95       	com	r25
    158a:	84 96       	adiw	r24, 0x24	; 36
    158c:	fc 01       	movw	r30, r24
    158e:	ee 0f       	add	r30, r30
    1590:	ff 1f       	adc	r31, r31
    1592:	8e 0f       	add	r24, r30
    1594:	9f 1f       	adc	r25, r31
    1596:	fc 01       	movw	r30, r24
    1598:	e7 5e       	subi	r30, 0xE7	; 231
    159a:	f6 4f       	sbci	r31, 0xF6	; 246
    159c:	80 81       	ld	r24, Z
    159e:	60 e0       	ldi	r22, 0x00	; 0
    15a0:	8f 73       	andi	r24, 0x3F	; 63
    15a2:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    15a6:	ac cf       	rjmp	.-168    	; 0x1500 <__vector_42+0x74>
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
    15a8:	80 91 a4 00 	lds	r24, 0x00A4
    15ac:	90 91 a5 00 	lds	r25, 0x00A5
    15b0:	04 96       	adiw	r24, 0x04	; 4
    15b2:	80 34       	cpi	r24, 0x40	; 64
    15b4:	9c 49       	sbci	r25, 0x9C	; 156
    15b6:	80 f2       	brcs	.-96     	; 0x1558 <__vector_42+0xcc>
    15b8:	d6 cf       	rjmp	.-84     	; 0x1566 <__vector_42+0xda>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    15ba:	20 91 a4 00 	lds	r18, 0x00A4
    15be:	30 91 a5 00 	lds	r19, 0x00A5
    15c2:	e8 e1       	ldi	r30, 0x18	; 24
    15c4:	f9 e0       	ldi	r31, 0x09	; 9
    15c6:	80 81       	ld	r24, Z
    15c8:	99 27       	eor	r25, r25
    15ca:	87 fd       	sbrc	r24, 7
    15cc:	90 95       	com	r25
    15ce:	84 96       	adiw	r24, 0x24	; 36
    15d0:	dc 01       	movw	r26, r24
    15d2:	aa 0f       	add	r26, r26
    15d4:	bb 1f       	adc	r27, r27
    15d6:	8a 0f       	add	r24, r26
    15d8:	9b 1f       	adc	r25, r27
    15da:	dc 01       	movw	r26, r24
    15dc:	a7 5e       	subi	r26, 0xE7	; 231
    15de:	b6 4f       	sbci	r27, 0xF6	; 246
    15e0:	11 96       	adiw	r26, 0x01	; 1
    15e2:	8d 91       	ld	r24, X+
    15e4:	9c 91       	ld	r25, X
    15e6:	12 97       	sbiw	r26, 0x02	; 2
    15e8:	82 0f       	add	r24, r18
    15ea:	93 1f       	adc	r25, r19
    15ec:	90 93 a9 00 	sts	0x00A9, r25
    15f0:	80 93 a8 00 	sts	0x00A8, r24
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
    15f4:	80 81       	ld	r24, Z
    15f6:	99 27       	eor	r25, r25
    15f8:	87 fd       	sbrc	r24, 7
    15fa:	90 95       	com	r25
    15fc:	84 96       	adiw	r24, 0x24	; 36
    15fe:	fc 01       	movw	r30, r24
    1600:	ee 0f       	add	r30, r30
    1602:	ff 1f       	adc	r31, r31
    1604:	8e 0f       	add	r24, r30
    1606:	9f 1f       	adc	r25, r31
    1608:	fc 01       	movw	r30, r24
    160a:	e7 5e       	subi	r30, 0xE7	; 231
    160c:	f6 4f       	sbci	r31, 0xF6	; 246
    160e:	80 81       	ld	r24, Z
    1610:	86 fd       	sbrc	r24, 6
    1612:	8e cf       	rjmp	.-228    	; 0x1530 <__vector_42+0xa4>

#if defined(_useTimer4)
ISR(TIMER4_COMPA_vect) 
{
  handle_interrupts(_timer4, &TCNT4, &OCR4A); 
}
    1614:	ff 91       	pop	r31
    1616:	ef 91       	pop	r30
    1618:	bf 91       	pop	r27
    161a:	af 91       	pop	r26
    161c:	9f 91       	pop	r25
    161e:	8f 91       	pop	r24
    1620:	7f 91       	pop	r23
    1622:	6f 91       	pop	r22
    1624:	5f 91       	pop	r21
    1626:	4f 91       	pop	r20
    1628:	3f 91       	pop	r19
    162a:	2f 91       	pop	r18
    162c:	0f 90       	pop	r0
    162e:	0b be       	out	0x3b, r0	; 59
    1630:	0f 90       	pop	r0
    1632:	0f be       	out	0x3f, r0	; 63
    1634:	0f 90       	pop	r0
    1636:	1f 90       	pop	r1
    1638:	18 95       	reti

0000163a <__vector_47>:
#endif

#if defined(_useTimer5)
ISR(TIMER5_COMPA_vect) 
{
    163a:	1f 92       	push	r1
    163c:	0f 92       	push	r0
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	0f 92       	push	r0
    1642:	11 24       	eor	r1, r1
    1644:	0b b6       	in	r0, 0x3b	; 59
    1646:	0f 92       	push	r0
    1648:	2f 93       	push	r18
    164a:	3f 93       	push	r19
    164c:	4f 93       	push	r20
    164e:	5f 93       	push	r21
    1650:	6f 93       	push	r22
    1652:	7f 93       	push	r23
    1654:	8f 93       	push	r24
    1656:	9f 93       	push	r25
    1658:	af 93       	push	r26
    165a:	bf 93       	push	r27
    165c:	ef 93       	push	r30
    165e:	ff 93       	push	r31

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    1660:	80 91 15 09 	lds	r24, 0x0915
    1664:	88 23       	and	r24, r24
    1666:	2c f4       	brge	.+10     	; 0x1672 <__vector_47+0x38>
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
    1668:	10 92 25 01 	sts	0x0125, r1
    166c:	10 92 24 01 	sts	0x0124, r1
    1670:	1b c0       	rjmp	.+54     	; 0x16a8 <__vector_47+0x6e>
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
    1672:	20 91 15 09 	lds	r18, 0x0915
    1676:	33 27       	eor	r19, r19
    1678:	27 fd       	sbrc	r18, 7
    167a:	30 95       	com	r19
    167c:	80 91 14 09 	lds	r24, 0x0914
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	28 17       	cp	r18, r24
    1684:	39 07       	cpc	r19, r25
    1686:	84 f4       	brge	.+32     	; 0x16a8 <__vector_47+0x6e>
    1688:	80 91 15 09 	lds	r24, 0x0915
    168c:	99 27       	eor	r25, r25
    168e:	87 fd       	sbrc	r24, 7
    1690:	90 95       	com	r25
    1692:	fc 01       	movw	r30, r24
    1694:	ee 0f       	add	r30, r30
    1696:	ff 1f       	adc	r31, r31
    1698:	8e 0f       	add	r24, r30
    169a:	9f 1f       	adc	r25, r31
    169c:	fc 01       	movw	r30, r24
    169e:	e7 5e       	subi	r30, 0xE7	; 231
    16a0:	f6 4f       	sbci	r31, 0xF6	; 246
    16a2:	80 81       	ld	r24, Z
    16a4:	86 fd       	sbrc	r24, 6
    16a6:	3d c0       	rjmp	.+122    	; 0x1722 <__vector_47+0xe8>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
    16a8:	e5 e1       	ldi	r30, 0x15	; 21
    16aa:	f9 e0       	ldi	r31, 0x09	; 9
    16ac:	80 81       	ld	r24, Z
    16ae:	8f 5f       	subi	r24, 0xFF	; 255
    16b0:	80 83       	st	Z, r24
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    16b2:	20 81       	ld	r18, Z
    16b4:	33 27       	eor	r19, r19
    16b6:	27 fd       	sbrc	r18, 7
    16b8:	30 95       	com	r19
    16ba:	80 91 14 09 	lds	r24, 0x0914
    16be:	90 e0       	ldi	r25, 0x00	; 0
    16c0:	28 17       	cp	r18, r24
    16c2:	39 07       	cpc	r19, r25
    16c4:	0c f0       	brlt	.+2      	; 0x16c8 <__vector_47+0x8e>
    16c6:	40 c0       	rjmp	.+128    	; 0x1748 <__vector_47+0x10e>
    16c8:	80 91 15 09 	lds	r24, 0x0915
    16cc:	8c 30       	cpi	r24, 0x0C	; 12
    16ce:	0c f4       	brge	.+2      	; 0x16d2 <__vector_47+0x98>
    16d0:	44 c0       	rjmp	.+136    	; 0x175a <__vector_47+0x120>
    16d2:	3a c0       	rjmp	.+116    	; 0x1748 <__vector_47+0x10e>
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
    16d4:	80 91 15 09 	lds	r24, 0x0915
    16d8:	99 27       	eor	r25, r25
    16da:	87 fd       	sbrc	r24, 7
    16dc:	90 95       	com	r25
    16de:	fc 01       	movw	r30, r24
    16e0:	ee 0f       	add	r30, r30
    16e2:	ff 1f       	adc	r31, r31
    16e4:	8e 0f       	add	r24, r30
    16e6:	9f 1f       	adc	r25, r31
    16e8:	fc 01       	movw	r30, r24
    16ea:	e7 5e       	subi	r30, 0xE7	; 231
    16ec:	f6 4f       	sbci	r31, 0xF6	; 246
    16ee:	80 81       	ld	r24, Z
    16f0:	61 e0       	ldi	r22, 0x01	; 1
    16f2:	8f 73       	andi	r24, 0x3F	; 63
    16f4:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    16f8:	5b c0       	rjmp	.+182    	; 0x17b0 <__vector_47+0x176>
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);  
    16fa:	80 e4       	ldi	r24, 0x40	; 64
    16fc:	9c e9       	ldi	r25, 0x9C	; 156
    16fe:	90 93 29 01 	sts	0x0129, r25
    1702:	80 93 28 01 	sts	0x0128, r24
    1706:	09 c0       	rjmp	.+18     	; 0x171a <__vector_47+0xe0>
    else 
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    1708:	80 91 24 01 	lds	r24, 0x0124
    170c:	90 91 25 01 	lds	r25, 0x0125
    1710:	04 96       	adiw	r24, 0x04	; 4
    1712:	90 93 29 01 	sts	0x0129, r25
    1716:	80 93 28 01 	sts	0x0128, r24
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    171a:	8f ef       	ldi	r24, 0xFF	; 255
    171c:	80 93 15 09 	sts	0x0915, r24
    1720:	47 c0       	rjmp	.+142    	; 0x17b0 <__vector_47+0x176>
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer 
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )  
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
    1722:	80 91 15 09 	lds	r24, 0x0915
    1726:	99 27       	eor	r25, r25
    1728:	87 fd       	sbrc	r24, 7
    172a:	90 95       	com	r25
    172c:	fc 01       	movw	r30, r24
    172e:	ee 0f       	add	r30, r30
    1730:	ff 1f       	adc	r31, r31
    1732:	8e 0f       	add	r24, r30
    1734:	9f 1f       	adc	r25, r31
    1736:	fc 01       	movw	r30, r24
    1738:	e7 5e       	subi	r30, 0xE7	; 231
    173a:	f6 4f       	sbci	r31, 0xF6	; 246
    173c:	80 81       	ld	r24, Z
    173e:	60 e0       	ldi	r22, 0x00	; 0
    1740:	8f 73       	andi	r24, 0x3F	; 63
    1742:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    1746:	b0 cf       	rjmp	.-160    	; 0x16a8 <__vector_47+0x6e>
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high   
  }  
  else { 
    // finished all channels so wait for the refresh period to expire before starting over 
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
    1748:	80 91 24 01 	lds	r24, 0x0124
    174c:	90 91 25 01 	lds	r25, 0x0125
    1750:	04 96       	adiw	r24, 0x04	; 4
    1752:	80 34       	cpi	r24, 0x40	; 64
    1754:	9c 49       	sbci	r25, 0x9C	; 156
    1756:	88 f2       	brcs	.-94     	; 0x16fa <__vector_47+0xc0>
    1758:	d7 cf       	rjmp	.-82     	; 0x1708 <__vector_47+0xce>
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated   
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    175a:	20 91 24 01 	lds	r18, 0x0124
    175e:	30 91 25 01 	lds	r19, 0x0125
    1762:	e5 e1       	ldi	r30, 0x15	; 21
    1764:	f9 e0       	ldi	r31, 0x09	; 9
    1766:	80 81       	ld	r24, Z
    1768:	99 27       	eor	r25, r25
    176a:	87 fd       	sbrc	r24, 7
    176c:	90 95       	com	r25
    176e:	dc 01       	movw	r26, r24
    1770:	aa 0f       	add	r26, r26
    1772:	bb 1f       	adc	r27, r27
    1774:	8a 0f       	add	r24, r26
    1776:	9b 1f       	adc	r25, r27
    1778:	dc 01       	movw	r26, r24
    177a:	a7 5e       	subi	r26, 0xE7	; 231
    177c:	b6 4f       	sbci	r27, 0xF6	; 246
    177e:	11 96       	adiw	r26, 0x01	; 1
    1780:	8d 91       	ld	r24, X+
    1782:	9c 91       	ld	r25, X
    1784:	12 97       	sbiw	r26, 0x02	; 2
    1786:	82 0f       	add	r24, r18
    1788:	93 1f       	adc	r25, r19
    178a:	90 93 29 01 	sts	0x0129, r25
    178e:	80 93 28 01 	sts	0x0128, r24
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
    1792:	80 81       	ld	r24, Z
    1794:	99 27       	eor	r25, r25
    1796:	87 fd       	sbrc	r24, 7
    1798:	90 95       	com	r25
    179a:	fc 01       	movw	r30, r24
    179c:	ee 0f       	add	r30, r30
    179e:	ff 1f       	adc	r31, r31
    17a0:	8e 0f       	add	r24, r30
    17a2:	9f 1f       	adc	r25, r31
    17a4:	fc 01       	movw	r30, r24
    17a6:	e7 5e       	subi	r30, 0xE7	; 231
    17a8:	f6 4f       	sbci	r31, 0xF6	; 246
    17aa:	80 81       	ld	r24, Z
    17ac:	86 fd       	sbrc	r24, 6
    17ae:	92 cf       	rjmp	.-220    	; 0x16d4 <__vector_47+0x9a>

#if defined(_useTimer5)
ISR(TIMER5_COMPA_vect) 
{
  handle_interrupts(_timer5, &TCNT5, &OCR5A); 
}
    17b0:	ff 91       	pop	r31
    17b2:	ef 91       	pop	r30
    17b4:	bf 91       	pop	r27
    17b6:	af 91       	pop	r26
    17b8:	9f 91       	pop	r25
    17ba:	8f 91       	pop	r24
    17bc:	7f 91       	pop	r23
    17be:	6f 91       	pop	r22
    17c0:	5f 91       	pop	r21
    17c2:	4f 91       	pop	r20
    17c4:	3f 91       	pop	r19
    17c6:	2f 91       	pop	r18
    17c8:	0f 90       	pop	r0
    17ca:	0b be       	out	0x3b, r0	; 59
    17cc:	0f 90       	pop	r0
    17ce:	0f be       	out	0x3f, r0	; 63
    17d0:	0f 90       	pop	r0
    17d2:	1f 90       	pop	r1
    17d4:	18 95       	reti

000017d6 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    17d6:	e0 91 b5 09 	lds	r30, 0x09B5
    17da:	f0 91 b6 09 	lds	r31, 0x09B6
    17de:	80 81       	ld	r24, Z
    17e0:	81 11       	cpse	r24, r1
    17e2:	07 c0       	rjmp	.+14     	; 0x17f2 <prvResetNextTaskUnblockTime+0x1c>
    17e4:	8f ef       	ldi	r24, 0xFF	; 255
    17e6:	9f ef       	ldi	r25, 0xFF	; 255
    17e8:	90 93 19 02 	sts	0x0219, r25
    17ec:	80 93 18 02 	sts	0x0218, r24
    17f0:	08 95       	ret
    17f2:	e0 91 b5 09 	lds	r30, 0x09B5
    17f6:	f0 91 b6 09 	lds	r31, 0x09B6
    17fa:	05 80       	ldd	r0, Z+5	; 0x05
    17fc:	f6 81       	ldd	r31, Z+6	; 0x06
    17fe:	e0 2d       	mov	r30, r0
    1800:	06 80       	ldd	r0, Z+6	; 0x06
    1802:	f7 81       	ldd	r31, Z+7	; 0x07
    1804:	e0 2d       	mov	r30, r0
    1806:	82 81       	ldd	r24, Z+2	; 0x02
    1808:	93 81       	ldd	r25, Z+3	; 0x03
    180a:	90 93 19 02 	sts	0x0219, r25
    180e:	80 93 18 02 	sts	0x0218, r24
    1812:	08 95       	ret

00001814 <prvAddCurrentTaskToDelayedList>:
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	ec 01       	movw	r28, r24
    181a:	e0 91 b7 09 	lds	r30, 0x09B7
    181e:	f0 91 b8 09 	lds	r31, 0x09B8
    1822:	93 83       	std	Z+3, r25	; 0x03
    1824:	82 83       	std	Z+2, r24	; 0x02
    1826:	80 91 af 09 	lds	r24, 0x09AF
    182a:	90 91 b0 09 	lds	r25, 0x09B0
    182e:	c8 17       	cp	r28, r24
    1830:	d9 07       	cpc	r29, r25
    1832:	60 f4       	brcc	.+24     	; 0x184c <prvAddCurrentTaskToDelayedList+0x38>
    1834:	60 91 b7 09 	lds	r22, 0x09B7
    1838:	70 91 b8 09 	lds	r23, 0x09B8
    183c:	80 91 b3 09 	lds	r24, 0x09B3
    1840:	90 91 b4 09 	lds	r25, 0x09B4
    1844:	6e 5f       	subi	r22, 0xFE	; 254
    1846:	7f 4f       	sbci	r23, 0xFF	; 255
    1848:	de d8       	rcall	.-3652   	; 0xa06 <vListInsert>
    184a:	16 c0       	rjmp	.+44     	; 0x1878 <prvAddCurrentTaskToDelayedList+0x64>
    184c:	60 91 b7 09 	lds	r22, 0x09B7
    1850:	70 91 b8 09 	lds	r23, 0x09B8
    1854:	80 91 b5 09 	lds	r24, 0x09B5
    1858:	90 91 b6 09 	lds	r25, 0x09B6
    185c:	6e 5f       	subi	r22, 0xFE	; 254
    185e:	7f 4f       	sbci	r23, 0xFF	; 255
    1860:	d2 d8       	rcall	.-3676   	; 0xa06 <vListInsert>
    1862:	80 91 18 02 	lds	r24, 0x0218
    1866:	90 91 19 02 	lds	r25, 0x0219
    186a:	c8 17       	cp	r28, r24
    186c:	d9 07       	cpc	r29, r25
    186e:	20 f4       	brcc	.+8      	; 0x1878 <prvAddCurrentTaskToDelayedList+0x64>
    1870:	d0 93 19 02 	sts	0x0219, r29
    1874:	c0 93 18 02 	sts	0x0218, r28
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	08 95       	ret

0000187e <xTaskGenericCreate>:
    187e:	4f 92       	push	r4
    1880:	5f 92       	push	r5
    1882:	6f 92       	push	r6
    1884:	7f 92       	push	r7
    1886:	8f 92       	push	r8
    1888:	9f 92       	push	r9
    188a:	af 92       	push	r10
    188c:	bf 92       	push	r11
    188e:	cf 92       	push	r12
    1890:	df 92       	push	r13
    1892:	ef 92       	push	r14
    1894:	ff 92       	push	r15
    1896:	0f 93       	push	r16
    1898:	1f 93       	push	r17
    189a:	cf 93       	push	r28
    189c:	df 93       	push	r29
    189e:	4c 01       	movw	r8, r24
    18a0:	5b 01       	movw	r10, r22
    18a2:	2a 01       	movw	r4, r20
    18a4:	39 01       	movw	r6, r18
    18a6:	81 e2       	ldi	r24, 0x21	; 33
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	43 d8       	rcall	.-3962   	; 0x932 <pvPortMalloc>
    18ac:	ec 01       	movw	r28, r24
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	09 f4       	brne	.+2      	; 0x18b4 <xTaskGenericCreate+0x36>
    18b2:	dd c0       	rjmp	.+442    	; 0x1a6e <xTaskGenericCreate+0x1f0>
    18b4:	c1 14       	cp	r12, r1
    18b6:	d1 04       	cpc	r13, r1
    18b8:	09 f0       	breq	.+2      	; 0x18bc <xTaskGenericCreate+0x3e>
    18ba:	c3 c0       	rjmp	.+390    	; 0x1a42 <xTaskGenericCreate+0x1c4>
    18bc:	c2 01       	movw	r24, r4
    18be:	39 d8       	rcall	.-3982   	; 0x932 <pvPortMalloc>
    18c0:	98 8f       	std	Y+24, r25	; 0x18
    18c2:	8f 8b       	std	Y+23, r24	; 0x17
    18c4:	89 2b       	or	r24, r25
    18c6:	09 f0       	breq	.+2      	; 0x18ca <xTaskGenericCreate+0x4c>
    18c8:	be c0       	rjmp	.+380    	; 0x1a46 <xTaskGenericCreate+0x1c8>
    18ca:	ce 01       	movw	r24, r28
    18cc:	68 d8       	rcall	.-3888   	; 0x99e <vPortFree>
    18ce:	cf c0       	rjmp	.+414    	; 0x1a6e <xTaskGenericCreate+0x1f0>
    18d0:	cf 01       	movw	r24, r30
    18d2:	31 91       	ld	r19, Z+
    18d4:	da 01       	movw	r26, r20
    18d6:	3d 93       	st	X+, r19
    18d8:	ad 01       	movw	r20, r26
    18da:	dc 01       	movw	r26, r24
    18dc:	8c 91       	ld	r24, X
    18de:	88 23       	and	r24, r24
    18e0:	11 f0       	breq	.+4      	; 0x18e6 <xTaskGenericCreate+0x68>
    18e2:	21 50       	subi	r18, 0x01	; 1
    18e4:	a9 f7       	brne	.-22     	; 0x18d0 <xTaskGenericCreate+0x52>
    18e6:	18 a2       	std	Y+32, r1	; 0x20
    18e8:	10 2f       	mov	r17, r16
    18ea:	04 30       	cpi	r16, 0x04	; 4
    18ec:	08 f0       	brcs	.+2      	; 0x18f0 <xTaskGenericCreate+0x72>
    18ee:	13 e0       	ldi	r17, 0x03	; 3
    18f0:	1e 8b       	std	Y+22, r17	; 0x16
    18f2:	5e 01       	movw	r10, r28
    18f4:	b2 e0       	ldi	r27, 0x02	; 2
    18f6:	ab 0e       	add	r10, r27
    18f8:	b1 1c       	adc	r11, r1
    18fa:	c5 01       	movw	r24, r10
    18fc:	5f d8       	rcall	.-3906   	; 0x9bc <vListInitialiseItem>
    18fe:	ce 01       	movw	r24, r28
    1900:	0c 96       	adiw	r24, 0x0c	; 12
    1902:	5c d8       	rcall	.-3912   	; 0x9bc <vListInitialiseItem>
    1904:	d9 87       	std	Y+9, r29	; 0x09
    1906:	c8 87       	std	Y+8, r28	; 0x08
    1908:	84 e0       	ldi	r24, 0x04	; 4
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	81 1b       	sub	r24, r17
    190e:	91 09       	sbc	r25, r1
    1910:	9d 87       	std	Y+13, r25	; 0x0d
    1912:	8c 87       	std	Y+12, r24	; 0x0c
    1914:	db 8b       	std	Y+19, r29	; 0x13
    1916:	ca 8b       	std	Y+18, r28	; 0x12
    1918:	a3 01       	movw	r20, r6
    191a:	b4 01       	movw	r22, r8
    191c:	c6 01       	movw	r24, r12
    191e:	ca d8       	rcall	.-3692   	; 0xab4 <pxPortInitialiseStack>
    1920:	99 83       	std	Y+1, r25	; 0x01
    1922:	88 83       	st	Y, r24
    1924:	e1 14       	cp	r14, r1
    1926:	f1 04       	cpc	r15, r1
    1928:	19 f0       	breq	.+6      	; 0x1930 <xTaskGenericCreate+0xb2>
    192a:	f7 01       	movw	r30, r14
    192c:	d1 83       	std	Z+1, r29	; 0x01
    192e:	c0 83       	st	Z, r28
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	0f 92       	push	r0
    1936:	80 91 b1 09 	lds	r24, 0x09B1
    193a:	8f 5f       	subi	r24, 0xFF	; 255
    193c:	80 93 b1 09 	sts	0x09B1, r24
    1940:	80 91 b7 09 	lds	r24, 0x09B7
    1944:	90 91 b8 09 	lds	r25, 0x09B8
    1948:	89 2b       	or	r24, r25
    194a:	09 f0       	breq	.+2      	; 0x194e <xTaskGenericCreate+0xd0>
    194c:	3c c0       	rjmp	.+120    	; 0x19c6 <xTaskGenericCreate+0x148>
    194e:	d0 93 b8 09 	sts	0x09B8, r29
    1952:	c0 93 b7 09 	sts	0x09B7, r28
    1956:	80 91 b1 09 	lds	r24, 0x09B1
    195a:	81 30       	cpi	r24, 0x01	; 1
    195c:	09 f0       	breq	.+2      	; 0x1960 <xTaskGenericCreate+0xe2>
    195e:	42 c0       	rjmp	.+132    	; 0x19e4 <xTaskGenericCreate+0x166>
    1960:	e1 2c       	mov	r14, r1
    1962:	f1 2c       	mov	r15, r1
    1964:	c7 01       	movw	r24, r14
    1966:	88 0f       	add	r24, r24
    1968:	99 1f       	adc	r25, r25
    196a:	88 0f       	add	r24, r24
    196c:	99 1f       	adc	r25, r25
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	8e 0d       	add	r24, r14
    1974:	9f 1d       	adc	r25, r15
    1976:	86 54       	subi	r24, 0x46	; 70
    1978:	96 4f       	sbci	r25, 0xF6	; 246
    197a:	12 d8       	rcall	.-4060   	; 0x9a0 <vListInitialise>
    197c:	ff ef       	ldi	r31, 0xFF	; 255
    197e:	ef 1a       	sub	r14, r31
    1980:	ff 0a       	sbc	r15, r31
    1982:	84 e0       	ldi	r24, 0x04	; 4
    1984:	e8 16       	cp	r14, r24
    1986:	f1 04       	cpc	r15, r1
    1988:	69 f7       	brne	.-38     	; 0x1964 <xTaskGenericCreate+0xe6>
    198a:	8e ed       	ldi	r24, 0xDE	; 222
    198c:	99 e0       	ldi	r25, 0x09	; 9
    198e:	08 d8       	rcall	.-4080   	; 0x9a0 <vListInitialise>
    1990:	87 ee       	ldi	r24, 0xE7	; 231
    1992:	99 e0       	ldi	r25, 0x09	; 9
    1994:	05 d8       	rcall	.-4086   	; 0x9a0 <vListInitialise>
    1996:	80 ef       	ldi	r24, 0xF0	; 240
    1998:	99 e0       	ldi	r25, 0x09	; 9
    199a:	02 d8       	rcall	.-4092   	; 0x9a0 <vListInitialise>
    199c:	89 ef       	ldi	r24, 0xF9	; 249
    199e:	99 e0       	ldi	r25, 0x09	; 9
    19a0:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListInitialise>
    19a4:	82 e0       	ldi	r24, 0x02	; 2
    19a6:	9a e0       	ldi	r25, 0x0A	; 10
    19a8:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListInitialise>
    19ac:	8e ed       	ldi	r24, 0xDE	; 222
    19ae:	99 e0       	ldi	r25, 0x09	; 9
    19b0:	90 93 b6 09 	sts	0x09B6, r25
    19b4:	80 93 b5 09 	sts	0x09B5, r24
    19b8:	87 ee       	ldi	r24, 0xE7	; 231
    19ba:	99 e0       	ldi	r25, 0x09	; 9
    19bc:	90 93 b4 09 	sts	0x09B4, r25
    19c0:	80 93 b3 09 	sts	0x09B3, r24
    19c4:	0f c0       	rjmp	.+30     	; 0x19e4 <xTaskGenericCreate+0x166>
    19c6:	80 91 ad 09 	lds	r24, 0x09AD
    19ca:	81 11       	cpse	r24, r1
    19cc:	0b c0       	rjmp	.+22     	; 0x19e4 <xTaskGenericCreate+0x166>
    19ce:	e0 91 b7 09 	lds	r30, 0x09B7
    19d2:	f0 91 b8 09 	lds	r31, 0x09B8
    19d6:	86 89       	ldd	r24, Z+22	; 0x16
    19d8:	08 17       	cp	r16, r24
    19da:	20 f0       	brcs	.+8      	; 0x19e4 <xTaskGenericCreate+0x166>
    19dc:	d0 93 b8 09 	sts	0x09B8, r29
    19e0:	c0 93 b7 09 	sts	0x09B7, r28
    19e4:	80 91 b9 09 	lds	r24, 0x09B9
    19e8:	8f 5f       	subi	r24, 0xFF	; 255
    19ea:	80 93 b9 09 	sts	0x09B9, r24
    19ee:	8e 89       	ldd	r24, Y+22	; 0x16
    19f0:	90 91 ae 09 	lds	r25, 0x09AE
    19f4:	98 17       	cp	r25, r24
    19f6:	10 f4       	brcc	.+4      	; 0x19fc <xTaskGenericCreate+0x17e>
    19f8:	80 93 ae 09 	sts	0x09AE, r24
    19fc:	90 e0       	ldi	r25, 0x00	; 0
    19fe:	9c 01       	movw	r18, r24
    1a00:	22 0f       	add	r18, r18
    1a02:	33 1f       	adc	r19, r19
    1a04:	22 0f       	add	r18, r18
    1a06:	33 1f       	adc	r19, r19
    1a08:	22 0f       	add	r18, r18
    1a0a:	33 1f       	adc	r19, r19
    1a0c:	82 0f       	add	r24, r18
    1a0e:	93 1f       	adc	r25, r19
    1a10:	b5 01       	movw	r22, r10
    1a12:	86 54       	subi	r24, 0x46	; 70
    1a14:	96 4f       	sbci	r25, 0xF6	; 246
    1a16:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInsertEnd>
    1a1a:	0f 90       	pop	r0
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	80 91 ad 09 	lds	r24, 0x09AD
    1a22:	88 23       	and	r24, r24
    1a24:	51 f0       	breq	.+20     	; 0x1a3a <xTaskGenericCreate+0x1bc>
    1a26:	e0 91 b7 09 	lds	r30, 0x09B7
    1a2a:	f0 91 b8 09 	lds	r31, 0x09B8
    1a2e:	86 89       	ldd	r24, Z+22	; 0x16
    1a30:	80 17       	cp	r24, r16
    1a32:	28 f4       	brcc	.+10     	; 0x1a3e <xTaskGenericCreate+0x1c0>
    1a34:	1d d9       	rcall	.-3526   	; 0xc70 <vPortYield>
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	1b c0       	rjmp	.+54     	; 0x1a70 <xTaskGenericCreate+0x1f2>
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	19 c0       	rjmp	.+50     	; 0x1a70 <xTaskGenericCreate+0x1f2>
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	17 c0       	rjmp	.+46     	; 0x1a70 <xTaskGenericCreate+0x1f2>
    1a42:	d8 8e       	std	Y+24, r13	; 0x18
    1a44:	cf 8a       	std	Y+23, r12	; 0x17
    1a46:	a1 e0       	ldi	r26, 0x01	; 1
    1a48:	4a 1a       	sub	r4, r26
    1a4a:	51 08       	sbc	r5, r1
    1a4c:	cf 88       	ldd	r12, Y+23	; 0x17
    1a4e:	d8 8c       	ldd	r13, Y+24	; 0x18
    1a50:	c4 0c       	add	r12, r4
    1a52:	d5 1c       	adc	r13, r5
    1a54:	f5 01       	movw	r30, r10
    1a56:	80 81       	ld	r24, Z
    1a58:	89 8f       	std	Y+25, r24	; 0x19
    1a5a:	80 81       	ld	r24, Z
    1a5c:	88 23       	and	r24, r24
    1a5e:	09 f4       	brne	.+2      	; 0x1a62 <xTaskGenericCreate+0x1e4>
    1a60:	42 cf       	rjmp	.-380    	; 0x18e6 <xTaskGenericCreate+0x68>
    1a62:	ae 01       	movw	r20, r28
    1a64:	46 5e       	subi	r20, 0xE6	; 230
    1a66:	5f 4f       	sbci	r21, 0xFF	; 255
    1a68:	31 96       	adiw	r30, 0x01	; 1
    1a6a:	27 e0       	ldi	r18, 0x07	; 7
    1a6c:	31 cf       	rjmp	.-414    	; 0x18d0 <xTaskGenericCreate+0x52>
    1a6e:	8f ef       	ldi	r24, 0xFF	; 255
    1a70:	df 91       	pop	r29
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	ff 90       	pop	r15
    1a7a:	ef 90       	pop	r14
    1a7c:	df 90       	pop	r13
    1a7e:	cf 90       	pop	r12
    1a80:	bf 90       	pop	r11
    1a82:	af 90       	pop	r10
    1a84:	9f 90       	pop	r9
    1a86:	8f 90       	pop	r8
    1a88:	7f 90       	pop	r7
    1a8a:	6f 90       	pop	r6
    1a8c:	5f 90       	pop	r5
    1a8e:	4f 90       	pop	r4
    1a90:	08 95       	ret

00001a92 <vTaskStartScheduler>:
    1a92:	af 92       	push	r10
    1a94:	bf 92       	push	r11
    1a96:	cf 92       	push	r12
    1a98:	df 92       	push	r13
    1a9a:	ef 92       	push	r14
    1a9c:	ff 92       	push	r15
    1a9e:	0f 93       	push	r16
    1aa0:	a1 2c       	mov	r10, r1
    1aa2:	b1 2c       	mov	r11, r1
    1aa4:	c1 2c       	mov	r12, r1
    1aa6:	d1 2c       	mov	r13, r1
    1aa8:	e1 2c       	mov	r14, r1
    1aaa:	f1 2c       	mov	r15, r1
    1aac:	00 e0       	ldi	r16, 0x00	; 0
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	45 e5       	ldi	r20, 0x55	; 85
    1ab4:	50 e0       	ldi	r21, 0x00	; 0
    1ab6:	60 e7       	ldi	r22, 0x70	; 112
    1ab8:	72 e0       	ldi	r23, 0x02	; 2
    1aba:	86 eb       	ldi	r24, 0xB6	; 182
    1abc:	9e e0       	ldi	r25, 0x0E	; 14
    1abe:	df de       	rcall	.-578    	; 0x187e <xTaskGenericCreate>
    1ac0:	81 30       	cpi	r24, 0x01	; 1
    1ac2:	41 f4       	brne	.+16     	; 0x1ad4 <vTaskStartScheduler+0x42>
    1ac4:	f8 94       	cli
    1ac6:	80 93 ad 09 	sts	0x09AD, r24
    1aca:	10 92 b0 09 	sts	0x09B0, r1
    1ace:	10 92 af 09 	sts	0x09AF, r1
    1ad2:	8d d8       	rcall	.-3814   	; 0xbee <xPortStartScheduler>
    1ad4:	0f 91       	pop	r16
    1ad6:	ff 90       	pop	r15
    1ad8:	ef 90       	pop	r14
    1ada:	df 90       	pop	r13
    1adc:	cf 90       	pop	r12
    1ade:	bf 90       	pop	r11
    1ae0:	af 90       	pop	r10
    1ae2:	08 95       	ret

00001ae4 <vTaskSuspendAll>:
    1ae4:	80 91 a9 09 	lds	r24, 0x09A9
    1ae8:	8f 5f       	subi	r24, 0xFF	; 255
    1aea:	80 93 a9 09 	sts	0x09A9, r24
    1aee:	08 95       	ret

00001af0 <xTaskIncrementTick>:
    1af0:	cf 92       	push	r12
    1af2:	df 92       	push	r13
    1af4:	ef 92       	push	r14
    1af6:	ff 92       	push	r15
    1af8:	0f 93       	push	r16
    1afa:	1f 93       	push	r17
    1afc:	cf 93       	push	r28
    1afe:	df 93       	push	r29
    1b00:	80 91 a9 09 	lds	r24, 0x09A9
    1b04:	81 11       	cpse	r24, r1
    1b06:	99 c0       	rjmp	.+306    	; 0x1c3a <xTaskIncrementTick+0x14a>
    1b08:	80 91 af 09 	lds	r24, 0x09AF
    1b0c:	90 91 b0 09 	lds	r25, 0x09B0
    1b10:	01 96       	adiw	r24, 0x01	; 1
    1b12:	90 93 b0 09 	sts	0x09B0, r25
    1b16:	80 93 af 09 	sts	0x09AF, r24
    1b1a:	e0 90 af 09 	lds	r14, 0x09AF
    1b1e:	f0 90 b0 09 	lds	r15, 0x09B0
    1b22:	e1 14       	cp	r14, r1
    1b24:	f1 04       	cpc	r15, r1
    1b26:	b1 f4       	brne	.+44     	; 0x1b54 <xTaskIncrementTick+0x64>
    1b28:	80 91 b5 09 	lds	r24, 0x09B5
    1b2c:	90 91 b6 09 	lds	r25, 0x09B6
    1b30:	20 91 b3 09 	lds	r18, 0x09B3
    1b34:	30 91 b4 09 	lds	r19, 0x09B4
    1b38:	30 93 b6 09 	sts	0x09B6, r19
    1b3c:	20 93 b5 09 	sts	0x09B5, r18
    1b40:	90 93 b4 09 	sts	0x09B4, r25
    1b44:	80 93 b3 09 	sts	0x09B3, r24
    1b48:	80 91 aa 09 	lds	r24, 0x09AA
    1b4c:	8f 5f       	subi	r24, 0xFF	; 255
    1b4e:	80 93 aa 09 	sts	0x09AA, r24
    1b52:	41 de       	rcall	.-894    	; 0x17d6 <prvResetNextTaskUnblockTime>
    1b54:	80 91 18 02 	lds	r24, 0x0218
    1b58:	90 91 19 02 	lds	r25, 0x0219
    1b5c:	e8 16       	cp	r14, r24
    1b5e:	f9 06       	cpc	r15, r25
    1b60:	20 f4       	brcc	.+8      	; 0x1b6a <xTaskIncrementTick+0x7a>
    1b62:	d1 2c       	mov	r13, r1
    1b64:	54 c0       	rjmp	.+168    	; 0x1c0e <xTaskIncrementTick+0x11e>
    1b66:	dc 2c       	mov	r13, r12
    1b68:	03 c0       	rjmp	.+6      	; 0x1b70 <xTaskIncrementTick+0x80>
    1b6a:	d1 2c       	mov	r13, r1
    1b6c:	cc 24       	eor	r12, r12
    1b6e:	c3 94       	inc	r12
    1b70:	e0 91 b5 09 	lds	r30, 0x09B5
    1b74:	f0 91 b6 09 	lds	r31, 0x09B6
    1b78:	80 81       	ld	r24, Z
    1b7a:	81 11       	cpse	r24, r1
    1b7c:	07 c0       	rjmp	.+14     	; 0x1b8c <xTaskIncrementTick+0x9c>
    1b7e:	8f ef       	ldi	r24, 0xFF	; 255
    1b80:	9f ef       	ldi	r25, 0xFF	; 255
    1b82:	90 93 19 02 	sts	0x0219, r25
    1b86:	80 93 18 02 	sts	0x0218, r24
    1b8a:	41 c0       	rjmp	.+130    	; 0x1c0e <xTaskIncrementTick+0x11e>
    1b8c:	e0 91 b5 09 	lds	r30, 0x09B5
    1b90:	f0 91 b6 09 	lds	r31, 0x09B6
    1b94:	05 80       	ldd	r0, Z+5	; 0x05
    1b96:	f6 81       	ldd	r31, Z+6	; 0x06
    1b98:	e0 2d       	mov	r30, r0
    1b9a:	c6 81       	ldd	r28, Z+6	; 0x06
    1b9c:	d7 81       	ldd	r29, Z+7	; 0x07
    1b9e:	2a 81       	ldd	r18, Y+2	; 0x02
    1ba0:	3b 81       	ldd	r19, Y+3	; 0x03
    1ba2:	e2 16       	cp	r14, r18
    1ba4:	f3 06       	cpc	r15, r19
    1ba6:	28 f4       	brcc	.+10     	; 0x1bb2 <xTaskIncrementTick+0xc2>
    1ba8:	30 93 19 02 	sts	0x0219, r19
    1bac:	20 93 18 02 	sts	0x0218, r18
    1bb0:	2e c0       	rjmp	.+92     	; 0x1c0e <xTaskIncrementTick+0x11e>
    1bb2:	8e 01       	movw	r16, r28
    1bb4:	0e 5f       	subi	r16, 0xFE	; 254
    1bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb8:	c8 01       	movw	r24, r16
    1bba:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1bbe:	8c 89       	ldd	r24, Y+20	; 0x14
    1bc0:	9d 89       	ldd	r25, Y+21	; 0x15
    1bc2:	89 2b       	or	r24, r25
    1bc4:	21 f0       	breq	.+8      	; 0x1bce <xTaskIncrementTick+0xde>
    1bc6:	ce 01       	movw	r24, r28
    1bc8:	0c 96       	adiw	r24, 0x0c	; 12
    1bca:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1bce:	2e 89       	ldd	r18, Y+22	; 0x16
    1bd0:	80 91 ae 09 	lds	r24, 0x09AE
    1bd4:	82 17       	cp	r24, r18
    1bd6:	10 f4       	brcc	.+4      	; 0x1bdc <xTaskIncrementTick+0xec>
    1bd8:	20 93 ae 09 	sts	0x09AE, r18
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	c9 01       	movw	r24, r18
    1be0:	88 0f       	add	r24, r24
    1be2:	99 1f       	adc	r25, r25
    1be4:	88 0f       	add	r24, r24
    1be6:	99 1f       	adc	r25, r25
    1be8:	88 0f       	add	r24, r24
    1bea:	99 1f       	adc	r25, r25
    1bec:	82 0f       	add	r24, r18
    1bee:	93 1f       	adc	r25, r19
    1bf0:	b8 01       	movw	r22, r16
    1bf2:	86 54       	subi	r24, 0x46	; 70
    1bf4:	96 4f       	sbci	r25, 0xF6	; 246
    1bf6:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInsertEnd>
    1bfa:	e0 91 b7 09 	lds	r30, 0x09B7
    1bfe:	f0 91 b8 09 	lds	r31, 0x09B8
    1c02:	9e 89       	ldd	r25, Y+22	; 0x16
    1c04:	86 89       	ldd	r24, Z+22	; 0x16
    1c06:	98 17       	cp	r25, r24
    1c08:	08 f0       	brcs	.+2      	; 0x1c0c <xTaskIncrementTick+0x11c>
    1c0a:	ad cf       	rjmp	.-166    	; 0x1b66 <xTaskIncrementTick+0x76>
    1c0c:	b1 cf       	rjmp	.-158    	; 0x1b70 <xTaskIncrementTick+0x80>
    1c0e:	e0 91 b7 09 	lds	r30, 0x09B7
    1c12:	f0 91 b8 09 	lds	r31, 0x09B8
    1c16:	86 89       	ldd	r24, Z+22	; 0x16
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	ee 0f       	add	r30, r30
    1c1e:	ff 1f       	adc	r31, r31
    1c20:	ee 0f       	add	r30, r30
    1c22:	ff 1f       	adc	r31, r31
    1c24:	ee 0f       	add	r30, r30
    1c26:	ff 1f       	adc	r31, r31
    1c28:	8e 0f       	add	r24, r30
    1c2a:	9f 1f       	adc	r25, r31
    1c2c:	fc 01       	movw	r30, r24
    1c2e:	e6 54       	subi	r30, 0x46	; 70
    1c30:	f6 4f       	sbci	r31, 0xF6	; 246
    1c32:	80 81       	ld	r24, Z
    1c34:	82 30       	cpi	r24, 0x02	; 2
    1c36:	40 f4       	brcc	.+16     	; 0x1c48 <xTaskIncrementTick+0x158>
    1c38:	09 c0       	rjmp	.+18     	; 0x1c4c <xTaskIncrementTick+0x15c>
    1c3a:	80 91 ac 09 	lds	r24, 0x09AC
    1c3e:	8f 5f       	subi	r24, 0xFF	; 255
    1c40:	80 93 ac 09 	sts	0x09AC, r24
    1c44:	d1 2c       	mov	r13, r1
    1c46:	02 c0       	rjmp	.+4      	; 0x1c4c <xTaskIncrementTick+0x15c>
    1c48:	dd 24       	eor	r13, r13
    1c4a:	d3 94       	inc	r13
    1c4c:	80 91 ab 09 	lds	r24, 0x09AB
    1c50:	88 23       	and	r24, r24
    1c52:	11 f0       	breq	.+4      	; 0x1c58 <xTaskIncrementTick+0x168>
    1c54:	dd 24       	eor	r13, r13
    1c56:	d3 94       	inc	r13
    1c58:	8d 2d       	mov	r24, r13
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	1f 91       	pop	r17
    1c60:	0f 91       	pop	r16
    1c62:	ff 90       	pop	r15
    1c64:	ef 90       	pop	r14
    1c66:	df 90       	pop	r13
    1c68:	cf 90       	pop	r12
    1c6a:	08 95       	ret

00001c6c <xTaskResumeAll>:
    1c6c:	df 92       	push	r13
    1c6e:	ef 92       	push	r14
    1c70:	ff 92       	push	r15
    1c72:	0f 93       	push	r16
    1c74:	1f 93       	push	r17
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	0f b6       	in	r0, 0x3f	; 63
    1c7c:	f8 94       	cli
    1c7e:	0f 92       	push	r0
    1c80:	80 91 a9 09 	lds	r24, 0x09A9
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	80 93 a9 09 	sts	0x09A9, r24
    1c8a:	80 91 a9 09 	lds	r24, 0x09A9
    1c8e:	81 11       	cpse	r24, r1
    1c90:	60 c0       	rjmp	.+192    	; 0x1d52 <xTaskResumeAll+0xe6>
    1c92:	80 91 b1 09 	lds	r24, 0x09B1
    1c96:	81 11       	cpse	r24, r1
    1c98:	32 c0       	rjmp	.+100    	; 0x1cfe <xTaskResumeAll+0x92>
    1c9a:	5e c0       	rjmp	.+188    	; 0x1d58 <xTaskResumeAll+0xec>
    1c9c:	e0 91 f5 09 	lds	r30, 0x09F5
    1ca0:	f0 91 f6 09 	lds	r31, 0x09F6
    1ca4:	c6 81       	ldd	r28, Z+6	; 0x06
    1ca6:	d7 81       	ldd	r29, Z+7	; 0x07
    1ca8:	ce 01       	movw	r24, r28
    1caa:	0c 96       	adiw	r24, 0x0c	; 12
    1cac:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1cb0:	8e 01       	movw	r16, r28
    1cb2:	0e 5f       	subi	r16, 0xFE	; 254
    1cb4:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb6:	c8 01       	movw	r24, r16
    1cb8:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1cbc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cbe:	90 91 ae 09 	lds	r25, 0x09AE
    1cc2:	98 17       	cp	r25, r24
    1cc4:	10 f4       	brcc	.+4      	; 0x1cca <xTaskResumeAll+0x5e>
    1cc6:	80 93 ae 09 	sts	0x09AE, r24
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	9c 01       	movw	r18, r24
    1cce:	22 0f       	add	r18, r18
    1cd0:	33 1f       	adc	r19, r19
    1cd2:	22 0f       	add	r18, r18
    1cd4:	33 1f       	adc	r19, r19
    1cd6:	22 0f       	add	r18, r18
    1cd8:	33 1f       	adc	r19, r19
    1cda:	82 0f       	add	r24, r18
    1cdc:	93 1f       	adc	r25, r19
    1cde:	b8 01       	movw	r22, r16
    1ce0:	86 54       	subi	r24, 0x46	; 70
    1ce2:	96 4f       	sbci	r25, 0xF6	; 246
    1ce4:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInsertEnd>
    1ce8:	e0 91 b7 09 	lds	r30, 0x09B7
    1cec:	f0 91 b8 09 	lds	r31, 0x09B8
    1cf0:	9e 89       	ldd	r25, Y+22	; 0x16
    1cf2:	86 89       	ldd	r24, Z+22	; 0x16
    1cf4:	98 17       	cp	r25, r24
    1cf6:	58 f0       	brcs	.+22     	; 0x1d0e <xTaskResumeAll+0xa2>
    1cf8:	d0 92 ab 09 	sts	0x09AB, r13
    1cfc:	08 c0       	rjmp	.+16     	; 0x1d0e <xTaskResumeAll+0xa2>
    1cfe:	0f 2e       	mov	r0, r31
    1d00:	f0 ef       	ldi	r31, 0xF0	; 240
    1d02:	ef 2e       	mov	r14, r31
    1d04:	f9 e0       	ldi	r31, 0x09	; 9
    1d06:	ff 2e       	mov	r15, r31
    1d08:	f0 2d       	mov	r31, r0
    1d0a:	dd 24       	eor	r13, r13
    1d0c:	d3 94       	inc	r13
    1d0e:	f7 01       	movw	r30, r14
    1d10:	80 81       	ld	r24, Z
    1d12:	81 11       	cpse	r24, r1
    1d14:	c3 cf       	rjmp	.-122    	; 0x1c9c <xTaskResumeAll+0x30>
    1d16:	80 91 ac 09 	lds	r24, 0x09AC
    1d1a:	88 23       	and	r24, r24
    1d1c:	91 f0       	breq	.+36     	; 0x1d42 <xTaskResumeAll+0xd6>
    1d1e:	80 91 ac 09 	lds	r24, 0x09AC
    1d22:	88 23       	and	r24, r24
    1d24:	71 f0       	breq	.+28     	; 0x1d42 <xTaskResumeAll+0xd6>
    1d26:	c1 e0       	ldi	r28, 0x01	; 1
    1d28:	e3 de       	rcall	.-570    	; 0x1af0 <xTaskIncrementTick>
    1d2a:	81 11       	cpse	r24, r1
    1d2c:	c0 93 ab 09 	sts	0x09AB, r28
    1d30:	80 91 ac 09 	lds	r24, 0x09AC
    1d34:	81 50       	subi	r24, 0x01	; 1
    1d36:	80 93 ac 09 	sts	0x09AC, r24
    1d3a:	80 91 ac 09 	lds	r24, 0x09AC
    1d3e:	81 11       	cpse	r24, r1
    1d40:	f3 cf       	rjmp	.-26     	; 0x1d28 <xTaskResumeAll+0xbc>
    1d42:	80 91 ab 09 	lds	r24, 0x09AB
    1d46:	81 30       	cpi	r24, 0x01	; 1
    1d48:	31 f4       	brne	.+12     	; 0x1d56 <xTaskResumeAll+0xea>
    1d4a:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	03 c0       	rjmp	.+6      	; 0x1d58 <xTaskResumeAll+0xec>
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	01 c0       	rjmp	.+2      	; 0x1d58 <xTaskResumeAll+0xec>
    1d56:	80 e0       	ldi	r24, 0x00	; 0
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	df 91       	pop	r29
    1d5e:	cf 91       	pop	r28
    1d60:	1f 91       	pop	r17
    1d62:	0f 91       	pop	r16
    1d64:	ff 90       	pop	r15
    1d66:	ef 90       	pop	r14
    1d68:	df 90       	pop	r13
    1d6a:	08 95       	ret

00001d6c <prvIdleTask>:
    1d6c:	c9 ef       	ldi	r28, 0xF9	; 249
    1d6e:	d9 e0       	ldi	r29, 0x09	; 9
    1d70:	0f 2e       	mov	r0, r31
    1d72:	fa eb       	ldi	r31, 0xBA	; 186
    1d74:	ef 2e       	mov	r14, r31
    1d76:	f9 e0       	ldi	r31, 0x09	; 9
    1d78:	ff 2e       	mov	r15, r31
    1d7a:	f0 2d       	mov	r31, r0
    1d7c:	26 c0       	rjmp	.+76     	; 0x1dca <prvIdleTask+0x5e>
    1d7e:	b2 de       	rcall	.-668    	; 0x1ae4 <vTaskSuspendAll>
    1d80:	18 81       	ld	r17, Y
    1d82:	74 df       	rcall	.-280    	; 0x1c6c <xTaskResumeAll>
    1d84:	11 23       	and	r17, r17
    1d86:	09 f1       	breq	.+66     	; 0x1dca <prvIdleTask+0x5e>
    1d88:	0f b6       	in	r0, 0x3f	; 63
    1d8a:	f8 94       	cli
    1d8c:	0f 92       	push	r0
    1d8e:	e0 91 fe 09 	lds	r30, 0x09FE
    1d92:	f0 91 ff 09 	lds	r31, 0x09FF
    1d96:	06 81       	ldd	r16, Z+6	; 0x06
    1d98:	17 81       	ldd	r17, Z+7	; 0x07
    1d9a:	c8 01       	movw	r24, r16
    1d9c:	02 96       	adiw	r24, 0x02	; 2
    1d9e:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1da2:	80 91 b1 09 	lds	r24, 0x09B1
    1da6:	81 50       	subi	r24, 0x01	; 1
    1da8:	80 93 b1 09 	sts	0x09B1, r24
    1dac:	80 91 b2 09 	lds	r24, 0x09B2
    1db0:	81 50       	subi	r24, 0x01	; 1
    1db2:	80 93 b2 09 	sts	0x09B2, r24
    1db6:	0f 90       	pop	r0
    1db8:	0f be       	out	0x3f, r0	; 63
    1dba:	f8 01       	movw	r30, r16
    1dbc:	87 89       	ldd	r24, Z+23	; 0x17
    1dbe:	90 8d       	ldd	r25, Z+24	; 0x18
    1dc0:	0e 94 cf 04 	call	0x99e	; 0x99e <vPortFree>
    1dc4:	c8 01       	movw	r24, r16
    1dc6:	0e 94 cf 04 	call	0x99e	; 0x99e <vPortFree>
    1dca:	80 91 b2 09 	lds	r24, 0x09B2
    1dce:	81 11       	cpse	r24, r1
    1dd0:	d6 cf       	rjmp	.-84     	; 0x1d7e <prvIdleTask+0x12>
    1dd2:	f7 01       	movw	r30, r14
    1dd4:	80 81       	ld	r24, Z
    1dd6:	82 30       	cpi	r24, 0x02	; 2
    1dd8:	c0 f3       	brcs	.-16     	; 0x1dca <prvIdleTask+0x5e>
    1dda:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    1dde:	f5 cf       	rjmp	.-22     	; 0x1dca <prvIdleTask+0x5e>

00001de0 <vTaskDelay>:
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	ec 01       	movw	r28, r24
    1de6:	00 97       	sbiw	r24, 0x00	; 0
    1de8:	99 f0       	breq	.+38     	; 0x1e10 <vTaskDelay+0x30>
    1dea:	7c de       	rcall	.-776    	; 0x1ae4 <vTaskSuspendAll>
    1dec:	80 91 af 09 	lds	r24, 0x09AF
    1df0:	90 91 b0 09 	lds	r25, 0x09B0
    1df4:	c8 0f       	add	r28, r24
    1df6:	d9 1f       	adc	r29, r25
    1df8:	80 91 b7 09 	lds	r24, 0x09B7
    1dfc:	90 91 b8 09 	lds	r25, 0x09B8
    1e00:	02 96       	adiw	r24, 0x02	; 2
    1e02:	0e 94 34 05 	call	0xa68	; 0xa68 <uxListRemove>
    1e06:	ce 01       	movw	r24, r28
    1e08:	05 dd       	rcall	.-1526   	; 0x1814 <prvAddCurrentTaskToDelayedList>
    1e0a:	30 df       	rcall	.-416    	; 0x1c6c <xTaskResumeAll>
    1e0c:	81 11       	cpse	r24, r1
    1e0e:	02 c0       	rjmp	.+4      	; 0x1e14 <vTaskDelay+0x34>
    1e10:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	08 95       	ret

00001e1a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1e1a:	80 91 a9 09 	lds	r24, 0x09A9
    1e1e:	88 23       	and	r24, r24
    1e20:	21 f0       	breq	.+8      	; 0x1e2a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1e22:	81 e0       	ldi	r24, 0x01	; 1
    1e24:	80 93 ab 09 	sts	0x09AB, r24
    1e28:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1e2a:	10 92 ab 09 	sts	0x09AB, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1e2e:	80 91 ae 09 	lds	r24, 0x09AE
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	fc 01       	movw	r30, r24
    1e36:	ee 0f       	add	r30, r30
    1e38:	ff 1f       	adc	r31, r31
    1e3a:	ee 0f       	add	r30, r30
    1e3c:	ff 1f       	adc	r31, r31
    1e3e:	ee 0f       	add	r30, r30
    1e40:	ff 1f       	adc	r31, r31
    1e42:	8e 0f       	add	r24, r30
    1e44:	9f 1f       	adc	r25, r31
    1e46:	fc 01       	movw	r30, r24
    1e48:	e6 54       	subi	r30, 0x46	; 70
    1e4a:	f6 4f       	sbci	r31, 0xF6	; 246
    1e4c:	80 81       	ld	r24, Z
    1e4e:	81 11       	cpse	r24, r1
    1e50:	17 c0       	rjmp	.+46     	; 0x1e80 <vTaskSwitchContext+0x66>
    1e52:	80 91 ae 09 	lds	r24, 0x09AE
    1e56:	81 50       	subi	r24, 0x01	; 1
    1e58:	80 93 ae 09 	sts	0x09AE, r24
    1e5c:	80 91 ae 09 	lds	r24, 0x09AE
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	fc 01       	movw	r30, r24
    1e64:	ee 0f       	add	r30, r30
    1e66:	ff 1f       	adc	r31, r31
    1e68:	ee 0f       	add	r30, r30
    1e6a:	ff 1f       	adc	r31, r31
    1e6c:	ee 0f       	add	r30, r30
    1e6e:	ff 1f       	adc	r31, r31
    1e70:	8e 0f       	add	r24, r30
    1e72:	9f 1f       	adc	r25, r31
    1e74:	fc 01       	movw	r30, r24
    1e76:	e6 54       	subi	r30, 0x46	; 70
    1e78:	f6 4f       	sbci	r31, 0xF6	; 246
    1e7a:	80 81       	ld	r24, Z
    1e7c:	88 23       	and	r24, r24
    1e7e:	49 f3       	breq	.-46     	; 0x1e52 <vTaskSwitchContext+0x38>
    1e80:	e0 91 ae 09 	lds	r30, 0x09AE
    1e84:	f0 e0       	ldi	r31, 0x00	; 0
    1e86:	cf 01       	movw	r24, r30
    1e88:	88 0f       	add	r24, r24
    1e8a:	99 1f       	adc	r25, r25
    1e8c:	88 0f       	add	r24, r24
    1e8e:	99 1f       	adc	r25, r25
    1e90:	88 0f       	add	r24, r24
    1e92:	99 1f       	adc	r25, r25
    1e94:	e8 0f       	add	r30, r24
    1e96:	f9 1f       	adc	r31, r25
    1e98:	e6 54       	subi	r30, 0x46	; 70
    1e9a:	f6 4f       	sbci	r31, 0xF6	; 246
    1e9c:	a1 81       	ldd	r26, Z+1	; 0x01
    1e9e:	b2 81       	ldd	r27, Z+2	; 0x02
    1ea0:	12 96       	adiw	r26, 0x02	; 2
    1ea2:	0d 90       	ld	r0, X+
    1ea4:	bc 91       	ld	r27, X
    1ea6:	a0 2d       	mov	r26, r0
    1ea8:	b2 83       	std	Z+2, r27	; 0x02
    1eaa:	a1 83       	std	Z+1, r26	; 0x01
    1eac:	cf 01       	movw	r24, r30
    1eae:	03 96       	adiw	r24, 0x03	; 3
    1eb0:	a8 17       	cp	r26, r24
    1eb2:	b9 07       	cpc	r27, r25
    1eb4:	31 f4       	brne	.+12     	; 0x1ec2 <vTaskSwitchContext+0xa8>
    1eb6:	12 96       	adiw	r26, 0x02	; 2
    1eb8:	8d 91       	ld	r24, X+
    1eba:	9c 91       	ld	r25, X
    1ebc:	13 97       	sbiw	r26, 0x03	; 3
    1ebe:	92 83       	std	Z+2, r25	; 0x02
    1ec0:	81 83       	std	Z+1, r24	; 0x01
    1ec2:	01 80       	ldd	r0, Z+1	; 0x01
    1ec4:	f2 81       	ldd	r31, Z+2	; 0x02
    1ec6:	e0 2d       	mov	r30, r0
    1ec8:	86 81       	ldd	r24, Z+6	; 0x06
    1eca:	97 81       	ldd	r25, Z+7	; 0x07
    1ecc:	90 93 b8 09 	sts	0x09B8, r25
    1ed0:	80 93 b7 09 	sts	0x09B7, r24
    1ed4:	08 95       	ret

00001ed6 <_ZN10UltrasonicC1Eii>:
 */

#include "Ultrasonic.h"
#include "delay.h"

Ultrasonic::Ultrasonic(int tp, int ep)
    1ed6:	ef 92       	push	r14
    1ed8:	ff 92       	push	r15
    1eda:	0f 93       	push	r16
    1edc:	1f 93       	push	r17
    1ede:	cf 93       	push	r28
    1ee0:	df 93       	push	r29
    1ee2:	ec 01       	movw	r28, r24
    1ee4:	06 2f       	mov	r16, r22
    1ee6:	e7 2e       	mov	r14, r23
    1ee8:	14 2f       	mov	r17, r20
    1eea:	f5 2e       	mov	r15, r21
    {
    pinMode(tp, OUTPUT);
    1eec:	61 e0       	ldi	r22, 0x01	; 1
    1eee:	80 2f       	mov	r24, r16
    1ef0:	0e 94 35 19 	call	0x326a	; 0x326a <pinMode>
    pinMode(ep, INPUT);
    1ef4:	60 e0       	ldi	r22, 0x00	; 0
    1ef6:	81 2f       	mov	r24, r17
    1ef8:	0e 94 35 19 	call	0x326a	; 0x326a <pinMode>
    _trigPin = tp;
    1efc:	08 83       	st	Y, r16
    1efe:	e9 82       	std	Y+1, r14	; 0x01
    _EchoPin = ep;
    1f00:	1a 83       	std	Y+2, r17	; 0x02
    1f02:	fb 82       	std	Y+3, r15	; 0x03
    //_cmDivisor = 27.6233;
	_cmDivisor = 19; //calibrated for freertos
    1f04:	40 e0       	ldi	r20, 0x00	; 0
    1f06:	50 e0       	ldi	r21, 0x00	; 0
    1f08:	68 e9       	ldi	r22, 0x98	; 152
    1f0a:	71 e4       	ldi	r23, 0x41	; 65
    1f0c:	4c 83       	std	Y+4, r20	; 0x04
    1f0e:	5d 83       	std	Y+5, r21	; 0x05
    1f10:	6e 83       	std	Y+6, r22	; 0x06
    1f12:	7f 83       	std	Y+7, r23	; 0x07
    _inDivisor = 70.1633;
    1f14:	4c e9       	ldi	r20, 0x9C	; 156
    1f16:	53 e5       	ldi	r21, 0x53	; 83
    1f18:	6c e8       	ldi	r22, 0x8C	; 140
    1f1a:	72 e4       	ldi	r23, 0x42	; 66
    1f1c:	48 87       	std	Y+8, r20	; 0x08
    1f1e:	59 87       	std	Y+9, r21	; 0x09
    1f20:	6a 87       	std	Y+10, r22	; 0x0a
    1f22:	7b 87       	std	Y+11, r23	; 0x0b
    }
    1f24:	df 91       	pop	r29
    1f26:	cf 91       	pop	r28
    1f28:	1f 91       	pop	r17
    1f2a:	0f 91       	pop	r16
    1f2c:	ff 90       	pop	r15
    1f2e:	ef 90       	pop	r14
    1f30:	08 95       	ret

00001f32 <_ZN10Ultrasonic6timingEv>:

long Ultrasonic::timing()
    {
    1f32:	cf 93       	push	r28
    1f34:	df 93       	push	r29
    1f36:	ec 01       	movw	r28, r24
    digitalWrite(_trigPin, LOW);
    1f38:	60 e0       	ldi	r22, 0x00	; 0
    1f3a:	88 81       	ld	r24, Y
    1f3c:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    delayMicroseconds(2);
    1f40:	82 e0       	ldi	r24, 0x02	; 2
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	0e 94 21 18 	call	0x3042	; 0x3042 <delayMicroseconds>
    digitalWrite(_trigPin, HIGH);
    1f48:	61 e0       	ldi	r22, 0x01	; 1
    1f4a:	88 81       	ld	r24, Y
    1f4c:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    delayMicroseconds(10);
    1f50:	8a e0       	ldi	r24, 0x0A	; 10
    1f52:	90 e0       	ldi	r25, 0x00	; 0
    1f54:	0e 94 21 18 	call	0x3042	; 0x3042 <delayMicroseconds>
    digitalWrite(_trigPin, LOW);
    1f58:	60 e0       	ldi	r22, 0x00	; 0
    1f5a:	88 81       	ld	r24, Y
    1f5c:	0e 94 77 19 	call	0x32ee	; 0x32ee <digitalWrite>
    return pulseIn(_EchoPin, HIGH);
    1f60:	20 e4       	ldi	r18, 0x40	; 64
    1f62:	32 e4       	ldi	r19, 0x42	; 66
    1f64:	4f e0       	ldi	r20, 0x0F	; 15
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	61 e0       	ldi	r22, 0x01	; 1
    1f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f6c:	0e 94 a9 19 	call	0x3352	; 0x3352 <pulseIn>
    }
    1f70:	df 91       	pop	r29
    1f72:	cf 91       	pop	r28
    1f74:	08 95       	ret

00001f76 <_ZN10Ultrasonic12CalcDistanceEli>:

float Ultrasonic::CalcDistance(long microsec, int metric)
    {
    1f76:	cf 93       	push	r28
    1f78:	df 93       	push	r29
    1f7a:	ec 01       	movw	r28, r24
    // microsec / 29 / 2;
    if(metric) return microsec / _cmDivisor / 2.0;  // CM
    1f7c:	23 2b       	or	r18, r19
    1f7e:	71 f0       	breq	.+28     	; 0x1f9c <_ZN10Ultrasonic12CalcDistanceEli+0x26>
    1f80:	cb 01       	movw	r24, r22
    1f82:	ba 01       	movw	r22, r20
    1f84:	94 d1       	rcall	.+808    	; 0x22ae <__floatsisf>
    1f86:	2c 81       	ldd	r18, Y+4	; 0x04
    1f88:	3d 81       	ldd	r19, Y+5	; 0x05
    1f8a:	4e 81       	ldd	r20, Y+6	; 0x06
    1f8c:	5f 81       	ldd	r21, Y+7	; 0x07
    1f8e:	25 d1       	rcall	.+586    	; 0x21da <__divsf3>
    1f90:	20 e0       	ldi	r18, 0x00	; 0
    1f92:	30 e0       	ldi	r19, 0x00	; 0
    1f94:	40 e0       	ldi	r20, 0x00	; 0
    1f96:	5f e3       	ldi	r21, 0x3F	; 63
    1f98:	3e d2       	rcall	.+1148   	; 0x2416 <__mulsf3>
    1f9a:	0d c0       	rjmp	.+26     	; 0x1fb6 <_ZN10Ultrasonic12CalcDistanceEli+0x40>
    // microsec / 74 / 2;
    else return microsec / _inDivisor / 2.0;  // IN
    1f9c:	cb 01       	movw	r24, r22
    1f9e:	ba 01       	movw	r22, r20
    1fa0:	86 d1       	rcall	.+780    	; 0x22ae <__floatsisf>
    1fa2:	28 85       	ldd	r18, Y+8	; 0x08
    1fa4:	39 85       	ldd	r19, Y+9	; 0x09
    1fa6:	4a 85       	ldd	r20, Y+10	; 0x0a
    1fa8:	5b 85       	ldd	r21, Y+11	; 0x0b
    1faa:	17 d1       	rcall	.+558    	; 0x21da <__divsf3>
    1fac:	20 e0       	ldi	r18, 0x00	; 0
    1fae:	30 e0       	ldi	r19, 0x00	; 0
    1fb0:	40 e0       	ldi	r20, 0x00	; 0
    1fb2:	5f e3       	ldi	r21, 0x3F	; 63
    1fb4:	30 d2       	rcall	.+1120   	; 0x2416 <__mulsf3>
    }
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	08 95       	ret

00001fbc <_ZN4XBee6escapeEPhiS0_>:
    escapedLen = escape(buf, len+9, outBuff);

    return escapedLen;
}

int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    1fbc:	0f 93       	push	r16
    1fbe:	1f 93       	push	r17
    1fc0:	cf 93       	push	r28
    1fc2:	df 93       	push	r29
    int pos = 1;

    output[0] = input[0];
    1fc4:	eb 01       	movw	r28, r22
    1fc6:	88 81       	ld	r24, Y
    1fc8:	f9 01       	movw	r30, r18
    1fca:	80 83       	st	Z, r24
    for (int i=1; i<inLen; i++){
    1fcc:	42 30       	cpi	r20, 0x02	; 2
    1fce:	51 05       	cpc	r21, r1
    1fd0:	54 f1       	brlt	.+84     	; 0x2026 <_ZN4XBee6escapeEPhiS0_+0x6a>
    escapedLen = escape(buf, len+9, outBuff);

    return escapedLen;
}

int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    1fd2:	fb 01       	movw	r30, r22
    1fd4:	31 96       	adiw	r30, 0x01	; 1
    1fd6:	46 0f       	add	r20, r22
    1fd8:	57 1f       	adc	r21, r23
    int pos = 1;
    1fda:	a1 e0       	ldi	r26, 0x01	; 1
    1fdc:	b0 e0       	ldi	r27, 0x00	; 0
        switch(input[i]){
            case 0x7D:
            case 0x7E:
            case 0x11:
            case 0x13:
                output[pos++] = 0x7D;
    1fde:	0d e7       	ldi	r16, 0x7D	; 125
                output[pos++] = input[i] ^ 0x20;
    1fe0:	10 e2       	ldi	r17, 0x20	; 32
    escapedLen = escape(buf, len+9, outBuff);

    return escapedLen;
}

int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    1fe2:	cf 01       	movw	r24, r30
    int pos = 1;

    output[0] = input[0];
    for (int i=1; i<inLen; i++){
        switch(input[i]){
    1fe4:	60 81       	ld	r22, Z
    1fe6:	63 31       	cpi	r22, 0x13	; 19
    1fe8:	41 f0       	breq	.+16     	; 0x1ffa <_ZN4XBee6escapeEPhiS0_+0x3e>
    1fea:	18 f4       	brcc	.+6      	; 0x1ff2 <_ZN4XBee6escapeEPhiS0_+0x36>
    1fec:	61 31       	cpi	r22, 0x11	; 17
    1fee:	89 f4       	brne	.+34     	; 0x2012 <_ZN4XBee6escapeEPhiS0_+0x56>
    1ff0:	04 c0       	rjmp	.+8      	; 0x1ffa <_ZN4XBee6escapeEPhiS0_+0x3e>
    1ff2:	76 2f       	mov	r23, r22
    1ff4:	7d 57       	subi	r23, 0x7D	; 125
    1ff6:	72 30       	cpi	r23, 0x02	; 2
    1ff8:	60 f4       	brcc	.+24     	; 0x2012 <_ZN4XBee6escapeEPhiS0_+0x56>
            case 0x7D:
            case 0x7E:
            case 0x11:
            case 0x13:
                output[pos++] = 0x7D;
    1ffa:	b9 01       	movw	r22, r18
    1ffc:	6a 0f       	add	r22, r26
    1ffe:	7b 1f       	adc	r23, r27
    2000:	eb 01       	movw	r28, r22
    2002:	08 83       	st	Y, r16
                output[pos++] = input[i] ^ 0x20;
    2004:	ec 01       	movw	r28, r24
    2006:	88 81       	ld	r24, Y
    2008:	81 27       	eor	r24, r17
    200a:	eb 01       	movw	r28, r22
    200c:	89 83       	std	Y+1, r24	; 0x01
    200e:	12 96       	adiw	r26, 0x02	; 2
                break;
    2010:	05 c0       	rjmp	.+10     	; 0x201c <_ZN4XBee6escapeEPhiS0_+0x60>
            default:
                output[pos++] = input[i];
    2012:	e9 01       	movw	r28, r18
    2014:	ca 0f       	add	r28, r26
    2016:	db 1f       	adc	r29, r27
    2018:	68 83       	st	Y, r22
    201a:	11 96       	adiw	r26, 0x01	; 1
    201c:	31 96       	adiw	r30, 0x01	; 1

int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;

    output[0] = input[0];
    for (int i=1; i<inLen; i++){
    201e:	e4 17       	cp	r30, r20
    2020:	f5 07       	cpc	r31, r21
    2022:	f9 f6       	brne	.-66     	; 0x1fe2 <_ZN4XBee6escapeEPhiS0_+0x26>
    2024:	02 c0       	rjmp	.+4      	; 0x202a <_ZN4XBee6escapeEPhiS0_+0x6e>

    return escapedLen;
}

int XBee::escape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;
    2026:	a1 e0       	ldi	r26, 0x01	; 1
    2028:	b0 e0       	ldi	r27, 0x00	; 0
                break;
      }
   }

   return pos;
}
    202a:	8a 2f       	mov	r24, r26
    202c:	9b 2f       	mov	r25, r27
    202e:	df 91       	pop	r29
    2030:	cf 91       	pop	r28
    2032:	1f 91       	pop	r17
    2034:	0f 91       	pop	r16
    2036:	08 95       	ret

00002038 <_ZN4XBee4SendEPhiS0_i>:

    return LSB+4;
}


int XBee::Send(unsigned char *msg, int len, unsigned char *outBuff, int addr){
    2038:	af 92       	push	r10
    203a:	bf 92       	push	r11
    203c:	cf 92       	push	r12
    203e:	df 92       	push	r13
    2040:	ef 92       	push	r14
    2042:	ff 92       	push	r15
    2044:	0f 93       	push	r16
    2046:	1f 93       	push	r17
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
    2050:	c4 56       	subi	r28, 0x64	; 100
    2052:	d1 09       	sbc	r29, r1
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	6c 01       	movw	r12, r24
    2060:	7a 01       	movw	r14, r20
    2062:	59 01       	movw	r10, r18
    unsigned char buf[100];
    int escapedLen = 0;
    unsigned char checksum = 0;

    buf[0] = 0x7E;
    2064:	8e e7       	ldi	r24, 0x7E	; 126
    2066:	89 83       	std	Y+1, r24	; 0x01
    buf[1] = 0x00;
    2068:	1a 82       	std	Y+2, r1	; 0x02
    // LSB = content + 5 (API type + frameid + addr(2) + options)
    buf[2] = (unsigned char)(len + 5);
    206a:	84 2f       	mov	r24, r20
    206c:	8b 5f       	subi	r24, 0xFB	; 251
    206e:	8b 83       	std	Y+3, r24	; 0x03
    buf[3] = 0x01;  // transmit request
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	8c 83       	std	Y+4, r24	; 0x04
    buf[4] = 0x00;  // Frame ID
    2074:	1d 82       	std	Y+5, r1	; 0x05
    buf[5] = (unsigned char)((addr & 0xFF00) >> 8);
    2076:	1e 83       	std	Y+6, r17	; 0x06
    buf[6] = (unsigned char)(addr & 0xFF);
    2078:	0f 83       	std	Y+7, r16	; 0x07
    buf[7] = 0x01;  // Disable acknowledge
    207a:	88 87       	std	Y+8, r24	; 0x08
    memcpy(&buf[8], msg, len);
    207c:	9e 01       	movw	r18, r28
    207e:	27 5f       	subi	r18, 0xF7	; 247
    2080:	3f 4f       	sbci	r19, 0xFF	; 255
    2082:	5f 2d       	mov	r21, r15
    2084:	82 2f       	mov	r24, r18
    2086:	93 2f       	mov	r25, r19
    2088:	0e 94 e7 1a 	call	0x35ce	; 0x35ce <memcpy>

    for (int i=3;i<len+8;i++){
    208c:	c7 01       	movw	r24, r14
    208e:	08 96       	adiw	r24, 0x08	; 8
    2090:	84 30       	cpi	r24, 0x04	; 4
    2092:	91 05       	cpc	r25, r1
    2094:	7c f0       	brlt	.+30     	; 0x20b4 <_ZN4XBee4SendEPhiS0_i+0x7c>
    2096:	fe 01       	movw	r30, r28
    2098:	34 96       	adiw	r30, 0x04	; 4

    return LSB+4;
}


int XBee::Send(unsigned char *msg, int len, unsigned char *outBuff, int addr){
    209a:	69 e0       	ldi	r22, 0x09	; 9
    209c:	70 e0       	ldi	r23, 0x00	; 0
    209e:	6c 0f       	add	r22, r28
    20a0:	7d 1f       	adc	r23, r29
    20a2:	6e 0d       	add	r22, r14
    20a4:	7f 1d       	adc	r23, r15
    unsigned char buf[100];
    int escapedLen = 0;
    unsigned char checksum = 0;
    20a6:	20 e0       	ldi	r18, 0x00	; 0
    buf[6] = (unsigned char)(addr & 0xFF);
    buf[7] = 0x01;  // Disable acknowledge
    memcpy(&buf[8], msg, len);

    for (int i=3;i<len+8;i++){
        checksum += buf[i];
    20a8:	31 91       	ld	r19, Z+
    20aa:	23 0f       	add	r18, r19
    buf[5] = (unsigned char)((addr & 0xFF00) >> 8);
    buf[6] = (unsigned char)(addr & 0xFF);
    buf[7] = 0x01;  // Disable acknowledge
    memcpy(&buf[8], msg, len);

    for (int i=3;i<len+8;i++){
    20ac:	e6 17       	cp	r30, r22
    20ae:	f7 07       	cpc	r31, r23
    20b0:	d9 f7       	brne	.-10     	; 0x20a8 <_ZN4XBee4SendEPhiS0_i+0x70>
    20b2:	01 c0       	rjmp	.+2      	; 0x20b6 <_ZN4XBee4SendEPhiS0_i+0x7e>


int XBee::Send(unsigned char *msg, int len, unsigned char *outBuff, int addr){
    unsigned char buf[100];
    int escapedLen = 0;
    unsigned char checksum = 0;
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    for (int i=3;i<len+8;i++){
        checksum += buf[i];
    }

    // Total length = LSB + 9 (LSB value + MSB + LSB + start delimeter + checksum)
    buf[len+8] = 0xFF - checksum;
    20b6:	e1 e0       	ldi	r30, 0x01	; 1
    20b8:	f0 e0       	ldi	r31, 0x00	; 0
    20ba:	ec 0f       	add	r30, r28
    20bc:	fd 1f       	adc	r31, r29
    20be:	e8 0f       	add	r30, r24
    20c0:	f9 1f       	adc	r31, r25
    20c2:	20 95       	com	r18
    20c4:	20 83       	st	Z, r18
    escapedLen = escape(buf, len+9, outBuff);
    20c6:	a7 01       	movw	r20, r14
    20c8:	47 5f       	subi	r20, 0xF7	; 247
    20ca:	5f 4f       	sbci	r21, 0xFF	; 255
    20cc:	95 01       	movw	r18, r10
    20ce:	be 01       	movw	r22, r28
    20d0:	6f 5f       	subi	r22, 0xFF	; 255
    20d2:	7f 4f       	sbci	r23, 0xFF	; 255
    20d4:	c6 01       	movw	r24, r12
    20d6:	72 df       	rcall	.-284    	; 0x1fbc <_ZN4XBee6escapeEPhiS0_>

    return escapedLen;
}
    20d8:	cc 59       	subi	r28, 0x9C	; 156
    20da:	df 4f       	sbci	r29, 0xFF	; 255
    20dc:	0f b6       	in	r0, 0x3f	; 63
    20de:	f8 94       	cli
    20e0:	de bf       	out	0x3e, r29	; 62
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	cd bf       	out	0x3d, r28	; 61
    20e6:	df 91       	pop	r29
    20e8:	cf 91       	pop	r28
    20ea:	1f 91       	pop	r17
    20ec:	0f 91       	pop	r16
    20ee:	ff 90       	pop	r15
    20f0:	ef 90       	pop	r14
    20f2:	df 90       	pop	r13
    20f4:	cf 90       	pop	r12
    20f6:	bf 90       	pop	r11
    20f8:	af 90       	pop	r10
    20fa:	08 95       	ret

000020fc <_ZN4XBee8unescapeEPhiS0_>:
   }

   return pos;
}

int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    20fc:	1f 93       	push	r17
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
    int pos = 1;
    bool skip = false;
    unsigned char curr = 0;

    output[0] = input[0];
    2102:	fb 01       	movw	r30, r22
    2104:	80 81       	ld	r24, Z
    2106:	f9 01       	movw	r30, r18
    2108:	80 83       	st	Z, r24
    for (int i=1; i<inLen; i++) {
    210a:	42 30       	cpi	r20, 0x02	; 2
    210c:	51 05       	cpc	r21, r1
    210e:	14 f1       	brlt	.+68     	; 0x2154 <_ZN4XBee8unescapeEPhiS0_+0x58>
   }

   return pos;
}

int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    2110:	fb 01       	movw	r30, r22
    2112:	32 96       	adiw	r30, 0x02	; 2
    2114:	6f 5f       	subi	r22, 0xFF	; 255
    2116:	7f 4f       	sbci	r23, 0xFF	; 255
    2118:	46 0f       	add	r20, r22
    211a:	57 1f       	adc	r21, r23
    int pos = 1;
    bool skip = false;
    211c:	80 e0       	ldi	r24, 0x00	; 0

   return pos;
}

int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;
    211e:	a1 e0       	ldi	r26, 0x01	; 1
    2120:	b0 e0       	ldi	r27, 0x00	; 0
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i<inLen; i++) {
        if (skip){
            skip = false;
    2122:	60 e0       	ldi	r22, 0x00	; 0
            continue;
        }

        if (input[i] == 0x7D){
            curr = input[i+1] ^ 0x20;
    2124:	10 e2       	ldi	r17, 0x20	; 32
            skip = true;
    2126:	71 e0       	ldi	r23, 0x01	; 1
    bool skip = false;
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i<inLen; i++) {
        if (skip){
    2128:	81 11       	cpse	r24, r1
    212a:	0e c0       	rjmp	.+28     	; 0x2148 <_ZN4XBee8unescapeEPhiS0_+0x4c>
   }

   return pos;
}

int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    212c:	ef 01       	movw	r28, r30
    212e:	21 97       	sbiw	r28, 0x01	; 1
        if (skip){
            skip = false;
            continue;
        }

        if (input[i] == 0x7D){
    2130:	98 81       	ld	r25, Y
    2132:	9d 37       	cpi	r25, 0x7D	; 125
    2134:	19 f4       	brne	.+6      	; 0x213c <_ZN4XBee8unescapeEPhiS0_+0x40>
            curr = input[i+1] ^ 0x20;
    2136:	90 81       	ld	r25, Z
    2138:	91 27       	eor	r25, r17
            skip = true;
    213a:	87 2f       	mov	r24, r23
        }else{
            curr = input[i];
        }

        output[pos] = curr;
    213c:	e9 01       	movw	r28, r18
    213e:	ca 0f       	add	r28, r26
    2140:	db 1f       	adc	r29, r27
    2142:	98 83       	st	Y, r25
        pos++;
    2144:	11 96       	adiw	r26, 0x01	; 1
    2146:	01 c0       	rjmp	.+2      	; 0x214a <_ZN4XBee8unescapeEPhiS0_+0x4e>
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i<inLen; i++) {
        if (skip){
            skip = false;
    2148:	86 2f       	mov	r24, r22
    214a:	31 96       	adiw	r30, 0x01	; 1
    int pos = 1;
    bool skip = false;
    unsigned char curr = 0;

    output[0] = input[0];
    for (int i=1; i<inLen; i++) {
    214c:	e4 17       	cp	r30, r20
    214e:	f5 07       	cpc	r31, r21
    2150:	59 f7       	brne	.-42     	; 0x2128 <_ZN4XBee8unescapeEPhiS0_+0x2c>
    2152:	02 c0       	rjmp	.+4      	; 0x2158 <_ZN4XBee8unescapeEPhiS0_+0x5c>

   return pos;
}

int XBee::unescape(unsigned char *input, int inLen, unsigned char *output){
    int pos = 1;
    2154:	a1 e0       	ldi	r26, 0x01	; 1
    2156:	b0 e0       	ldi	r27, 0x00	; 0
        output[pos] = curr;
        pos++;
    }

    return pos;
}
    2158:	8a 2f       	mov	r24, r26
    215a:	9b 2f       	mov	r25, r27
    215c:	df 91       	pop	r29
    215e:	cf 91       	pop	r28
    2160:	1f 91       	pop	r17
    2162:	08 95       	ret

00002164 <_ZN4XBee7ReceiveEPhiS0_>:
#include "XBee.h"
#include "String.h"

int XBee::Receive(unsigned char *inBuff, int len, unsigned char *outBuff){
    2164:	cf 93       	push	r28
    2166:	df 93       	push	r29
    2168:	e9 01       	movw	r28, r18
    int unescapeLen = 0;
    unsigned char checksum = 0;
    unsigned char LSB = 0;

    if (inBuff[0] != 0x7E)
    216a:	fb 01       	movw	r30, r22
    216c:	20 81       	ld	r18, Z
    216e:	2e 37       	cpi	r18, 0x7E	; 126
    2170:	01 f5       	brne	.+64     	; 0x21b2 <_ZN4XBee7ReceiveEPhiS0_+0x4e>
        return 0;

    if (len < 10)
    2172:	4a 30       	cpi	r20, 0x0A	; 10
    2174:	51 05       	cpc	r21, r1
    2176:	04 f1       	brlt	.+64     	; 0x21b8 <_ZN4XBee7ReceiveEPhiS0_+0x54>
        return 0;

    unescapeLen = unescape(inBuff, len, outBuff);
    2178:	9e 01       	movw	r18, r28
    217a:	c0 df       	rcall	.-128    	; 0x20fc <_ZN4XBee8unescapeEPhiS0_>

    // Check we have at least the amount of bytes indicated by LSB
    LSB = outBuff[2]; 
    if (LSB > (unescapeLen - 4))
    217c:	4a 81       	ldd	r20, Y+2	; 0x02
    217e:	50 e0       	ldi	r21, 0x00	; 0
    2180:	04 97       	sbiw	r24, 0x04	; 4
    2182:	84 17       	cp	r24, r20
    2184:	95 07       	cpc	r25, r21
    2186:	dc f0       	brlt	.+54     	; 0x21be <_ZN4XBee7ReceiveEPhiS0_+0x5a>
        return 0;

    // Calculate our checksum
    // (char will overflow, no need to AND for lower bytes)
    for (int i=3; i<LSB+4; i++){
    2188:	4c 5f       	subi	r20, 0xFC	; 252
    218a:	5f 4f       	sbci	r21, 0xFF	; 255
    218c:	44 30       	cpi	r20, 0x04	; 4
    218e:	51 05       	cpc	r21, r1
    2190:	cc f0       	brlt	.+50     	; 0x21c4 <_ZN4XBee7ReceiveEPhiS0_+0x60>
#include "XBee.h"
#include "String.h"

int XBee::Receive(unsigned char *inBuff, int len, unsigned char *outBuff){
    2192:	fe 01       	movw	r30, r28
    2194:	33 96       	adiw	r30, 0x03	; 3
    2196:	83 e0       	ldi	r24, 0x03	; 3
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	20 e0       	ldi	r18, 0x00	; 0
        return 0;

    // Calculate our checksum
    // (char will overflow, no need to AND for lower bytes)
    for (int i=3; i<LSB+4; i++){
        checksum += outBuff[i];
    219c:	31 91       	ld	r19, Z+
    219e:	23 0f       	add	r18, r19
    if (LSB > (unescapeLen - 4))
        return 0;

    // Calculate our checksum
    // (char will overflow, no need to AND for lower bytes)
    for (int i=3; i<LSB+4; i++){
    21a0:	01 96       	adiw	r24, 0x01	; 1
    21a2:	84 17       	cp	r24, r20
    21a4:	95 07       	cpc	r25, r21
    21a6:	d4 f3       	brlt	.-12     	; 0x219c <_ZN4XBee7ReceiveEPhiS0_+0x38>
        checksum += outBuff[i];
    }

    if (checksum != 0xFF)
    21a8:	2f 3f       	cpi	r18, 0xFF	; 255
    21aa:	71 f0       	breq	.+28     	; 0x21c8 <_ZN4XBee7ReceiveEPhiS0_+0x64>
        return 0;
    21ac:	40 e0       	ldi	r20, 0x00	; 0
    21ae:	50 e0       	ldi	r21, 0x00	; 0
    21b0:	0b c0       	rjmp	.+22     	; 0x21c8 <_ZN4XBee7ReceiveEPhiS0_+0x64>
    int unescapeLen = 0;
    unsigned char checksum = 0;
    unsigned char LSB = 0;

    if (inBuff[0] != 0x7E)
        return 0;
    21b2:	40 e0       	ldi	r20, 0x00	; 0
    21b4:	50 e0       	ldi	r21, 0x00	; 0
    21b6:	08 c0       	rjmp	.+16     	; 0x21c8 <_ZN4XBee7ReceiveEPhiS0_+0x64>

    if (len < 10)
        return 0;
    21b8:	40 e0       	ldi	r20, 0x00	; 0
    21ba:	50 e0       	ldi	r21, 0x00	; 0
    21bc:	05 c0       	rjmp	.+10     	; 0x21c8 <_ZN4XBee7ReceiveEPhiS0_+0x64>
    unescapeLen = unescape(inBuff, len, outBuff);

    // Check we have at least the amount of bytes indicated by LSB
    LSB = outBuff[2]; 
    if (LSB > (unescapeLen - 4))
        return 0;
    21be:	40 e0       	ldi	r20, 0x00	; 0
    21c0:	50 e0       	ldi	r21, 0x00	; 0
    21c2:	02 c0       	rjmp	.+4      	; 0x21c8 <_ZN4XBee7ReceiveEPhiS0_+0x64>
    for (int i=3; i<LSB+4; i++){
        checksum += outBuff[i];
    }

    if (checksum != 0xFF)
        return 0;
    21c4:	40 e0       	ldi	r20, 0x00	; 0
    21c6:	50 e0       	ldi	r21, 0x00	; 0

    return LSB+4;
}
    21c8:	84 2f       	mov	r24, r20
    21ca:	95 2f       	mov	r25, r21
    21cc:	df 91       	pop	r29
    21ce:	cf 91       	pop	r28
    21d0:	08 95       	ret

000021d2 <__cmpsf2>:
    21d2:	a8 d0       	rcall	.+336    	; 0x2324 <__fp_cmp>
    21d4:	08 f4       	brcc	.+2      	; 0x21d8 <__cmpsf2+0x6>
    21d6:	81 e0       	ldi	r24, 0x01	; 1
    21d8:	08 95       	ret

000021da <__divsf3>:
    21da:	0c d0       	rcall	.+24     	; 0x21f4 <__divsf3x>
    21dc:	de c0       	rjmp	.+444    	; 0x239a <__fp_round>
    21de:	d6 d0       	rcall	.+428    	; 0x238c <__fp_pscB>
    21e0:	40 f0       	brcs	.+16     	; 0x21f2 <__divsf3+0x18>
    21e2:	cd d0       	rcall	.+410    	; 0x237e <__fp_pscA>
    21e4:	30 f0       	brcs	.+12     	; 0x21f2 <__divsf3+0x18>
    21e6:	21 f4       	brne	.+8      	; 0x21f0 <__divsf3+0x16>
    21e8:	5f 3f       	cpi	r21, 0xFF	; 255
    21ea:	19 f0       	breq	.+6      	; 0x21f2 <__divsf3+0x18>
    21ec:	bf c0       	rjmp	.+382    	; 0x236c <__fp_inf>
    21ee:	51 11       	cpse	r21, r1
    21f0:	08 c1       	rjmp	.+528    	; 0x2402 <__fp_szero>
    21f2:	c2 c0       	rjmp	.+388    	; 0x2378 <__fp_nan>

000021f4 <__divsf3x>:
    21f4:	e3 d0       	rcall	.+454    	; 0x23bc <__fp_split3>
    21f6:	98 f3       	brcs	.-26     	; 0x21de <__divsf3+0x4>

000021f8 <__divsf3_pse>:
    21f8:	99 23       	and	r25, r25
    21fa:	c9 f3       	breq	.-14     	; 0x21ee <__divsf3+0x14>
    21fc:	55 23       	and	r21, r21
    21fe:	b1 f3       	breq	.-20     	; 0x21ec <__divsf3+0x12>
    2200:	95 1b       	sub	r25, r21
    2202:	55 0b       	sbc	r21, r21
    2204:	bb 27       	eor	r27, r27
    2206:	aa 27       	eor	r26, r26
    2208:	62 17       	cp	r22, r18
    220a:	73 07       	cpc	r23, r19
    220c:	84 07       	cpc	r24, r20
    220e:	38 f0       	brcs	.+14     	; 0x221e <__stack+0x1f>
    2210:	9f 5f       	subi	r25, 0xFF	; 255
    2212:	5f 4f       	sbci	r21, 0xFF	; 255
    2214:	22 0f       	add	r18, r18
    2216:	33 1f       	adc	r19, r19
    2218:	44 1f       	adc	r20, r20
    221a:	aa 1f       	adc	r26, r26
    221c:	a9 f3       	breq	.-22     	; 0x2208 <__stack+0x9>
    221e:	33 d0       	rcall	.+102    	; 0x2286 <__stack+0x87>
    2220:	0e 2e       	mov	r0, r30
    2222:	3a f0       	brmi	.+14     	; 0x2232 <__stack+0x33>
    2224:	e0 e8       	ldi	r30, 0x80	; 128
    2226:	30 d0       	rcall	.+96     	; 0x2288 <__stack+0x89>
    2228:	91 50       	subi	r25, 0x01	; 1
    222a:	50 40       	sbci	r21, 0x00	; 0
    222c:	e6 95       	lsr	r30
    222e:	00 1c       	adc	r0, r0
    2230:	ca f7       	brpl	.-14     	; 0x2224 <__stack+0x25>
    2232:	29 d0       	rcall	.+82     	; 0x2286 <__stack+0x87>
    2234:	fe 2f       	mov	r31, r30
    2236:	27 d0       	rcall	.+78     	; 0x2286 <__stack+0x87>
    2238:	66 0f       	add	r22, r22
    223a:	77 1f       	adc	r23, r23
    223c:	88 1f       	adc	r24, r24
    223e:	bb 1f       	adc	r27, r27
    2240:	26 17       	cp	r18, r22
    2242:	37 07       	cpc	r19, r23
    2244:	48 07       	cpc	r20, r24
    2246:	ab 07       	cpc	r26, r27
    2248:	b0 e8       	ldi	r27, 0x80	; 128
    224a:	09 f0       	breq	.+2      	; 0x224e <__stack+0x4f>
    224c:	bb 0b       	sbc	r27, r27
    224e:	80 2d       	mov	r24, r0
    2250:	bf 01       	movw	r22, r30
    2252:	ff 27       	eor	r31, r31
    2254:	93 58       	subi	r25, 0x83	; 131
    2256:	5f 4f       	sbci	r21, 0xFF	; 255
    2258:	2a f0       	brmi	.+10     	; 0x2264 <__stack+0x65>
    225a:	9e 3f       	cpi	r25, 0xFE	; 254
    225c:	51 05       	cpc	r21, r1
    225e:	68 f0       	brcs	.+26     	; 0x227a <__stack+0x7b>
    2260:	85 c0       	rjmp	.+266    	; 0x236c <__fp_inf>
    2262:	cf c0       	rjmp	.+414    	; 0x2402 <__fp_szero>
    2264:	5f 3f       	cpi	r21, 0xFF	; 255
    2266:	ec f3       	brlt	.-6      	; 0x2262 <__stack+0x63>
    2268:	98 3e       	cpi	r25, 0xE8	; 232
    226a:	dc f3       	brlt	.-10     	; 0x2262 <__stack+0x63>
    226c:	86 95       	lsr	r24
    226e:	77 95       	ror	r23
    2270:	67 95       	ror	r22
    2272:	b7 95       	ror	r27
    2274:	f7 95       	ror	r31
    2276:	9f 5f       	subi	r25, 0xFF	; 255
    2278:	c9 f7       	brne	.-14     	; 0x226c <__stack+0x6d>
    227a:	88 0f       	add	r24, r24
    227c:	91 1d       	adc	r25, r1
    227e:	96 95       	lsr	r25
    2280:	87 95       	ror	r24
    2282:	97 f9       	bld	r25, 7
    2284:	08 95       	ret
    2286:	e1 e0       	ldi	r30, 0x01	; 1
    2288:	66 0f       	add	r22, r22
    228a:	77 1f       	adc	r23, r23
    228c:	88 1f       	adc	r24, r24
    228e:	bb 1f       	adc	r27, r27
    2290:	62 17       	cp	r22, r18
    2292:	73 07       	cpc	r23, r19
    2294:	84 07       	cpc	r24, r20
    2296:	ba 07       	cpc	r27, r26
    2298:	20 f0       	brcs	.+8      	; 0x22a2 <__stack+0xa3>
    229a:	62 1b       	sub	r22, r18
    229c:	73 0b       	sbc	r23, r19
    229e:	84 0b       	sbc	r24, r20
    22a0:	ba 0b       	sbc	r27, r26
    22a2:	ee 1f       	adc	r30, r30
    22a4:	88 f7       	brcc	.-30     	; 0x2288 <__stack+0x89>
    22a6:	e0 95       	com	r30
    22a8:	08 95       	ret

000022aa <__floatunsisf>:
    22aa:	e8 94       	clt
    22ac:	09 c0       	rjmp	.+18     	; 0x22c0 <__floatsisf+0x12>

000022ae <__floatsisf>:
    22ae:	97 fb       	bst	r25, 7
    22b0:	3e f4       	brtc	.+14     	; 0x22c0 <__floatsisf+0x12>
    22b2:	90 95       	com	r25
    22b4:	80 95       	com	r24
    22b6:	70 95       	com	r23
    22b8:	61 95       	neg	r22
    22ba:	7f 4f       	sbci	r23, 0xFF	; 255
    22bc:	8f 4f       	sbci	r24, 0xFF	; 255
    22be:	9f 4f       	sbci	r25, 0xFF	; 255
    22c0:	99 23       	and	r25, r25
    22c2:	a9 f0       	breq	.+42     	; 0x22ee <__floatsisf+0x40>
    22c4:	f9 2f       	mov	r31, r25
    22c6:	96 e9       	ldi	r25, 0x96	; 150
    22c8:	bb 27       	eor	r27, r27
    22ca:	93 95       	inc	r25
    22cc:	f6 95       	lsr	r31
    22ce:	87 95       	ror	r24
    22d0:	77 95       	ror	r23
    22d2:	67 95       	ror	r22
    22d4:	b7 95       	ror	r27
    22d6:	f1 11       	cpse	r31, r1
    22d8:	f8 cf       	rjmp	.-16     	; 0x22ca <__floatsisf+0x1c>
    22da:	fa f4       	brpl	.+62     	; 0x231a <__floatsisf+0x6c>
    22dc:	bb 0f       	add	r27, r27
    22de:	11 f4       	brne	.+4      	; 0x22e4 <__floatsisf+0x36>
    22e0:	60 ff       	sbrs	r22, 0
    22e2:	1b c0       	rjmp	.+54     	; 0x231a <__floatsisf+0x6c>
    22e4:	6f 5f       	subi	r22, 0xFF	; 255
    22e6:	7f 4f       	sbci	r23, 0xFF	; 255
    22e8:	8f 4f       	sbci	r24, 0xFF	; 255
    22ea:	9f 4f       	sbci	r25, 0xFF	; 255
    22ec:	16 c0       	rjmp	.+44     	; 0x231a <__floatsisf+0x6c>
    22ee:	88 23       	and	r24, r24
    22f0:	11 f0       	breq	.+4      	; 0x22f6 <__floatsisf+0x48>
    22f2:	96 e9       	ldi	r25, 0x96	; 150
    22f4:	11 c0       	rjmp	.+34     	; 0x2318 <__floatsisf+0x6a>
    22f6:	77 23       	and	r23, r23
    22f8:	21 f0       	breq	.+8      	; 0x2302 <__floatsisf+0x54>
    22fa:	9e e8       	ldi	r25, 0x8E	; 142
    22fc:	87 2f       	mov	r24, r23
    22fe:	76 2f       	mov	r23, r22
    2300:	05 c0       	rjmp	.+10     	; 0x230c <__floatsisf+0x5e>
    2302:	66 23       	and	r22, r22
    2304:	71 f0       	breq	.+28     	; 0x2322 <__floatsisf+0x74>
    2306:	96 e8       	ldi	r25, 0x86	; 134
    2308:	86 2f       	mov	r24, r22
    230a:	70 e0       	ldi	r23, 0x00	; 0
    230c:	60 e0       	ldi	r22, 0x00	; 0
    230e:	2a f0       	brmi	.+10     	; 0x231a <__floatsisf+0x6c>
    2310:	9a 95       	dec	r25
    2312:	66 0f       	add	r22, r22
    2314:	77 1f       	adc	r23, r23
    2316:	88 1f       	adc	r24, r24
    2318:	da f7       	brpl	.-10     	; 0x2310 <__floatsisf+0x62>
    231a:	88 0f       	add	r24, r24
    231c:	96 95       	lsr	r25
    231e:	87 95       	ror	r24
    2320:	97 f9       	bld	r25, 7
    2322:	08 95       	ret

00002324 <__fp_cmp>:
    2324:	99 0f       	add	r25, r25
    2326:	00 08       	sbc	r0, r0
    2328:	55 0f       	add	r21, r21
    232a:	aa 0b       	sbc	r26, r26
    232c:	e0 e8       	ldi	r30, 0x80	; 128
    232e:	fe ef       	ldi	r31, 0xFE	; 254
    2330:	16 16       	cp	r1, r22
    2332:	17 06       	cpc	r1, r23
    2334:	e8 07       	cpc	r30, r24
    2336:	f9 07       	cpc	r31, r25
    2338:	c0 f0       	brcs	.+48     	; 0x236a <__fp_cmp+0x46>
    233a:	12 16       	cp	r1, r18
    233c:	13 06       	cpc	r1, r19
    233e:	e4 07       	cpc	r30, r20
    2340:	f5 07       	cpc	r31, r21
    2342:	98 f0       	brcs	.+38     	; 0x236a <__fp_cmp+0x46>
    2344:	62 1b       	sub	r22, r18
    2346:	73 0b       	sbc	r23, r19
    2348:	84 0b       	sbc	r24, r20
    234a:	95 0b       	sbc	r25, r21
    234c:	39 f4       	brne	.+14     	; 0x235c <__fp_cmp+0x38>
    234e:	0a 26       	eor	r0, r26
    2350:	61 f0       	breq	.+24     	; 0x236a <__fp_cmp+0x46>
    2352:	23 2b       	or	r18, r19
    2354:	24 2b       	or	r18, r20
    2356:	25 2b       	or	r18, r21
    2358:	21 f4       	brne	.+8      	; 0x2362 <__fp_cmp+0x3e>
    235a:	08 95       	ret
    235c:	0a 26       	eor	r0, r26
    235e:	09 f4       	brne	.+2      	; 0x2362 <__fp_cmp+0x3e>
    2360:	a1 40       	sbci	r26, 0x01	; 1
    2362:	a6 95       	lsr	r26
    2364:	8f ef       	ldi	r24, 0xFF	; 255
    2366:	81 1d       	adc	r24, r1
    2368:	81 1d       	adc	r24, r1
    236a:	08 95       	ret

0000236c <__fp_inf>:
    236c:	97 f9       	bld	r25, 7
    236e:	9f 67       	ori	r25, 0x7F	; 127
    2370:	80 e8       	ldi	r24, 0x80	; 128
    2372:	70 e0       	ldi	r23, 0x00	; 0
    2374:	60 e0       	ldi	r22, 0x00	; 0
    2376:	08 95       	ret

00002378 <__fp_nan>:
    2378:	9f ef       	ldi	r25, 0xFF	; 255
    237a:	80 ec       	ldi	r24, 0xC0	; 192
    237c:	08 95       	ret

0000237e <__fp_pscA>:
    237e:	00 24       	eor	r0, r0
    2380:	0a 94       	dec	r0
    2382:	16 16       	cp	r1, r22
    2384:	17 06       	cpc	r1, r23
    2386:	18 06       	cpc	r1, r24
    2388:	09 06       	cpc	r0, r25
    238a:	08 95       	ret

0000238c <__fp_pscB>:
    238c:	00 24       	eor	r0, r0
    238e:	0a 94       	dec	r0
    2390:	12 16       	cp	r1, r18
    2392:	13 06       	cpc	r1, r19
    2394:	14 06       	cpc	r1, r20
    2396:	05 06       	cpc	r0, r21
    2398:	08 95       	ret

0000239a <__fp_round>:
    239a:	09 2e       	mov	r0, r25
    239c:	03 94       	inc	r0
    239e:	00 0c       	add	r0, r0
    23a0:	11 f4       	brne	.+4      	; 0x23a6 <__fp_round+0xc>
    23a2:	88 23       	and	r24, r24
    23a4:	52 f0       	brmi	.+20     	; 0x23ba <__fp_round+0x20>
    23a6:	bb 0f       	add	r27, r27
    23a8:	40 f4       	brcc	.+16     	; 0x23ba <__fp_round+0x20>
    23aa:	bf 2b       	or	r27, r31
    23ac:	11 f4       	brne	.+4      	; 0x23b2 <__fp_round+0x18>
    23ae:	60 ff       	sbrs	r22, 0
    23b0:	04 c0       	rjmp	.+8      	; 0x23ba <__fp_round+0x20>
    23b2:	6f 5f       	subi	r22, 0xFF	; 255
    23b4:	7f 4f       	sbci	r23, 0xFF	; 255
    23b6:	8f 4f       	sbci	r24, 0xFF	; 255
    23b8:	9f 4f       	sbci	r25, 0xFF	; 255
    23ba:	08 95       	ret

000023bc <__fp_split3>:
    23bc:	57 fd       	sbrc	r21, 7
    23be:	90 58       	subi	r25, 0x80	; 128
    23c0:	44 0f       	add	r20, r20
    23c2:	55 1f       	adc	r21, r21
    23c4:	59 f0       	breq	.+22     	; 0x23dc <__fp_splitA+0x10>
    23c6:	5f 3f       	cpi	r21, 0xFF	; 255
    23c8:	71 f0       	breq	.+28     	; 0x23e6 <__fp_splitA+0x1a>
    23ca:	47 95       	ror	r20

000023cc <__fp_splitA>:
    23cc:	88 0f       	add	r24, r24
    23ce:	97 fb       	bst	r25, 7
    23d0:	99 1f       	adc	r25, r25
    23d2:	61 f0       	breq	.+24     	; 0x23ec <__fp_splitA+0x20>
    23d4:	9f 3f       	cpi	r25, 0xFF	; 255
    23d6:	79 f0       	breq	.+30     	; 0x23f6 <__fp_splitA+0x2a>
    23d8:	87 95       	ror	r24
    23da:	08 95       	ret
    23dc:	12 16       	cp	r1, r18
    23de:	13 06       	cpc	r1, r19
    23e0:	14 06       	cpc	r1, r20
    23e2:	55 1f       	adc	r21, r21
    23e4:	f2 cf       	rjmp	.-28     	; 0x23ca <__fp_split3+0xe>
    23e6:	46 95       	lsr	r20
    23e8:	f1 df       	rcall	.-30     	; 0x23cc <__fp_splitA>
    23ea:	08 c0       	rjmp	.+16     	; 0x23fc <__fp_splitA+0x30>
    23ec:	16 16       	cp	r1, r22
    23ee:	17 06       	cpc	r1, r23
    23f0:	18 06       	cpc	r1, r24
    23f2:	99 1f       	adc	r25, r25
    23f4:	f1 cf       	rjmp	.-30     	; 0x23d8 <__fp_splitA+0xc>
    23f6:	86 95       	lsr	r24
    23f8:	71 05       	cpc	r23, r1
    23fa:	61 05       	cpc	r22, r1
    23fc:	08 94       	sec
    23fe:	08 95       	ret

00002400 <__fp_zero>:
    2400:	e8 94       	clt

00002402 <__fp_szero>:
    2402:	bb 27       	eor	r27, r27
    2404:	66 27       	eor	r22, r22
    2406:	77 27       	eor	r23, r23
    2408:	cb 01       	movw	r24, r22
    240a:	97 f9       	bld	r25, 7
    240c:	08 95       	ret

0000240e <__gesf2>:
    240e:	8a df       	rcall	.-236    	; 0x2324 <__fp_cmp>
    2410:	08 f4       	brcc	.+2      	; 0x2414 <__gesf2+0x6>
    2412:	8f ef       	ldi	r24, 0xFF	; 255
    2414:	08 95       	ret

00002416 <__mulsf3>:
    2416:	0b d0       	rcall	.+22     	; 0x242e <__mulsf3x>
    2418:	c0 cf       	rjmp	.-128    	; 0x239a <__fp_round>
    241a:	b1 df       	rcall	.-158    	; 0x237e <__fp_pscA>
    241c:	28 f0       	brcs	.+10     	; 0x2428 <__mulsf3+0x12>
    241e:	b6 df       	rcall	.-148    	; 0x238c <__fp_pscB>
    2420:	18 f0       	brcs	.+6      	; 0x2428 <__mulsf3+0x12>
    2422:	95 23       	and	r25, r21
    2424:	09 f0       	breq	.+2      	; 0x2428 <__mulsf3+0x12>
    2426:	a2 cf       	rjmp	.-188    	; 0x236c <__fp_inf>
    2428:	a7 cf       	rjmp	.-178    	; 0x2378 <__fp_nan>
    242a:	11 24       	eor	r1, r1
    242c:	ea cf       	rjmp	.-44     	; 0x2402 <__fp_szero>

0000242e <__mulsf3x>:
    242e:	c6 df       	rcall	.-116    	; 0x23bc <__fp_split3>
    2430:	a0 f3       	brcs	.-24     	; 0x241a <__mulsf3+0x4>

00002432 <__mulsf3_pse>:
    2432:	95 9f       	mul	r25, r21
    2434:	d1 f3       	breq	.-12     	; 0x242a <__mulsf3+0x14>
    2436:	95 0f       	add	r25, r21
    2438:	50 e0       	ldi	r21, 0x00	; 0
    243a:	55 1f       	adc	r21, r21
    243c:	62 9f       	mul	r22, r18
    243e:	f0 01       	movw	r30, r0
    2440:	72 9f       	mul	r23, r18
    2442:	bb 27       	eor	r27, r27
    2444:	f0 0d       	add	r31, r0
    2446:	b1 1d       	adc	r27, r1
    2448:	63 9f       	mul	r22, r19
    244a:	aa 27       	eor	r26, r26
    244c:	f0 0d       	add	r31, r0
    244e:	b1 1d       	adc	r27, r1
    2450:	aa 1f       	adc	r26, r26
    2452:	64 9f       	mul	r22, r20
    2454:	66 27       	eor	r22, r22
    2456:	b0 0d       	add	r27, r0
    2458:	a1 1d       	adc	r26, r1
    245a:	66 1f       	adc	r22, r22
    245c:	82 9f       	mul	r24, r18
    245e:	22 27       	eor	r18, r18
    2460:	b0 0d       	add	r27, r0
    2462:	a1 1d       	adc	r26, r1
    2464:	62 1f       	adc	r22, r18
    2466:	73 9f       	mul	r23, r19
    2468:	b0 0d       	add	r27, r0
    246a:	a1 1d       	adc	r26, r1
    246c:	62 1f       	adc	r22, r18
    246e:	83 9f       	mul	r24, r19
    2470:	a0 0d       	add	r26, r0
    2472:	61 1d       	adc	r22, r1
    2474:	22 1f       	adc	r18, r18
    2476:	74 9f       	mul	r23, r20
    2478:	33 27       	eor	r19, r19
    247a:	a0 0d       	add	r26, r0
    247c:	61 1d       	adc	r22, r1
    247e:	23 1f       	adc	r18, r19
    2480:	84 9f       	mul	r24, r20
    2482:	60 0d       	add	r22, r0
    2484:	21 1d       	adc	r18, r1
    2486:	82 2f       	mov	r24, r18
    2488:	76 2f       	mov	r23, r22
    248a:	6a 2f       	mov	r22, r26
    248c:	11 24       	eor	r1, r1
    248e:	9f 57       	subi	r25, 0x7F	; 127
    2490:	50 40       	sbci	r21, 0x00	; 0
    2492:	8a f0       	brmi	.+34     	; 0x24b6 <__mulsf3_pse+0x84>
    2494:	e1 f0       	breq	.+56     	; 0x24ce <__mulsf3_pse+0x9c>
    2496:	88 23       	and	r24, r24
    2498:	4a f0       	brmi	.+18     	; 0x24ac <__mulsf3_pse+0x7a>
    249a:	ee 0f       	add	r30, r30
    249c:	ff 1f       	adc	r31, r31
    249e:	bb 1f       	adc	r27, r27
    24a0:	66 1f       	adc	r22, r22
    24a2:	77 1f       	adc	r23, r23
    24a4:	88 1f       	adc	r24, r24
    24a6:	91 50       	subi	r25, 0x01	; 1
    24a8:	50 40       	sbci	r21, 0x00	; 0
    24aa:	a9 f7       	brne	.-22     	; 0x2496 <__mulsf3_pse+0x64>
    24ac:	9e 3f       	cpi	r25, 0xFE	; 254
    24ae:	51 05       	cpc	r21, r1
    24b0:	70 f0       	brcs	.+28     	; 0x24ce <__mulsf3_pse+0x9c>
    24b2:	5c cf       	rjmp	.-328    	; 0x236c <__fp_inf>
    24b4:	a6 cf       	rjmp	.-180    	; 0x2402 <__fp_szero>
    24b6:	5f 3f       	cpi	r21, 0xFF	; 255
    24b8:	ec f3       	brlt	.-6      	; 0x24b4 <__mulsf3_pse+0x82>
    24ba:	98 3e       	cpi	r25, 0xE8	; 232
    24bc:	dc f3       	brlt	.-10     	; 0x24b4 <__mulsf3_pse+0x82>
    24be:	86 95       	lsr	r24
    24c0:	77 95       	ror	r23
    24c2:	67 95       	ror	r22
    24c4:	b7 95       	ror	r27
    24c6:	f7 95       	ror	r31
    24c8:	e7 95       	ror	r30
    24ca:	9f 5f       	subi	r25, 0xFF	; 255
    24cc:	c1 f7       	brne	.-16     	; 0x24be <__mulsf3_pse+0x8c>
    24ce:	fe 2b       	or	r31, r30
    24d0:	88 0f       	add	r24, r24
    24d2:	91 1d       	adc	r25, r1
    24d4:	96 95       	lsr	r25
    24d6:	87 95       	ror	r24
    24d8:	97 f9       	bld	r25, 7
    24da:	08 95       	ret

000024dc <_ZN14HardwareSerial9availableEv>:
  return 1;
}

HardwareSerial::operator bool() {
	return true;
}
    24dc:	fc 01       	movw	r30, r24
    24de:	84 85       	ldd	r24, Z+12	; 0x0c
    24e0:	95 85       	ldd	r25, Z+13	; 0x0d
    24e2:	fc 01       	movw	r30, r24
    24e4:	e0 5c       	subi	r30, 0xC0	; 192
    24e6:	ff 4f       	sbci	r31, 0xFF	; 255
    24e8:	20 81       	ld	r18, Z
    24ea:	31 81       	ldd	r19, Z+1	; 0x01
    24ec:	fc 01       	movw	r30, r24
    24ee:	ee 5b       	subi	r30, 0xBE	; 190
    24f0:	ff 4f       	sbci	r31, 0xFF	; 255
    24f2:	80 81       	ld	r24, Z
    24f4:	91 81       	ldd	r25, Z+1	; 0x01
    24f6:	20 5c       	subi	r18, 0xC0	; 192
    24f8:	3f 4f       	sbci	r19, 0xFF	; 255
    24fa:	28 1b       	sub	r18, r24
    24fc:	39 0b       	sbc	r19, r25
    24fe:	2f 73       	andi	r18, 0x3F	; 63
    2500:	30 78       	andi	r19, 0x80	; 128
    2502:	33 23       	and	r19, r19
    2504:	34 f4       	brge	.+12     	; 0x2512 <_ZN14HardwareSerial9availableEv+0x36>
    2506:	21 50       	subi	r18, 0x01	; 1
    2508:	31 09       	sbc	r19, r1
    250a:	20 6c       	ori	r18, 0xC0	; 192
    250c:	3f 6f       	ori	r19, 0xFF	; 255
    250e:	2f 5f       	subi	r18, 0xFF	; 255
    2510:	3f 4f       	sbci	r19, 0xFF	; 255
    2512:	82 2f       	mov	r24, r18
    2514:	93 2f       	mov	r25, r19
    2516:	08 95       	ret

00002518 <_ZN14HardwareSerial4peekEv>:
    2518:	fc 01       	movw	r30, r24
    251a:	84 85       	ldd	r24, Z+12	; 0x0c
    251c:	95 85       	ldd	r25, Z+13	; 0x0d
    251e:	fc 01       	movw	r30, r24
    2520:	e0 5c       	subi	r30, 0xC0	; 192
    2522:	ff 4f       	sbci	r31, 0xFF	; 255
    2524:	40 81       	ld	r20, Z
    2526:	51 81       	ldd	r21, Z+1	; 0x01
    2528:	fc 01       	movw	r30, r24
    252a:	ee 5b       	subi	r30, 0xBE	; 190
    252c:	ff 4f       	sbci	r31, 0xFF	; 255
    252e:	20 81       	ld	r18, Z
    2530:	31 81       	ldd	r19, Z+1	; 0x01
    2532:	42 17       	cp	r20, r18
    2534:	53 07       	cpc	r21, r19
    2536:	59 f0       	breq	.+22     	; 0x254e <_ZN14HardwareSerial4peekEv+0x36>
    2538:	fc 01       	movw	r30, r24
    253a:	ee 5b       	subi	r30, 0xBE	; 190
    253c:	ff 4f       	sbci	r31, 0xFF	; 255
    253e:	20 81       	ld	r18, Z
    2540:	31 81       	ldd	r19, Z+1	; 0x01
    2542:	fc 01       	movw	r30, r24
    2544:	e2 0f       	add	r30, r18
    2546:	f3 1f       	adc	r31, r19
    2548:	20 81       	ld	r18, Z
    254a:	30 e0       	ldi	r19, 0x00	; 0
    254c:	02 c0       	rjmp	.+4      	; 0x2552 <_ZN14HardwareSerial4peekEv+0x3a>
    254e:	2f ef       	ldi	r18, 0xFF	; 255
    2550:	3f ef       	ldi	r19, 0xFF	; 255
    2552:	82 2f       	mov	r24, r18
    2554:	93 2f       	mov	r25, r19
    2556:	08 95       	ret

00002558 <_ZN14HardwareSerial4readEv>:
    2558:	fc 01       	movw	r30, r24
    255a:	84 85       	ldd	r24, Z+12	; 0x0c
    255c:	95 85       	ldd	r25, Z+13	; 0x0d
    255e:	fc 01       	movw	r30, r24
    2560:	e0 5c       	subi	r30, 0xC0	; 192
    2562:	ff 4f       	sbci	r31, 0xFF	; 255
    2564:	40 81       	ld	r20, Z
    2566:	51 81       	ldd	r21, Z+1	; 0x01
    2568:	fc 01       	movw	r30, r24
    256a:	ee 5b       	subi	r30, 0xBE	; 190
    256c:	ff 4f       	sbci	r31, 0xFF	; 255
    256e:	20 81       	ld	r18, Z
    2570:	31 81       	ldd	r19, Z+1	; 0x01
    2572:	42 17       	cp	r20, r18
    2574:	53 07       	cpc	r21, r19
    2576:	91 f0       	breq	.+36     	; 0x259c <_ZN14HardwareSerial4readEv+0x44>
    2578:	fc 01       	movw	r30, r24
    257a:	ee 5b       	subi	r30, 0xBE	; 190
    257c:	ff 4f       	sbci	r31, 0xFF	; 255
    257e:	20 81       	ld	r18, Z
    2580:	31 81       	ldd	r19, Z+1	; 0x01
    2582:	dc 01       	movw	r26, r24
    2584:	a2 0f       	add	r26, r18
    2586:	b3 1f       	adc	r27, r19
    2588:	2c 91       	ld	r18, X
    258a:	80 81       	ld	r24, Z
    258c:	91 81       	ldd	r25, Z+1	; 0x01
    258e:	01 96       	adiw	r24, 0x01	; 1
    2590:	8f 73       	andi	r24, 0x3F	; 63
    2592:	99 27       	eor	r25, r25
    2594:	91 83       	std	Z+1, r25	; 0x01
    2596:	80 83       	st	Z, r24
    2598:	30 e0       	ldi	r19, 0x00	; 0
    259a:	02 c0       	rjmp	.+4      	; 0x25a0 <_ZN14HardwareSerial4readEv+0x48>
    259c:	2f ef       	ldi	r18, 0xFF	; 255
    259e:	3f ef       	ldi	r19, 0xFF	; 255
    25a0:	82 2f       	mov	r24, r18
    25a2:	93 2f       	mov	r25, r19
    25a4:	08 95       	ret

000025a6 <_ZN14HardwareSerial5flushEv>:
    25a6:	fc 01       	movw	r30, r24
    25a8:	81 a1       	ldd	r24, Z+33	; 0x21
    25aa:	88 23       	and	r24, r24
    25ac:	29 f0       	breq	.+10     	; 0x25b8 <_ZN14HardwareSerial5flushEv+0x12>
    25ae:	a4 89       	ldd	r26, Z+20	; 0x14
    25b0:	b5 89       	ldd	r27, Z+21	; 0x15
    25b2:	8c 91       	ld	r24, X
    25b4:	86 ff       	sbrs	r24, 6
    25b6:	fb cf       	rjmp	.-10     	; 0x25ae <_ZN14HardwareSerial5flushEv+0x8>
    25b8:	11 a2       	std	Z+33, r1	; 0x21
    25ba:	08 95       	ret

000025bc <_ZN14HardwareSerial5writeEh>:
    25bc:	dc 01       	movw	r26, r24
    25be:	1e 96       	adiw	r26, 0x0e	; 14
    25c0:	8d 91       	ld	r24, X+
    25c2:	9c 91       	ld	r25, X
    25c4:	1f 97       	sbiw	r26, 0x0f	; 15
    25c6:	fc 01       	movw	r30, r24
    25c8:	e0 5c       	subi	r30, 0xC0	; 192
    25ca:	ff 4f       	sbci	r31, 0xFF	; 255
    25cc:	40 81       	ld	r20, Z
    25ce:	51 81       	ldd	r21, Z+1	; 0x01
    25d0:	4f 5f       	subi	r20, 0xFF	; 255
    25d2:	5f 4f       	sbci	r21, 0xFF	; 255
    25d4:	4f 73       	andi	r20, 0x3F	; 63
    25d6:	55 27       	eor	r21, r21
    25d8:	fc 01       	movw	r30, r24
    25da:	ee 5b       	subi	r30, 0xBE	; 190
    25dc:	ff 4f       	sbci	r31, 0xFF	; 255
    25de:	20 81       	ld	r18, Z
    25e0:	31 81       	ldd	r19, Z+1	; 0x01
    25e2:	24 17       	cp	r18, r20
    25e4:	35 07       	cpc	r19, r21
    25e6:	d9 f3       	breq	.-10     	; 0x25de <_ZN14HardwareSerial5writeEh+0x22>
    25e8:	fc 01       	movw	r30, r24
    25ea:	e0 5c       	subi	r30, 0xC0	; 192
    25ec:	ff 4f       	sbci	r31, 0xFF	; 255
    25ee:	20 81       	ld	r18, Z
    25f0:	31 81       	ldd	r19, Z+1	; 0x01
    25f2:	fc 01       	movw	r30, r24
    25f4:	e2 0f       	add	r30, r18
    25f6:	f3 1f       	adc	r31, r19
    25f8:	60 83       	st	Z, r22
    25fa:	1e 96       	adiw	r26, 0x0e	; 14
    25fc:	ed 91       	ld	r30, X+
    25fe:	fc 91       	ld	r31, X
    2600:	1f 97       	sbiw	r26, 0x0f	; 15
    2602:	e0 5c       	subi	r30, 0xC0	; 192
    2604:	ff 4f       	sbci	r31, 0xFF	; 255
    2606:	51 83       	std	Z+1, r21	; 0x01
    2608:	40 83       	st	Z, r20
    260a:	56 96       	adiw	r26, 0x16	; 22
    260c:	ed 91       	ld	r30, X+
    260e:	fc 91       	ld	r31, X
    2610:	57 97       	sbiw	r26, 0x17	; 23
    2612:	40 81       	ld	r20, Z
    2614:	21 e0       	ldi	r18, 0x01	; 1
    2616:	30 e0       	ldi	r19, 0x00	; 0
    2618:	c9 01       	movw	r24, r18
    261a:	5f 96       	adiw	r26, 0x1f	; 31
    261c:	0c 90       	ld	r0, X
    261e:	5f 97       	sbiw	r26, 0x1f	; 31
    2620:	02 c0       	rjmp	.+4      	; 0x2626 <_ZN14HardwareSerial5writeEh+0x6a>
    2622:	88 0f       	add	r24, r24
    2624:	99 1f       	adc	r25, r25
    2626:	0a 94       	dec	r0
    2628:	e2 f7       	brpl	.-8      	; 0x2622 <_ZN14HardwareSerial5writeEh+0x66>
    262a:	84 2b       	or	r24, r20
    262c:	80 83       	st	Z, r24
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	91 96       	adiw	r26, 0x21	; 33
    2632:	8c 93       	st	X, r24
    2634:	91 97       	sbiw	r26, 0x21	; 33
    2636:	54 96       	adiw	r26, 0x14	; 20
    2638:	ed 91       	ld	r30, X+
    263a:	fc 91       	ld	r31, X
    263c:	55 97       	sbiw	r26, 0x15	; 21
    263e:	80 81       	ld	r24, Z
    2640:	80 64       	ori	r24, 0x40	; 64
    2642:	80 83       	st	Z, r24
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	08 95       	ret

0000264a <__vector_25>:
    264a:	1f 92       	push	r1
    264c:	0f 92       	push	r0
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	0f 92       	push	r0
    2652:	11 24       	eor	r1, r1
    2654:	0b b6       	in	r0, 0x3b	; 59
    2656:	0f 92       	push	r0
    2658:	2f 93       	push	r18
    265a:	3f 93       	push	r19
    265c:	4f 93       	push	r20
    265e:	8f 93       	push	r24
    2660:	9f 93       	push	r25
    2662:	af 93       	push	r26
    2664:	bf 93       	push	r27
    2666:	ef 93       	push	r30
    2668:	ff 93       	push	r31
    266a:	80 91 c0 00 	lds	r24, 0x00C0
    266e:	82 fd       	sbrc	r24, 2
    2670:	1a c0       	rjmp	.+52     	; 0x26a6 <__vector_25+0x5c>
    2672:	40 91 c6 00 	lds	r20, 0x00C6
    2676:	80 91 af 0c 	lds	r24, 0x0CAF
    267a:	90 91 b0 0c 	lds	r25, 0x0CB0
    267e:	01 96       	adiw	r24, 0x01	; 1
    2680:	8f 73       	andi	r24, 0x3F	; 63
    2682:	99 27       	eor	r25, r25
    2684:	20 91 b1 0c 	lds	r18, 0x0CB1
    2688:	30 91 b2 0c 	lds	r19, 0x0CB2
    268c:	82 17       	cp	r24, r18
    268e:	93 07       	cpc	r25, r19
    2690:	61 f0       	breq	.+24     	; 0x26aa <__vector_25+0x60>
    2692:	ef ea       	ldi	r30, 0xAF	; 175
    2694:	fc e0       	ldi	r31, 0x0C	; 12
    2696:	a0 81       	ld	r26, Z
    2698:	b1 81       	ldd	r27, Z+1	; 0x01
    269a:	a1 59       	subi	r26, 0x91	; 145
    269c:	b3 4f       	sbci	r27, 0xF3	; 243
    269e:	4c 93       	st	X, r20
    26a0:	91 83       	std	Z+1, r25	; 0x01
    26a2:	80 83       	st	Z, r24
    26a4:	02 c0       	rjmp	.+4      	; 0x26aa <__vector_25+0x60>
    26a6:	80 91 c6 00 	lds	r24, 0x00C6
    26aa:	ff 91       	pop	r31
    26ac:	ef 91       	pop	r30
    26ae:	bf 91       	pop	r27
    26b0:	af 91       	pop	r26
    26b2:	9f 91       	pop	r25
    26b4:	8f 91       	pop	r24
    26b6:	4f 91       	pop	r20
    26b8:	3f 91       	pop	r19
    26ba:	2f 91       	pop	r18
    26bc:	0f 90       	pop	r0
    26be:	0b be       	out	0x3b, r0	; 59
    26c0:	0f 90       	pop	r0
    26c2:	0f be       	out	0x3f, r0	; 63
    26c4:	0f 90       	pop	r0
    26c6:	1f 90       	pop	r1
    26c8:	18 95       	reti

000026ca <__vector_36>:
    26ca:	1f 92       	push	r1
    26cc:	0f 92       	push	r0
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	0f 92       	push	r0
    26d2:	11 24       	eor	r1, r1
    26d4:	0b b6       	in	r0, 0x3b	; 59
    26d6:	0f 92       	push	r0
    26d8:	2f 93       	push	r18
    26da:	3f 93       	push	r19
    26dc:	4f 93       	push	r20
    26de:	8f 93       	push	r24
    26e0:	9f 93       	push	r25
    26e2:	af 93       	push	r26
    26e4:	bf 93       	push	r27
    26e6:	ef 93       	push	r30
    26e8:	ff 93       	push	r31
    26ea:	80 91 c8 00 	lds	r24, 0x00C8
    26ee:	82 fd       	sbrc	r24, 2
    26f0:	1a c0       	rjmp	.+52     	; 0x2726 <__vector_36+0x5c>
    26f2:	40 91 ce 00 	lds	r20, 0x00CE
    26f6:	80 91 27 0c 	lds	r24, 0x0C27
    26fa:	90 91 28 0c 	lds	r25, 0x0C28
    26fe:	01 96       	adiw	r24, 0x01	; 1
    2700:	8f 73       	andi	r24, 0x3F	; 63
    2702:	99 27       	eor	r25, r25
    2704:	20 91 29 0c 	lds	r18, 0x0C29
    2708:	30 91 2a 0c 	lds	r19, 0x0C2A
    270c:	82 17       	cp	r24, r18
    270e:	93 07       	cpc	r25, r19
    2710:	61 f0       	breq	.+24     	; 0x272a <__vector_36+0x60>
    2712:	e7 e2       	ldi	r30, 0x27	; 39
    2714:	fc e0       	ldi	r31, 0x0C	; 12
    2716:	a0 81       	ld	r26, Z
    2718:	b1 81       	ldd	r27, Z+1	; 0x01
    271a:	a9 51       	subi	r26, 0x19	; 25
    271c:	b4 4f       	sbci	r27, 0xF4	; 244
    271e:	4c 93       	st	X, r20
    2720:	91 83       	std	Z+1, r25	; 0x01
    2722:	80 83       	st	Z, r24
    2724:	02 c0       	rjmp	.+4      	; 0x272a <__vector_36+0x60>
    2726:	80 91 ce 00 	lds	r24, 0x00CE
    272a:	ff 91       	pop	r31
    272c:	ef 91       	pop	r30
    272e:	bf 91       	pop	r27
    2730:	af 91       	pop	r26
    2732:	9f 91       	pop	r25
    2734:	8f 91       	pop	r24
    2736:	4f 91       	pop	r20
    2738:	3f 91       	pop	r19
    273a:	2f 91       	pop	r18
    273c:	0f 90       	pop	r0
    273e:	0b be       	out	0x3b, r0	; 59
    2740:	0f 90       	pop	r0
    2742:	0f be       	out	0x3f, r0	; 63
    2744:	0f 90       	pop	r0
    2746:	1f 90       	pop	r1
    2748:	18 95       	reti

0000274a <__vector_51>:
    274a:	1f 92       	push	r1
    274c:	0f 92       	push	r0
    274e:	0f b6       	in	r0, 0x3f	; 63
    2750:	0f 92       	push	r0
    2752:	11 24       	eor	r1, r1
    2754:	0b b6       	in	r0, 0x3b	; 59
    2756:	0f 92       	push	r0
    2758:	2f 93       	push	r18
    275a:	3f 93       	push	r19
    275c:	4f 93       	push	r20
    275e:	8f 93       	push	r24
    2760:	9f 93       	push	r25
    2762:	af 93       	push	r26
    2764:	bf 93       	push	r27
    2766:	ef 93       	push	r30
    2768:	ff 93       	push	r31
    276a:	80 91 d0 00 	lds	r24, 0x00D0
    276e:	82 fd       	sbrc	r24, 2
    2770:	1a c0       	rjmp	.+52     	; 0x27a6 <__vector_51+0x5c>
    2772:	40 91 d6 00 	lds	r20, 0x00D6
    2776:	80 91 9f 0b 	lds	r24, 0x0B9F
    277a:	90 91 a0 0b 	lds	r25, 0x0BA0
    277e:	01 96       	adiw	r24, 0x01	; 1
    2780:	8f 73       	andi	r24, 0x3F	; 63
    2782:	99 27       	eor	r25, r25
    2784:	20 91 a1 0b 	lds	r18, 0x0BA1
    2788:	30 91 a2 0b 	lds	r19, 0x0BA2
    278c:	82 17       	cp	r24, r18
    278e:	93 07       	cpc	r25, r19
    2790:	61 f0       	breq	.+24     	; 0x27aa <__vector_51+0x60>
    2792:	ef e9       	ldi	r30, 0x9F	; 159
    2794:	fb e0       	ldi	r31, 0x0B	; 11
    2796:	a0 81       	ld	r26, Z
    2798:	b1 81       	ldd	r27, Z+1	; 0x01
    279a:	a1 5a       	subi	r26, 0xA1	; 161
    279c:	b4 4f       	sbci	r27, 0xF4	; 244
    279e:	4c 93       	st	X, r20
    27a0:	91 83       	std	Z+1, r25	; 0x01
    27a2:	80 83       	st	Z, r24
    27a4:	02 c0       	rjmp	.+4      	; 0x27aa <__vector_51+0x60>
    27a6:	80 91 d6 00 	lds	r24, 0x00D6
    27aa:	ff 91       	pop	r31
    27ac:	ef 91       	pop	r30
    27ae:	bf 91       	pop	r27
    27b0:	af 91       	pop	r26
    27b2:	9f 91       	pop	r25
    27b4:	8f 91       	pop	r24
    27b6:	4f 91       	pop	r20
    27b8:	3f 91       	pop	r19
    27ba:	2f 91       	pop	r18
    27bc:	0f 90       	pop	r0
    27be:	0b be       	out	0x3b, r0	; 59
    27c0:	0f 90       	pop	r0
    27c2:	0f be       	out	0x3f, r0	; 63
    27c4:	0f 90       	pop	r0
    27c6:	1f 90       	pop	r1
    27c8:	18 95       	reti

000027ca <__vector_54>:
    27ca:	1f 92       	push	r1
    27cc:	0f 92       	push	r0
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	0f 92       	push	r0
    27d2:	11 24       	eor	r1, r1
    27d4:	0b b6       	in	r0, 0x3b	; 59
    27d6:	0f 92       	push	r0
    27d8:	2f 93       	push	r18
    27da:	3f 93       	push	r19
    27dc:	4f 93       	push	r20
    27de:	8f 93       	push	r24
    27e0:	9f 93       	push	r25
    27e2:	af 93       	push	r26
    27e4:	bf 93       	push	r27
    27e6:	ef 93       	push	r30
    27e8:	ff 93       	push	r31
    27ea:	80 91 30 01 	lds	r24, 0x0130
    27ee:	82 fd       	sbrc	r24, 2
    27f0:	1a c0       	rjmp	.+52     	; 0x2826 <__vector_54+0x5c>
    27f2:	40 91 36 01 	lds	r20, 0x0136
    27f6:	80 91 17 0b 	lds	r24, 0x0B17
    27fa:	90 91 18 0b 	lds	r25, 0x0B18
    27fe:	01 96       	adiw	r24, 0x01	; 1
    2800:	8f 73       	andi	r24, 0x3F	; 63
    2802:	99 27       	eor	r25, r25
    2804:	20 91 19 0b 	lds	r18, 0x0B19
    2808:	30 91 1a 0b 	lds	r19, 0x0B1A
    280c:	82 17       	cp	r24, r18
    280e:	93 07       	cpc	r25, r19
    2810:	61 f0       	breq	.+24     	; 0x282a <__vector_54+0x60>
    2812:	e7 e1       	ldi	r30, 0x17	; 23
    2814:	fb e0       	ldi	r31, 0x0B	; 11
    2816:	a0 81       	ld	r26, Z
    2818:	b1 81       	ldd	r27, Z+1	; 0x01
    281a:	a9 52       	subi	r26, 0x29	; 41
    281c:	b5 4f       	sbci	r27, 0xF5	; 245
    281e:	4c 93       	st	X, r20
    2820:	91 83       	std	Z+1, r25	; 0x01
    2822:	80 83       	st	Z, r24
    2824:	02 c0       	rjmp	.+4      	; 0x282a <__vector_54+0x60>
    2826:	80 91 36 01 	lds	r24, 0x0136
    282a:	ff 91       	pop	r31
    282c:	ef 91       	pop	r30
    282e:	bf 91       	pop	r27
    2830:	af 91       	pop	r26
    2832:	9f 91       	pop	r25
    2834:	8f 91       	pop	r24
    2836:	4f 91       	pop	r20
    2838:	3f 91       	pop	r19
    283a:	2f 91       	pop	r18
    283c:	0f 90       	pop	r0
    283e:	0b be       	out	0x3b, r0	; 59
    2840:	0f 90       	pop	r0
    2842:	0f be       	out	0x3f, r0	; 63
    2844:	0f 90       	pop	r0
    2846:	1f 90       	pop	r1
    2848:	18 95       	reti

0000284a <__vector_26>:
    284a:	1f 92       	push	r1
    284c:	0f 92       	push	r0
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	0f 92       	push	r0
    2852:	11 24       	eor	r1, r1
    2854:	0b b6       	in	r0, 0x3b	; 59
    2856:	0f 92       	push	r0
    2858:	2f 93       	push	r18
    285a:	3f 93       	push	r19
    285c:	8f 93       	push	r24
    285e:	9f 93       	push	r25
    2860:	af 93       	push	r26
    2862:	bf 93       	push	r27
    2864:	ef 93       	push	r30
    2866:	ff 93       	push	r31
    2868:	20 91 6b 0c 	lds	r18, 0x0C6B
    286c:	30 91 6c 0c 	lds	r19, 0x0C6C
    2870:	80 91 6d 0c 	lds	r24, 0x0C6D
    2874:	90 91 6e 0c 	lds	r25, 0x0C6E
    2878:	28 17       	cp	r18, r24
    287a:	39 07       	cpc	r19, r25
    287c:	31 f4       	brne	.+12     	; 0x288a <__vector_26+0x40>
    287e:	e1 ec       	ldi	r30, 0xC1	; 193
    2880:	f0 e0       	ldi	r31, 0x00	; 0
    2882:	80 81       	ld	r24, Z
    2884:	8f 7d       	andi	r24, 0xDF	; 223
    2886:	80 83       	st	Z, r24
    2888:	10 c0       	rjmp	.+32     	; 0x28aa <__vector_26+0x60>
    288a:	ed e6       	ldi	r30, 0x6D	; 109
    288c:	fc e0       	ldi	r31, 0x0C	; 12
    288e:	a0 81       	ld	r26, Z
    2890:	b1 81       	ldd	r27, Z+1	; 0x01
    2892:	a5 5d       	subi	r26, 0xD5	; 213
    2894:	b3 4f       	sbci	r27, 0xF3	; 243
    2896:	2c 91       	ld	r18, X
    2898:	80 81       	ld	r24, Z
    289a:	91 81       	ldd	r25, Z+1	; 0x01
    289c:	01 96       	adiw	r24, 0x01	; 1
    289e:	8f 73       	andi	r24, 0x3F	; 63
    28a0:	99 27       	eor	r25, r25
    28a2:	91 83       	std	Z+1, r25	; 0x01
    28a4:	80 83       	st	Z, r24
    28a6:	20 93 c6 00 	sts	0x00C6, r18
    28aa:	ff 91       	pop	r31
    28ac:	ef 91       	pop	r30
    28ae:	bf 91       	pop	r27
    28b0:	af 91       	pop	r26
    28b2:	9f 91       	pop	r25
    28b4:	8f 91       	pop	r24
    28b6:	3f 91       	pop	r19
    28b8:	2f 91       	pop	r18
    28ba:	0f 90       	pop	r0
    28bc:	0b be       	out	0x3b, r0	; 59
    28be:	0f 90       	pop	r0
    28c0:	0f be       	out	0x3f, r0	; 63
    28c2:	0f 90       	pop	r0
    28c4:	1f 90       	pop	r1
    28c6:	18 95       	reti

000028c8 <__vector_37>:
    28c8:	1f 92       	push	r1
    28ca:	0f 92       	push	r0
    28cc:	0f b6       	in	r0, 0x3f	; 63
    28ce:	0f 92       	push	r0
    28d0:	11 24       	eor	r1, r1
    28d2:	0b b6       	in	r0, 0x3b	; 59
    28d4:	0f 92       	push	r0
    28d6:	2f 93       	push	r18
    28d8:	3f 93       	push	r19
    28da:	8f 93       	push	r24
    28dc:	9f 93       	push	r25
    28de:	af 93       	push	r26
    28e0:	bf 93       	push	r27
    28e2:	ef 93       	push	r30
    28e4:	ff 93       	push	r31
    28e6:	20 91 e3 0b 	lds	r18, 0x0BE3
    28ea:	30 91 e4 0b 	lds	r19, 0x0BE4
    28ee:	80 91 e5 0b 	lds	r24, 0x0BE5
    28f2:	90 91 e6 0b 	lds	r25, 0x0BE6
    28f6:	28 17       	cp	r18, r24
    28f8:	39 07       	cpc	r19, r25
    28fa:	31 f4       	brne	.+12     	; 0x2908 <__vector_37+0x40>
    28fc:	e9 ec       	ldi	r30, 0xC9	; 201
    28fe:	f0 e0       	ldi	r31, 0x00	; 0
    2900:	80 81       	ld	r24, Z
    2902:	8f 7d       	andi	r24, 0xDF	; 223
    2904:	80 83       	st	Z, r24
    2906:	10 c0       	rjmp	.+32     	; 0x2928 <__vector_37+0x60>
    2908:	e5 ee       	ldi	r30, 0xE5	; 229
    290a:	fb e0       	ldi	r31, 0x0B	; 11
    290c:	a0 81       	ld	r26, Z
    290e:	b1 81       	ldd	r27, Z+1	; 0x01
    2910:	ad 55       	subi	r26, 0x5D	; 93
    2912:	b4 4f       	sbci	r27, 0xF4	; 244
    2914:	2c 91       	ld	r18, X
    2916:	80 81       	ld	r24, Z
    2918:	91 81       	ldd	r25, Z+1	; 0x01
    291a:	01 96       	adiw	r24, 0x01	; 1
    291c:	8f 73       	andi	r24, 0x3F	; 63
    291e:	99 27       	eor	r25, r25
    2920:	91 83       	std	Z+1, r25	; 0x01
    2922:	80 83       	st	Z, r24
    2924:	20 93 ce 00 	sts	0x00CE, r18
    2928:	ff 91       	pop	r31
    292a:	ef 91       	pop	r30
    292c:	bf 91       	pop	r27
    292e:	af 91       	pop	r26
    2930:	9f 91       	pop	r25
    2932:	8f 91       	pop	r24
    2934:	3f 91       	pop	r19
    2936:	2f 91       	pop	r18
    2938:	0f 90       	pop	r0
    293a:	0b be       	out	0x3b, r0	; 59
    293c:	0f 90       	pop	r0
    293e:	0f be       	out	0x3f, r0	; 63
    2940:	0f 90       	pop	r0
    2942:	1f 90       	pop	r1
    2944:	18 95       	reti

00002946 <__vector_52>:
    2946:	1f 92       	push	r1
    2948:	0f 92       	push	r0
    294a:	0f b6       	in	r0, 0x3f	; 63
    294c:	0f 92       	push	r0
    294e:	11 24       	eor	r1, r1
    2950:	0b b6       	in	r0, 0x3b	; 59
    2952:	0f 92       	push	r0
    2954:	2f 93       	push	r18
    2956:	3f 93       	push	r19
    2958:	8f 93       	push	r24
    295a:	9f 93       	push	r25
    295c:	af 93       	push	r26
    295e:	bf 93       	push	r27
    2960:	ef 93       	push	r30
    2962:	ff 93       	push	r31
    2964:	20 91 5b 0b 	lds	r18, 0x0B5B
    2968:	30 91 5c 0b 	lds	r19, 0x0B5C
    296c:	80 91 5d 0b 	lds	r24, 0x0B5D
    2970:	90 91 5e 0b 	lds	r25, 0x0B5E
    2974:	28 17       	cp	r18, r24
    2976:	39 07       	cpc	r19, r25
    2978:	31 f4       	brne	.+12     	; 0x2986 <__vector_52+0x40>
    297a:	e1 ed       	ldi	r30, 0xD1	; 209
    297c:	f0 e0       	ldi	r31, 0x00	; 0
    297e:	80 81       	ld	r24, Z
    2980:	8f 7d       	andi	r24, 0xDF	; 223
    2982:	80 83       	st	Z, r24
    2984:	10 c0       	rjmp	.+32     	; 0x29a6 <__vector_52+0x60>
    2986:	ed e5       	ldi	r30, 0x5D	; 93
    2988:	fb e0       	ldi	r31, 0x0B	; 11
    298a:	a0 81       	ld	r26, Z
    298c:	b1 81       	ldd	r27, Z+1	; 0x01
    298e:	a5 5e       	subi	r26, 0xE5	; 229
    2990:	b4 4f       	sbci	r27, 0xF4	; 244
    2992:	2c 91       	ld	r18, X
    2994:	80 81       	ld	r24, Z
    2996:	91 81       	ldd	r25, Z+1	; 0x01
    2998:	01 96       	adiw	r24, 0x01	; 1
    299a:	8f 73       	andi	r24, 0x3F	; 63
    299c:	99 27       	eor	r25, r25
    299e:	91 83       	std	Z+1, r25	; 0x01
    29a0:	80 83       	st	Z, r24
    29a2:	20 93 d6 00 	sts	0x00D6, r18
    29a6:	ff 91       	pop	r31
    29a8:	ef 91       	pop	r30
    29aa:	bf 91       	pop	r27
    29ac:	af 91       	pop	r26
    29ae:	9f 91       	pop	r25
    29b0:	8f 91       	pop	r24
    29b2:	3f 91       	pop	r19
    29b4:	2f 91       	pop	r18
    29b6:	0f 90       	pop	r0
    29b8:	0b be       	out	0x3b, r0	; 59
    29ba:	0f 90       	pop	r0
    29bc:	0f be       	out	0x3f, r0	; 63
    29be:	0f 90       	pop	r0
    29c0:	1f 90       	pop	r1
    29c2:	18 95       	reti

000029c4 <__vector_55>:
    29c4:	1f 92       	push	r1
    29c6:	0f 92       	push	r0
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	0f 92       	push	r0
    29cc:	11 24       	eor	r1, r1
    29ce:	0b b6       	in	r0, 0x3b	; 59
    29d0:	0f 92       	push	r0
    29d2:	2f 93       	push	r18
    29d4:	3f 93       	push	r19
    29d6:	8f 93       	push	r24
    29d8:	9f 93       	push	r25
    29da:	af 93       	push	r26
    29dc:	bf 93       	push	r27
    29de:	ef 93       	push	r30
    29e0:	ff 93       	push	r31
    29e2:	20 91 d3 0a 	lds	r18, 0x0AD3
    29e6:	30 91 d4 0a 	lds	r19, 0x0AD4
    29ea:	80 91 d5 0a 	lds	r24, 0x0AD5
    29ee:	90 91 d6 0a 	lds	r25, 0x0AD6
    29f2:	28 17       	cp	r18, r24
    29f4:	39 07       	cpc	r19, r25
    29f6:	31 f4       	brne	.+12     	; 0x2a04 <__vector_55+0x40>
    29f8:	e1 e3       	ldi	r30, 0x31	; 49
    29fa:	f1 e0       	ldi	r31, 0x01	; 1
    29fc:	80 81       	ld	r24, Z
    29fe:	8f 7d       	andi	r24, 0xDF	; 223
    2a00:	80 83       	st	Z, r24
    2a02:	10 c0       	rjmp	.+32     	; 0x2a24 <__vector_55+0x60>
    2a04:	e5 ed       	ldi	r30, 0xD5	; 213
    2a06:	fa e0       	ldi	r31, 0x0A	; 10
    2a08:	a0 81       	ld	r26, Z
    2a0a:	b1 81       	ldd	r27, Z+1	; 0x01
    2a0c:	ad 56       	subi	r26, 0x6D	; 109
    2a0e:	b5 4f       	sbci	r27, 0xF5	; 245
    2a10:	2c 91       	ld	r18, X
    2a12:	80 81       	ld	r24, Z
    2a14:	91 81       	ldd	r25, Z+1	; 0x01
    2a16:	01 96       	adiw	r24, 0x01	; 1
    2a18:	8f 73       	andi	r24, 0x3F	; 63
    2a1a:	99 27       	eor	r25, r25
    2a1c:	91 83       	std	Z+1, r25	; 0x01
    2a1e:	80 83       	st	Z, r24
    2a20:	20 93 36 01 	sts	0x0136, r18
    2a24:	ff 91       	pop	r31
    2a26:	ef 91       	pop	r30
    2a28:	bf 91       	pop	r27
    2a2a:	af 91       	pop	r26
    2a2c:	9f 91       	pop	r25
    2a2e:	8f 91       	pop	r24
    2a30:	3f 91       	pop	r19
    2a32:	2f 91       	pop	r18
    2a34:	0f 90       	pop	r0
    2a36:	0b be       	out	0x3b, r0	; 59
    2a38:	0f 90       	pop	r0
    2a3a:	0f be       	out	0x3f, r0	; 63
    2a3c:	0f 90       	pop	r0
    2a3e:	1f 90       	pop	r1
    2a40:	18 95       	reti

00002a42 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>:
    2a42:	8f 92       	push	r8
    2a44:	9f 92       	push	r9
    2a46:	af 92       	push	r10
    2a48:	bf 92       	push	r11
    2a4a:	cf 92       	push	r12
    2a4c:	df 92       	push	r13
    2a4e:	ef 92       	push	r14
    2a50:	ff 92       	push	r15
    2a52:	0f 93       	push	r16
    2a54:	1f 93       	push	r17
    2a56:	cf 93       	push	r28
    2a58:	df 93       	push	r29
    2a5a:	cd b7       	in	r28, 0x3d	; 61
    2a5c:	de b7       	in	r29, 0x3e	; 62
    2a5e:	fc 01       	movw	r30, r24
    2a60:	13 82       	std	Z+3, r1	; 0x03
    2a62:	12 82       	std	Z+2, r1	; 0x02
    2a64:	88 ee       	ldi	r24, 0xE8	; 232
    2a66:	93 e0       	ldi	r25, 0x03	; 3
    2a68:	a0 e0       	ldi	r26, 0x00	; 0
    2a6a:	b0 e0       	ldi	r27, 0x00	; 0
    2a6c:	84 83       	std	Z+4, r24	; 0x04
    2a6e:	95 83       	std	Z+5, r25	; 0x05
    2a70:	a6 83       	std	Z+6, r26	; 0x06
    2a72:	b7 83       	std	Z+7, r27	; 0x07
    2a74:	89 e7       	ldi	r24, 0x79	; 121
    2a76:	92 e0       	ldi	r25, 0x02	; 2
    2a78:	91 83       	std	Z+1, r25	; 0x01
    2a7a:	80 83       	st	Z, r24
    2a7c:	75 87       	std	Z+13, r23	; 0x0d
    2a7e:	64 87       	std	Z+12, r22	; 0x0c
    2a80:	57 87       	std	Z+15, r21	; 0x0f
    2a82:	46 87       	std	Z+14, r20	; 0x0e
    2a84:	31 8b       	std	Z+17, r19	; 0x11
    2a86:	20 8b       	std	Z+16, r18	; 0x10
    2a88:	13 8b       	std	Z+19, r17	; 0x13
    2a8a:	02 8b       	std	Z+18, r16	; 0x12
    2a8c:	f5 8a       	std	Z+21, r15	; 0x15
    2a8e:	e4 8a       	std	Z+20, r14	; 0x14
    2a90:	d7 8a       	std	Z+23, r13	; 0x17
    2a92:	c6 8a       	std	Z+22, r12	; 0x16
    2a94:	b1 8e       	std	Z+25, r11	; 0x19
    2a96:	a0 8e       	std	Z+24, r10	; 0x18
    2a98:	93 8e       	std	Z+27, r9	; 0x1b
    2a9a:	82 8e       	std	Z+26, r8	; 0x1a
    2a9c:	88 89       	ldd	r24, Y+16	; 0x10
    2a9e:	84 8f       	std	Z+28, r24	; 0x1c
    2aa0:	89 89       	ldd	r24, Y+17	; 0x11
    2aa2:	85 8f       	std	Z+29, r24	; 0x1d
    2aa4:	8a 89       	ldd	r24, Y+18	; 0x12
    2aa6:	86 8f       	std	Z+30, r24	; 0x1e
    2aa8:	8b 89       	ldd	r24, Y+19	; 0x13
    2aaa:	87 8f       	std	Z+31, r24	; 0x1f
    2aac:	8c 89       	ldd	r24, Y+20	; 0x14
    2aae:	80 a3       	std	Z+32, r24	; 0x20
    2ab0:	df 91       	pop	r29
    2ab2:	cf 91       	pop	r28
    2ab4:	1f 91       	pop	r17
    2ab6:	0f 91       	pop	r16
    2ab8:	ff 90       	pop	r15
    2aba:	ef 90       	pop	r14
    2abc:	df 90       	pop	r13
    2abe:	cf 90       	pop	r12
    2ac0:	bf 90       	pop	r11
    2ac2:	af 90       	pop	r10
    2ac4:	9f 90       	pop	r9
    2ac6:	8f 90       	pop	r8
    2ac8:	08 95       	ret

00002aca <_ZN14HardwareSerial5beginEm>:
    2aca:	cf 92       	push	r12
    2acc:	df 92       	push	r13
    2ace:	ef 92       	push	r14
    2ad0:	ff 92       	push	r15
    2ad2:	cf 93       	push	r28
    2ad4:	df 93       	push	r29
    2ad6:	ec 01       	movw	r28, r24
    2ad8:	6a 01       	movw	r12, r20
    2ada:	7b 01       	movw	r14, r22
    2adc:	41 15       	cp	r20, r1
    2ade:	81 ee       	ldi	r24, 0xE1	; 225
    2ae0:	58 07       	cpc	r21, r24
    2ae2:	61 05       	cpc	r22, r1
    2ae4:	71 05       	cpc	r23, r1
    2ae6:	01 f1       	breq	.+64     	; 0x2b28 <_ZN14HardwareSerial5beginEm+0x5e>
    2ae8:	ec 89       	ldd	r30, Y+20	; 0x14
    2aea:	fd 89       	ldd	r31, Y+21	; 0x15
    2aec:	81 e0       	ldi	r24, 0x01	; 1
    2aee:	90 e0       	ldi	r25, 0x00	; 0
    2af0:	08 a0       	ldd	r0, Y+32	; 0x20
    2af2:	02 c0       	rjmp	.+4      	; 0x2af8 <_ZN14HardwareSerial5beginEm+0x2e>
    2af4:	88 0f       	add	r24, r24
    2af6:	99 1f       	adc	r25, r25
    2af8:	0a 94       	dec	r0
    2afa:	e2 f7       	brpl	.-8      	; 0x2af4 <_ZN14HardwareSerial5beginEm+0x2a>
    2afc:	80 83       	st	Z, r24
    2afe:	60 e0       	ldi	r22, 0x00	; 0
    2b00:	79 e0       	ldi	r23, 0x09	; 9
    2b02:	8d e3       	ldi	r24, 0x3D	; 61
    2b04:	90 e0       	ldi	r25, 0x00	; 0
    2b06:	a7 01       	movw	r20, r14
    2b08:	96 01       	movw	r18, r12
    2b0a:	1b d5       	rcall	.+2614   	; 0x3542 <__udivmodsi4>
    2b0c:	da 01       	movw	r26, r20
    2b0e:	c9 01       	movw	r24, r18
    2b10:	01 97       	sbiw	r24, 0x01	; 1
    2b12:	a1 09       	sbc	r26, r1
    2b14:	b1 09       	sbc	r27, r1
    2b16:	b6 95       	lsr	r27
    2b18:	a7 95       	ror	r26
    2b1a:	97 95       	ror	r25
    2b1c:	87 95       	ror	r24
    2b1e:	9c 01       	movw	r18, r24
    2b20:	21 15       	cp	r18, r1
    2b22:	80 e1       	ldi	r24, 0x10	; 16
    2b24:	38 07       	cpc	r19, r24
    2b26:	a0 f0       	brcs	.+40     	; 0x2b50 <_ZN14HardwareSerial5beginEm+0x86>
    2b28:	ec 89       	ldd	r30, Y+20	; 0x14
    2b2a:	fd 89       	ldd	r31, Y+21	; 0x15
    2b2c:	10 82       	st	Z, r1
    2b2e:	60 e8       	ldi	r22, 0x80	; 128
    2b30:	74 e8       	ldi	r23, 0x84	; 132
    2b32:	8e e1       	ldi	r24, 0x1E	; 30
    2b34:	90 e0       	ldi	r25, 0x00	; 0
    2b36:	a7 01       	movw	r20, r14
    2b38:	96 01       	movw	r18, r12
    2b3a:	03 d5       	rcall	.+2566   	; 0x3542 <__udivmodsi4>
    2b3c:	da 01       	movw	r26, r20
    2b3e:	c9 01       	movw	r24, r18
    2b40:	01 97       	sbiw	r24, 0x01	; 1
    2b42:	a1 09       	sbc	r26, r1
    2b44:	b1 09       	sbc	r27, r1
    2b46:	b6 95       	lsr	r27
    2b48:	a7 95       	ror	r26
    2b4a:	97 95       	ror	r25
    2b4c:	87 95       	ror	r24
    2b4e:	9c 01       	movw	r18, r24
    2b50:	e8 89       	ldd	r30, Y+16	; 0x10
    2b52:	f9 89       	ldd	r31, Y+17	; 0x11
    2b54:	30 83       	st	Z, r19
    2b56:	ea 89       	ldd	r30, Y+18	; 0x12
    2b58:	fb 89       	ldd	r31, Y+19	; 0x13
    2b5a:	20 83       	st	Z, r18
    2b5c:	19 a2       	std	Y+33, r1	; 0x21
    2b5e:	ee 89       	ldd	r30, Y+22	; 0x16
    2b60:	ff 89       	ldd	r31, Y+23	; 0x17
    2b62:	40 81       	ld	r20, Z
    2b64:	81 e0       	ldi	r24, 0x01	; 1
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	9c 01       	movw	r18, r24
    2b6a:	0c 8c       	ldd	r0, Y+28	; 0x1c
    2b6c:	02 c0       	rjmp	.+4      	; 0x2b72 <_ZN14HardwareSerial5beginEm+0xa8>
    2b6e:	22 0f       	add	r18, r18
    2b70:	33 1f       	adc	r19, r19
    2b72:	0a 94       	dec	r0
    2b74:	e2 f7       	brpl	.-8      	; 0x2b6e <_ZN14HardwareSerial5beginEm+0xa4>
    2b76:	24 2b       	or	r18, r20
    2b78:	20 83       	st	Z, r18
    2b7a:	ee 89       	ldd	r30, Y+22	; 0x16
    2b7c:	ff 89       	ldd	r31, Y+23	; 0x17
    2b7e:	40 81       	ld	r20, Z
    2b80:	9c 01       	movw	r18, r24
    2b82:	0d 8c       	ldd	r0, Y+29	; 0x1d
    2b84:	02 c0       	rjmp	.+4      	; 0x2b8a <_ZN14HardwareSerial5beginEm+0xc0>
    2b86:	22 0f       	add	r18, r18
    2b88:	33 1f       	adc	r19, r19
    2b8a:	0a 94       	dec	r0
    2b8c:	e2 f7       	brpl	.-8      	; 0x2b86 <_ZN14HardwareSerial5beginEm+0xbc>
    2b8e:	24 2b       	or	r18, r20
    2b90:	20 83       	st	Z, r18
    2b92:	ee 89       	ldd	r30, Y+22	; 0x16
    2b94:	ff 89       	ldd	r31, Y+23	; 0x17
    2b96:	40 81       	ld	r20, Z
    2b98:	9c 01       	movw	r18, r24
    2b9a:	0e 8c       	ldd	r0, Y+30	; 0x1e
    2b9c:	02 c0       	rjmp	.+4      	; 0x2ba2 <_ZN14HardwareSerial5beginEm+0xd8>
    2b9e:	22 0f       	add	r18, r18
    2ba0:	33 1f       	adc	r19, r19
    2ba2:	0a 94       	dec	r0
    2ba4:	e2 f7       	brpl	.-8      	; 0x2b9e <_ZN14HardwareSerial5beginEm+0xd4>
    2ba6:	24 2b       	or	r18, r20
    2ba8:	20 83       	st	Z, r18
    2baa:	ee 89       	ldd	r30, Y+22	; 0x16
    2bac:	ff 89       	ldd	r31, Y+23	; 0x17
    2bae:	20 81       	ld	r18, Z
    2bb0:	0f 8c       	ldd	r0, Y+31	; 0x1f
    2bb2:	02 c0       	rjmp	.+4      	; 0x2bb8 <_ZN14HardwareSerial5beginEm+0xee>
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	0a 94       	dec	r0
    2bba:	e2 f7       	brpl	.-8      	; 0x2bb4 <_ZN14HardwareSerial5beginEm+0xea>
    2bbc:	80 95       	com	r24
    2bbe:	82 23       	and	r24, r18
    2bc0:	80 83       	st	Z, r24
    2bc2:	df 91       	pop	r29
    2bc4:	cf 91       	pop	r28
    2bc6:	ff 90       	pop	r15
    2bc8:	ef 90       	pop	r14
    2bca:	df 90       	pop	r13
    2bcc:	cf 90       	pop	r12
    2bce:	08 95       	ret

00002bd0 <_GLOBAL__sub_I_rx_buffer>:
#endif
#if defined(UBRR2H)
  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
#endif
#if defined(UBRR3H)
  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
    2bd0:	5f 92       	push	r5
    2bd2:	6f 92       	push	r6
    2bd4:	7f 92       	push	r7
    2bd6:	8f 92       	push	r8
    2bd8:	9f 92       	push	r9
    2bda:	af 92       	push	r10
    2bdc:	bf 92       	push	r11
    2bde:	cf 92       	push	r12
    2be0:	df 92       	push	r13
    2be2:	ef 92       	push	r14
    2be4:	ff 92       	push	r15
    2be6:	0f 93       	push	r16
    2be8:	1f 93       	push	r17
    2bea:	cf 93       	push	r28
    2bec:	df 93       	push	r29
// Preinstantiate Objects //////////////////////////////////////////////////////

#if defined(UBRRH) && defined(UBRRL)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
#elif defined(UBRR0H) && defined(UBRR0L)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
    2bee:	55 24       	eor	r5, r5
    2bf0:	53 94       	inc	r5
    2bf2:	5f 92       	push	r5
    2bf4:	0f 2e       	mov	r0, r31
    2bf6:	f5 e0       	ldi	r31, 0x05	; 5
    2bf8:	6f 2e       	mov	r6, r31
    2bfa:	f0 2d       	mov	r31, r0
    2bfc:	6f 92       	push	r6
    2bfe:	0f 2e       	mov	r0, r31
    2c00:	f7 e0       	ldi	r31, 0x07	; 7
    2c02:	7f 2e       	mov	r7, r31
    2c04:	f0 2d       	mov	r31, r0
    2c06:	7f 92       	push	r7
    2c08:	d3 e0       	ldi	r29, 0x03	; 3
    2c0a:	df 93       	push	r29
    2c0c:	c4 e0       	ldi	r28, 0x04	; 4
    2c0e:	cf 93       	push	r28
    2c10:	0f 2e       	mov	r0, r31
    2c12:	f6 ec       	ldi	r31, 0xC6	; 198
    2c14:	8f 2e       	mov	r8, r31
    2c16:	91 2c       	mov	r9, r1
    2c18:	f0 2d       	mov	r31, r0
    2c1a:	0f 2e       	mov	r0, r31
    2c1c:	f2 ec       	ldi	r31, 0xC2	; 194
    2c1e:	af 2e       	mov	r10, r31
    2c20:	b1 2c       	mov	r11, r1
    2c22:	f0 2d       	mov	r31, r0
    2c24:	0f 2e       	mov	r0, r31
    2c26:	f1 ec       	ldi	r31, 0xC1	; 193
    2c28:	cf 2e       	mov	r12, r31
    2c2a:	d1 2c       	mov	r13, r1
    2c2c:	f0 2d       	mov	r31, r0
    2c2e:	0f 2e       	mov	r0, r31
    2c30:	f0 ec       	ldi	r31, 0xC0	; 192
    2c32:	ef 2e       	mov	r14, r31
    2c34:	f1 2c       	mov	r15, r1
    2c36:	f0 2d       	mov	r31, r0
    2c38:	04 ec       	ldi	r16, 0xC4	; 196
    2c3a:	10 e0       	ldi	r17, 0x00	; 0
    2c3c:	25 ec       	ldi	r18, 0xC5	; 197
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	4b e2       	ldi	r20, 0x2B	; 43
    2c42:	5c e0       	ldi	r21, 0x0C	; 12
    2c44:	6f e6       	ldi	r22, 0x6F	; 111
    2c46:	7c e0       	ldi	r23, 0x0C	; 12
    2c48:	81 e7       	ldi	r24, 0x71	; 113
    2c4a:	9a e0       	ldi	r25, 0x0A	; 10
    2c4c:	fa de       	rcall	.-524    	; 0x2a42 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>
#else
  #error no serial port defined  (port 0)
#endif

#if defined(UBRR1H)
  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
    2c4e:	5f 92       	push	r5
    2c50:	6f 92       	push	r6
    2c52:	7f 92       	push	r7
    2c54:	df 93       	push	r29
    2c56:	cf 93       	push	r28
    2c58:	0f 2e       	mov	r0, r31
    2c5a:	fe ec       	ldi	r31, 0xCE	; 206
    2c5c:	8f 2e       	mov	r8, r31
    2c5e:	91 2c       	mov	r9, r1
    2c60:	f0 2d       	mov	r31, r0
    2c62:	0f 2e       	mov	r0, r31
    2c64:	fa ec       	ldi	r31, 0xCA	; 202
    2c66:	af 2e       	mov	r10, r31
    2c68:	b1 2c       	mov	r11, r1
    2c6a:	f0 2d       	mov	r31, r0
    2c6c:	0f 2e       	mov	r0, r31
    2c6e:	f9 ec       	ldi	r31, 0xC9	; 201
    2c70:	cf 2e       	mov	r12, r31
    2c72:	d1 2c       	mov	r13, r1
    2c74:	f0 2d       	mov	r31, r0
    2c76:	0f 2e       	mov	r0, r31
    2c78:	f8 ec       	ldi	r31, 0xC8	; 200
    2c7a:	ef 2e       	mov	r14, r31
    2c7c:	f1 2c       	mov	r15, r1
    2c7e:	f0 2d       	mov	r31, r0
    2c80:	0c ec       	ldi	r16, 0xCC	; 204
    2c82:	10 e0       	ldi	r17, 0x00	; 0
    2c84:	2d ec       	ldi	r18, 0xCD	; 205
    2c86:	30 e0       	ldi	r19, 0x00	; 0
    2c88:	43 ea       	ldi	r20, 0xA3	; 163
    2c8a:	5b e0       	ldi	r21, 0x0B	; 11
    2c8c:	67 ee       	ldi	r22, 0xE7	; 231
    2c8e:	7b e0       	ldi	r23, 0x0B	; 11
    2c90:	8f e4       	ldi	r24, 0x4F	; 79
    2c92:	9a e0       	ldi	r25, 0x0A	; 10
    2c94:	d6 de       	rcall	.-596    	; 0x2a42 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>
#endif
#if defined(UBRR2H)
  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
    2c96:	5f 92       	push	r5
    2c98:	6f 92       	push	r6
    2c9a:	7f 92       	push	r7
    2c9c:	df 93       	push	r29
    2c9e:	cf 93       	push	r28
    2ca0:	0f 2e       	mov	r0, r31
    2ca2:	f6 ed       	ldi	r31, 0xD6	; 214
    2ca4:	8f 2e       	mov	r8, r31
    2ca6:	91 2c       	mov	r9, r1
    2ca8:	f0 2d       	mov	r31, r0
    2caa:	0f 2e       	mov	r0, r31
    2cac:	f2 ed       	ldi	r31, 0xD2	; 210
    2cae:	af 2e       	mov	r10, r31
    2cb0:	b1 2c       	mov	r11, r1
    2cb2:	f0 2d       	mov	r31, r0
    2cb4:	0f 2e       	mov	r0, r31
    2cb6:	f1 ed       	ldi	r31, 0xD1	; 209
    2cb8:	cf 2e       	mov	r12, r31
    2cba:	d1 2c       	mov	r13, r1
    2cbc:	f0 2d       	mov	r31, r0
    2cbe:	0f 2e       	mov	r0, r31
    2cc0:	f0 ed       	ldi	r31, 0xD0	; 208
    2cc2:	ef 2e       	mov	r14, r31
    2cc4:	f1 2c       	mov	r15, r1
    2cc6:	f0 2d       	mov	r31, r0
    2cc8:	04 ed       	ldi	r16, 0xD4	; 212
    2cca:	10 e0       	ldi	r17, 0x00	; 0
    2ccc:	25 ed       	ldi	r18, 0xD5	; 213
    2cce:	30 e0       	ldi	r19, 0x00	; 0
    2cd0:	4b e1       	ldi	r20, 0x1B	; 27
    2cd2:	5b e0       	ldi	r21, 0x0B	; 11
    2cd4:	6f e5       	ldi	r22, 0x5F	; 95
    2cd6:	7b e0       	ldi	r23, 0x0B	; 11
    2cd8:	8d e2       	ldi	r24, 0x2D	; 45
    2cda:	9a e0       	ldi	r25, 0x0A	; 10
    2cdc:	b2 de       	rcall	.-668    	; 0x2a42 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>
#endif
#if defined(UBRR3H)
  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
    2cde:	5f 92       	push	r5
    2ce0:	6f 92       	push	r6
    2ce2:	7f 92       	push	r7
    2ce4:	df 93       	push	r29
    2ce6:	cf 93       	push	r28
    2ce8:	0f 2e       	mov	r0, r31
    2cea:	f6 e3       	ldi	r31, 0x36	; 54
    2cec:	8f 2e       	mov	r8, r31
    2cee:	99 24       	eor	r9, r9
    2cf0:	93 94       	inc	r9
    2cf2:	f0 2d       	mov	r31, r0
    2cf4:	0f 2e       	mov	r0, r31
    2cf6:	f2 e3       	ldi	r31, 0x32	; 50
    2cf8:	af 2e       	mov	r10, r31
    2cfa:	bb 24       	eor	r11, r11
    2cfc:	b3 94       	inc	r11
    2cfe:	f0 2d       	mov	r31, r0
    2d00:	0f 2e       	mov	r0, r31
    2d02:	f1 e3       	ldi	r31, 0x31	; 49
    2d04:	cf 2e       	mov	r12, r31
    2d06:	dd 24       	eor	r13, r13
    2d08:	d3 94       	inc	r13
    2d0a:	f0 2d       	mov	r31, r0
    2d0c:	0f 2e       	mov	r0, r31
    2d0e:	f0 e3       	ldi	r31, 0x30	; 48
    2d10:	ef 2e       	mov	r14, r31
    2d12:	ff 24       	eor	r15, r15
    2d14:	f3 94       	inc	r15
    2d16:	f0 2d       	mov	r31, r0
    2d18:	04 e3       	ldi	r16, 0x34	; 52
    2d1a:	11 e0       	ldi	r17, 0x01	; 1
    2d1c:	25 e3       	ldi	r18, 0x35	; 53
    2d1e:	31 e0       	ldi	r19, 0x01	; 1
    2d20:	43 e9       	ldi	r20, 0x93	; 147
    2d22:	5a e0       	ldi	r21, 0x0A	; 10
    2d24:	67 ed       	ldi	r22, 0xD7	; 215
    2d26:	7a e0       	ldi	r23, 0x0A	; 10
    2d28:	8b e0       	ldi	r24, 0x0B	; 11
    2d2a:	9a e0       	ldi	r25, 0x0A	; 10
    2d2c:	8a de       	rcall	.-748    	; 0x2a42 <_ZN14HardwareSerialC1EP11ring_bufferS1_PVhS3_S3_S3_S3_S3_hhhhh>
    2d2e:	8d b7       	in	r24, 0x3d	; 61
    2d30:	9e b7       	in	r25, 0x3e	; 62
    2d32:	44 96       	adiw	r24, 0x14	; 20
    2d34:	0f b6       	in	r0, 0x3f	; 63
    2d36:	f8 94       	cli
    2d38:	9e bf       	out	0x3e, r25	; 62
    2d3a:	0f be       	out	0x3f, r0	; 63
    2d3c:	8d bf       	out	0x3d, r24	; 61
    2d3e:	df 91       	pop	r29
    2d40:	cf 91       	pop	r28
    2d42:	1f 91       	pop	r17
    2d44:	0f 91       	pop	r16
    2d46:	ff 90       	pop	r15
    2d48:	ef 90       	pop	r14
    2d4a:	df 90       	pop	r13
    2d4c:	cf 90       	pop	r12
    2d4e:	bf 90       	pop	r11
    2d50:	af 90       	pop	r10
    2d52:	9f 90       	pop	r9
    2d54:	8f 90       	pop	r8
    2d56:	7f 90       	pop	r7
    2d58:	6f 90       	pop	r6
    2d5a:	5f 90       	pop	r5
    2d5c:	08 95       	ret

00002d5e <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    2d5e:	cf 92       	push	r12
    2d60:	df 92       	push	r13
    2d62:	ef 92       	push	r14
    2d64:	ff 92       	push	r15
    2d66:	0f 93       	push	r16
    2d68:	1f 93       	push	r17
    2d6a:	cf 93       	push	r28
    2d6c:	df 93       	push	r29
    2d6e:	7c 01       	movw	r14, r24
    2d70:	6b 01       	movw	r12, r22
    2d72:	ea 01       	movw	r28, r20
    2d74:	20 97       	sbiw	r28, 0x00	; 0
    2d76:	91 f0       	breq	.+36     	; 0x2d9c <_ZN5Print5writeEPKhj+0x3e>
    2d78:	00 e0       	ldi	r16, 0x00	; 0
    2d7a:	10 e0       	ldi	r17, 0x00	; 0
    2d7c:	d6 01       	movw	r26, r12
    2d7e:	6d 91       	ld	r22, X+
    2d80:	6d 01       	movw	r12, r26
    2d82:	d7 01       	movw	r26, r14
    2d84:	ed 91       	ld	r30, X+
    2d86:	fc 91       	ld	r31, X
    2d88:	01 90       	ld	r0, Z+
    2d8a:	f0 81       	ld	r31, Z
    2d8c:	e0 2d       	mov	r30, r0
    2d8e:	c7 01       	movw	r24, r14
    2d90:	19 95       	eicall
    2d92:	08 0f       	add	r16, r24
    2d94:	19 1f       	adc	r17, r25
    2d96:	21 97       	sbiw	r28, 0x01	; 1
    2d98:	89 f7       	brne	.-30     	; 0x2d7c <_ZN5Print5writeEPKhj+0x1e>
    2d9a:	02 c0       	rjmp	.+4      	; 0x2da0 <_ZN5Print5writeEPKhj+0x42>
    2d9c:	00 e0       	ldi	r16, 0x00	; 0
    2d9e:	10 e0       	ldi	r17, 0x00	; 0
    2da0:	80 2f       	mov	r24, r16
    2da2:	91 2f       	mov	r25, r17
    2da4:	df 91       	pop	r29
    2da6:	cf 91       	pop	r28
    2da8:	1f 91       	pop	r17
    2daa:	0f 91       	pop	r16
    2dac:	ff 90       	pop	r15
    2dae:	ef 90       	pop	r14
    2db0:	df 90       	pop	r13
    2db2:	cf 90       	pop	r12
    2db4:	08 95       	ret

00002db6 <_ZN5Print5printEPKc>:
    2db6:	61 15       	cp	r22, r1
    2db8:	71 05       	cpc	r23, r1
    2dba:	99 f0       	breq	.+38     	; 0x2de2 <_ZN5Print5printEPKc+0x2c>
    2dbc:	e6 2f       	mov	r30, r22
    2dbe:	f7 2f       	mov	r31, r23
    2dc0:	df 01       	movw	r26, r30
    2dc2:	0d 90       	ld	r0, X+
    2dc4:	00 20       	and	r0, r0
    2dc6:	e9 f7       	brne	.-6      	; 0x2dc2 <_ZN5Print5printEPKc+0xc>
    2dc8:	11 97       	sbiw	r26, 0x01	; 1
    2dca:	ad 01       	movw	r20, r26
    2dcc:	4e 1b       	sub	r20, r30
    2dce:	5f 0b       	sbc	r21, r31
    2dd0:	dc 01       	movw	r26, r24
    2dd2:	ed 91       	ld	r30, X+
    2dd4:	fc 91       	ld	r31, X
    2dd6:	02 80       	ldd	r0, Z+2	; 0x02
    2dd8:	f3 81       	ldd	r31, Z+3	; 0x03
    2dda:	e0 2d       	mov	r30, r0
    2ddc:	19 95       	eicall
    2dde:	9c 01       	movw	r18, r24
    2de0:	02 c0       	rjmp	.+4      	; 0x2de6 <_ZN5Print5printEPKc+0x30>
    2de2:	20 e0       	ldi	r18, 0x00	; 0
    2de4:	30 e0       	ldi	r19, 0x00	; 0
    2de6:	82 2f       	mov	r24, r18
    2de8:	93 2f       	mov	r25, r19
    2dea:	08 95       	ret

00002dec <_ZN5Print5printEc>:
    2dec:	dc 01       	movw	r26, r24
    2dee:	ed 91       	ld	r30, X+
    2df0:	fc 91       	ld	r31, X
    2df2:	01 90       	ld	r0, Z+
    2df4:	f0 81       	ld	r31, Z
    2df6:	e0 2d       	mov	r30, r0
    2df8:	19 95       	eicall
    2dfa:	08 95       	ret

00002dfc <_ZN5Print7printlnEv>:
    2dfc:	0f 93       	push	r16
    2dfe:	1f 93       	push	r17
    2e00:	cf 93       	push	r28
    2e02:	df 93       	push	r29
    2e04:	ec 01       	movw	r28, r24
    2e06:	6d e0       	ldi	r22, 0x0D	; 13
    2e08:	f1 df       	rcall	.-30     	; 0x2dec <_ZN5Print5printEc>
    2e0a:	8c 01       	movw	r16, r24
    2e0c:	6a e0       	ldi	r22, 0x0A	; 10
    2e0e:	ce 01       	movw	r24, r28
    2e10:	ed df       	rcall	.-38     	; 0x2dec <_ZN5Print5printEc>
    2e12:	9c 01       	movw	r18, r24
    2e14:	20 0f       	add	r18, r16
    2e16:	31 1f       	adc	r19, r17
    2e18:	82 2f       	mov	r24, r18
    2e1a:	93 2f       	mov	r25, r19
    2e1c:	df 91       	pop	r29
    2e1e:	cf 91       	pop	r28
    2e20:	1f 91       	pop	r17
    2e22:	0f 91       	pop	r16
    2e24:	08 95       	ret

00002e26 <_ZN5Print7printlnEPKc>:
    2e26:	0f 93       	push	r16
    2e28:	1f 93       	push	r17
    2e2a:	cf 93       	push	r28
    2e2c:	df 93       	push	r29
    2e2e:	ec 01       	movw	r28, r24
    2e30:	c2 df       	rcall	.-124    	; 0x2db6 <_ZN5Print5printEPKc>
    2e32:	8c 01       	movw	r16, r24
    2e34:	ce 01       	movw	r24, r28
    2e36:	e2 df       	rcall	.-60     	; 0x2dfc <_ZN5Print7printlnEv>
    2e38:	9c 01       	movw	r18, r24
    2e3a:	20 0f       	add	r18, r16
    2e3c:	31 1f       	adc	r19, r17
    2e3e:	82 2f       	mov	r24, r18
    2e40:	93 2f       	mov	r25, r19
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	1f 91       	pop	r17
    2e48:	0f 91       	pop	r16
    2e4a:	08 95       	ret

00002e4c <_ZN5Print11printNumberEmh>:
    2e4c:	4f 92       	push	r4
    2e4e:	5f 92       	push	r5
    2e50:	6f 92       	push	r6
    2e52:	7f 92       	push	r7
    2e54:	9f 92       	push	r9
    2e56:	af 92       	push	r10
    2e58:	bf 92       	push	r11
    2e5a:	cf 92       	push	r12
    2e5c:	df 92       	push	r13
    2e5e:	ef 92       	push	r14
    2e60:	ff 92       	push	r15
    2e62:	0f 93       	push	r16
    2e64:	1f 93       	push	r17
    2e66:	cf 93       	push	r28
    2e68:	df 93       	push	r29
    2e6a:	cd b7       	in	r28, 0x3d	; 61
    2e6c:	de b7       	in	r29, 0x3e	; 62
    2e6e:	a1 97       	sbiw	r28, 0x21	; 33
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	de bf       	out	0x3e, r29	; 62
    2e76:	0f be       	out	0x3f, r0	; 63
    2e78:	cd bf       	out	0x3d, r28	; 61
    2e7a:	5c 01       	movw	r10, r24
    2e7c:	6a 01       	movw	r12, r20
    2e7e:	7b 01       	movw	r14, r22
    2e80:	92 2e       	mov	r9, r18
    2e82:	19 a2       	std	Y+33, r1	; 0x21
    2e84:	81 e0       	ldi	r24, 0x01	; 1
    2e86:	82 17       	cp	r24, r18
    2e88:	20 f0       	brcs	.+8      	; 0x2e92 <_ZN5Print11printNumberEmh+0x46>
    2e8a:	0f 2e       	mov	r0, r31
    2e8c:	fa e0       	ldi	r31, 0x0A	; 10
    2e8e:	9f 2e       	mov	r9, r31
    2e90:	f0 2d       	mov	r31, r0
    2e92:	8e 01       	movw	r16, r28
    2e94:	0f 5d       	subi	r16, 0xDF	; 223
    2e96:	1f 4f       	sbci	r17, 0xFF	; 255
    2e98:	49 2c       	mov	r4, r9
    2e9a:	51 2c       	mov	r5, r1
    2e9c:	61 2c       	mov	r6, r1
    2e9e:	71 2c       	mov	r7, r1
    2ea0:	c7 01       	movw	r24, r14
    2ea2:	b6 01       	movw	r22, r12
    2ea4:	a3 01       	movw	r20, r6
    2ea6:	92 01       	movw	r18, r4
    2ea8:	4c d3       	rcall	.+1688   	; 0x3542 <__udivmodsi4>
    2eaa:	8c 2d       	mov	r24, r12
    2eac:	92 9e       	mul	r9, r18
    2eae:	80 19       	sub	r24, r0
    2eb0:	11 24       	eor	r1, r1
    2eb2:	01 50       	subi	r16, 0x01	; 1
    2eb4:	11 09       	sbc	r17, r1
    2eb6:	8a 30       	cpi	r24, 0x0A	; 10
    2eb8:	10 f4       	brcc	.+4      	; 0x2ebe <_ZN5Print11printNumberEmh+0x72>
    2eba:	80 5d       	subi	r24, 0xD0	; 208
    2ebc:	01 c0       	rjmp	.+2      	; 0x2ec0 <_ZN5Print11printNumberEmh+0x74>
    2ebe:	89 5c       	subi	r24, 0xC9	; 201
    2ec0:	d8 01       	movw	r26, r16
    2ec2:	8c 93       	st	X, r24
    2ec4:	c2 2e       	mov	r12, r18
    2ec6:	d3 2e       	mov	r13, r19
    2ec8:	e4 2e       	mov	r14, r20
    2eca:	f5 2e       	mov	r15, r21
    2ecc:	c1 14       	cp	r12, r1
    2ece:	d1 04       	cpc	r13, r1
    2ed0:	e1 04       	cpc	r14, r1
    2ed2:	f1 04       	cpc	r15, r1
    2ed4:	29 f7       	brne	.-54     	; 0x2ea0 <_ZN5Print11printNumberEmh+0x54>
    2ed6:	01 15       	cp	r16, r1
    2ed8:	11 05       	cpc	r17, r1
    2eda:	a9 f0       	breq	.+42     	; 0x2f06 <_ZN5Print11printNumberEmh+0xba>
    2edc:	e0 2f       	mov	r30, r16
    2ede:	f1 2f       	mov	r31, r17
    2ee0:	df 01       	movw	r26, r30
    2ee2:	0d 90       	ld	r0, X+
    2ee4:	00 20       	and	r0, r0
    2ee6:	e9 f7       	brne	.-6      	; 0x2ee2 <_ZN5Print11printNumberEmh+0x96>
    2ee8:	11 97       	sbiw	r26, 0x01	; 1
    2eea:	ad 01       	movw	r20, r26
    2eec:	4e 1b       	sub	r20, r30
    2eee:	5f 0b       	sbc	r21, r31
    2ef0:	d5 01       	movw	r26, r10
    2ef2:	ed 91       	ld	r30, X+
    2ef4:	fc 91       	ld	r31, X
    2ef6:	02 80       	ldd	r0, Z+2	; 0x02
    2ef8:	f3 81       	ldd	r31, Z+3	; 0x03
    2efa:	e0 2d       	mov	r30, r0
    2efc:	b8 01       	movw	r22, r16
    2efe:	c5 01       	movw	r24, r10
    2f00:	19 95       	eicall
    2f02:	9c 01       	movw	r18, r24
    2f04:	02 c0       	rjmp	.+4      	; 0x2f0a <_ZN5Print11printNumberEmh+0xbe>
    2f06:	20 e0       	ldi	r18, 0x00	; 0
    2f08:	30 e0       	ldi	r19, 0x00	; 0
    2f0a:	82 2f       	mov	r24, r18
    2f0c:	93 2f       	mov	r25, r19
    2f0e:	a1 96       	adiw	r28, 0x21	; 33
    2f10:	0f b6       	in	r0, 0x3f	; 63
    2f12:	f8 94       	cli
    2f14:	de bf       	out	0x3e, r29	; 62
    2f16:	0f be       	out	0x3f, r0	; 63
    2f18:	cd bf       	out	0x3d, r28	; 61
    2f1a:	df 91       	pop	r29
    2f1c:	cf 91       	pop	r28
    2f1e:	1f 91       	pop	r17
    2f20:	0f 91       	pop	r16
    2f22:	ff 90       	pop	r15
    2f24:	ef 90       	pop	r14
    2f26:	df 90       	pop	r13
    2f28:	cf 90       	pop	r12
    2f2a:	bf 90       	pop	r11
    2f2c:	af 90       	pop	r10
    2f2e:	9f 90       	pop	r9
    2f30:	7f 90       	pop	r7
    2f32:	6f 90       	pop	r6
    2f34:	5f 90       	pop	r5
    2f36:	4f 90       	pop	r4
    2f38:	08 95       	ret

00002f3a <_ZN5Print5printEmi>:
    2f3a:	21 15       	cp	r18, r1
    2f3c:	31 05       	cpc	r19, r1
    2f3e:	49 f4       	brne	.+18     	; 0x2f52 <_ZN5Print5printEmi+0x18>
    2f40:	dc 01       	movw	r26, r24
    2f42:	ed 91       	ld	r30, X+
    2f44:	fc 91       	ld	r31, X
    2f46:	01 90       	ld	r0, Z+
    2f48:	f0 81       	ld	r31, Z
    2f4a:	e0 2d       	mov	r30, r0
    2f4c:	64 2f       	mov	r22, r20
    2f4e:	19 95       	eicall
    2f50:	08 95       	ret
    2f52:	7c cf       	rjmp	.-264    	; 0x2e4c <_ZN5Print11printNumberEmh>

00002f54 <_ZN5Print5printEhi>:
{
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
    2f54:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
    2f56:	46 2f       	mov	r20, r22
    2f58:	50 e0       	ldi	r21, 0x00	; 0
    2f5a:	60 e0       	ldi	r22, 0x00	; 0
    2f5c:	70 e0       	ldi	r23, 0x00	; 0
}
    2f5e:	ed cf       	rjmp	.-38     	; 0x2f3a <_ZN5Print5printEmi>

00002f60 <_ZN5Print7printlnEhi>:
  n += println();
  return n;
}

size_t Print::println(unsigned char b, int base)
{
    2f60:	0f 93       	push	r16
    2f62:	1f 93       	push	r17
    2f64:	cf 93       	push	r28
    2f66:	df 93       	push	r29
    2f68:	ec 01       	movw	r28, r24
  size_t n = print(b, base);
    2f6a:	f4 df       	rcall	.-24     	; 0x2f54 <_ZN5Print5printEhi>
    2f6c:	8c 01       	movw	r16, r24
  n += println();
    2f6e:	ce 01       	movw	r24, r28
    2f70:	45 df       	rcall	.-374    	; 0x2dfc <_ZN5Print7printlnEv>
    2f72:	9c 01       	movw	r18, r24
    2f74:	20 0f       	add	r18, r16
    2f76:	31 1f       	adc	r19, r17
  return n;
}
    2f78:	82 2f       	mov	r24, r18
    2f7a:	93 2f       	mov	r25, r19
    2f7c:	df 91       	pop	r29
    2f7e:	cf 91       	pop	r28
    2f80:	1f 91       	pop	r17
    2f82:	0f 91       	pop	r16
    2f84:	08 95       	ret

00002f86 <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    2f86:	1f 92       	push	r1
    2f88:	0f 92       	push	r0
    2f8a:	0f b6       	in	r0, 0x3f	; 63
    2f8c:	0f 92       	push	r0
    2f8e:	11 24       	eor	r1, r1
    2f90:	2f 93       	push	r18
    2f92:	3f 93       	push	r19
    2f94:	8f 93       	push	r24
    2f96:	9f 93       	push	r25
    2f98:	af 93       	push	r26
    2f9a:	bf 93       	push	r27
    2f9c:	80 91 b3 0c 	lds	r24, 0x0CB3
    2fa0:	90 91 b4 0c 	lds	r25, 0x0CB4
    2fa4:	a0 91 b5 0c 	lds	r26, 0x0CB5
    2fa8:	b0 91 b6 0c 	lds	r27, 0x0CB6
    2fac:	30 91 bb 0c 	lds	r19, 0x0CBB
    2fb0:	23 2f       	mov	r18, r19
    2fb2:	2d 5f       	subi	r18, 0xFD	; 253
    2fb4:	2d 37       	cpi	r18, 0x7D	; 125
    2fb6:	20 f4       	brcc	.+8      	; 0x2fc0 <__vector_23+0x3a>
    2fb8:	01 96       	adiw	r24, 0x01	; 1
    2fba:	a1 1d       	adc	r26, r1
    2fbc:	b1 1d       	adc	r27, r1
    2fbe:	05 c0       	rjmp	.+10     	; 0x2fca <__vector_23+0x44>
    2fc0:	23 2f       	mov	r18, r19
    2fc2:	2a 57       	subi	r18, 0x7A	; 122
    2fc4:	02 96       	adiw	r24, 0x02	; 2
    2fc6:	a1 1d       	adc	r26, r1
    2fc8:	b1 1d       	adc	r27, r1
    2fca:	20 93 bb 0c 	sts	0x0CBB, r18
    2fce:	80 93 b3 0c 	sts	0x0CB3, r24
    2fd2:	90 93 b4 0c 	sts	0x0CB4, r25
    2fd6:	a0 93 b5 0c 	sts	0x0CB5, r26
    2fda:	b0 93 b6 0c 	sts	0x0CB6, r27
    2fde:	80 91 b7 0c 	lds	r24, 0x0CB7
    2fe2:	90 91 b8 0c 	lds	r25, 0x0CB8
    2fe6:	a0 91 b9 0c 	lds	r26, 0x0CB9
    2fea:	b0 91 ba 0c 	lds	r27, 0x0CBA
    2fee:	01 96       	adiw	r24, 0x01	; 1
    2ff0:	a1 1d       	adc	r26, r1
    2ff2:	b1 1d       	adc	r27, r1
    2ff4:	80 93 b7 0c 	sts	0x0CB7, r24
    2ff8:	90 93 b8 0c 	sts	0x0CB8, r25
    2ffc:	a0 93 b9 0c 	sts	0x0CB9, r26
    3000:	b0 93 ba 0c 	sts	0x0CBA, r27
    3004:	bf 91       	pop	r27
    3006:	af 91       	pop	r26
    3008:	9f 91       	pop	r25
    300a:	8f 91       	pop	r24
    300c:	3f 91       	pop	r19
    300e:	2f 91       	pop	r18
    3010:	0f 90       	pop	r0
    3012:	0f be       	out	0x3f, r0	; 63
    3014:	0f 90       	pop	r0
    3016:	1f 90       	pop	r1
    3018:	18 95       	reti

0000301a <millis>:
    301a:	0f 93       	push	r16
    301c:	1f 93       	push	r17
    301e:	8f b7       	in	r24, 0x3f	; 63
    3020:	f8 94       	cli
    3022:	00 91 b3 0c 	lds	r16, 0x0CB3
    3026:	10 91 b4 0c 	lds	r17, 0x0CB4
    302a:	20 91 b5 0c 	lds	r18, 0x0CB5
    302e:	30 91 b6 0c 	lds	r19, 0x0CB6
    3032:	8f bf       	out	0x3f, r24	; 63
    3034:	60 2f       	mov	r22, r16
    3036:	71 2f       	mov	r23, r17
    3038:	82 2f       	mov	r24, r18
    303a:	93 2f       	mov	r25, r19
    303c:	1f 91       	pop	r17
    303e:	0f 91       	pop	r16
    3040:	08 95       	ret

00003042 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call yields a delay of approximately 1 1/8 us.
	if (--us == 0)
    3042:	01 97       	sbiw	r24, 0x01	; 1
    3044:	39 f0       	breq	.+14     	; 0x3054 <delayMicroseconds+0x12>
		return;

	// the following loop takes a quarter of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2;
    3046:	88 0f       	add	r24, r24
    3048:	99 1f       	adc	r25, r25
    304a:	88 0f       	add	r24, r24
    304c:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	us -= 2;
    304e:	02 97       	sbiw	r24, 0x02	; 2
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
    3050:	01 97       	sbiw	r24, 0x01	; 1
    3052:	f1 f7       	brne	.-4      	; 0x3050 <delayMicroseconds+0xe>
    3054:	08 95       	ret

00003056 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    3056:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    3058:	84 b5       	in	r24, 0x24	; 36
    305a:	82 60       	ori	r24, 0x02	; 2
    305c:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    305e:	84 b5       	in	r24, 0x24	; 36
    3060:	81 60       	ori	r24, 0x01	; 1
    3062:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    3064:	85 b5       	in	r24, 0x25	; 37
    3066:	82 60       	ori	r24, 0x02	; 2
    3068:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    306a:	85 b5       	in	r24, 0x25	; 37
    306c:	81 60       	ori	r24, 0x01	; 1
    306e:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3070:	ee e6       	ldi	r30, 0x6E	; 110
    3072:	f0 e0       	ldi	r31, 0x00	; 0
    3074:	80 81       	ld	r24, Z
    3076:	81 60       	ori	r24, 0x01	; 1
    3078:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    307a:	e1 e8       	ldi	r30, 0x81	; 129
    307c:	f0 e0       	ldi	r31, 0x00	; 0
    307e:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3080:	80 81       	ld	r24, Z
    3082:	82 60       	ori	r24, 0x02	; 2
    3084:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    3086:	80 81       	ld	r24, Z
    3088:	81 60       	ori	r24, 0x01	; 1
    308a:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    308c:	e0 e8       	ldi	r30, 0x80	; 128
    308e:	f0 e0       	ldi	r31, 0x00	; 0
    3090:	80 81       	ld	r24, Z
    3092:	81 60       	ori	r24, 0x01	; 1
    3094:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    3096:	e1 eb       	ldi	r30, 0xB1	; 177
    3098:	f0 e0       	ldi	r31, 0x00	; 0
    309a:	80 81       	ld	r24, Z
    309c:	84 60       	ori	r24, 0x04	; 4
    309e:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    30a0:	e0 eb       	ldi	r30, 0xB0	; 176
    30a2:	f0 e0       	ldi	r31, 0x00	; 0
    30a4:	80 81       	ld	r24, Z
    30a6:	81 60       	ori	r24, 0x01	; 1
    30a8:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    30aa:	e1 e9       	ldi	r30, 0x91	; 145
    30ac:	f0 e0       	ldi	r31, 0x00	; 0
    30ae:	80 81       	ld	r24, Z
    30b0:	82 60       	ori	r24, 0x02	; 2
    30b2:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    30b4:	80 81       	ld	r24, Z
    30b6:	81 60       	ori	r24, 0x01	; 1
    30b8:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    30ba:	e0 e9       	ldi	r30, 0x90	; 144
    30bc:	f0 e0       	ldi	r31, 0x00	; 0
    30be:	80 81       	ld	r24, Z
    30c0:	81 60       	ori	r24, 0x01	; 1
    30c2:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    30c4:	e1 ea       	ldi	r30, 0xA1	; 161
    30c6:	f0 e0       	ldi	r31, 0x00	; 0
    30c8:	80 81       	ld	r24, Z
    30ca:	82 60       	ori	r24, 0x02	; 2
    30cc:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    30ce:	80 81       	ld	r24, Z
    30d0:	81 60       	ori	r24, 0x01	; 1
    30d2:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    30d4:	e0 ea       	ldi	r30, 0xA0	; 160
    30d6:	f0 e0       	ldi	r31, 0x00	; 0
    30d8:	80 81       	ld	r24, Z
    30da:	81 60       	ori	r24, 0x01	; 1
    30dc:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    30de:	e1 e2       	ldi	r30, 0x21	; 33
    30e0:	f1 e0       	ldi	r31, 0x01	; 1
    30e2:	80 81       	ld	r24, Z
    30e4:	82 60       	ori	r24, 0x02	; 2
    30e6:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    30e8:	80 81       	ld	r24, Z
    30ea:	81 60       	ori	r24, 0x01	; 1
    30ec:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    30ee:	e0 e2       	ldi	r30, 0x20	; 32
    30f0:	f1 e0       	ldi	r31, 0x01	; 1
    30f2:	80 81       	ld	r24, Z
    30f4:	81 60       	ori	r24, 0x01	; 1
    30f6:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    30f8:	ea e7       	ldi	r30, 0x7A	; 122
    30fa:	f0 e0       	ldi	r31, 0x00	; 0
    30fc:	80 81       	ld	r24, Z
    30fe:	84 60       	ori	r24, 0x04	; 4
    3100:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    3102:	80 81       	ld	r24, Z
    3104:	82 60       	ori	r24, 0x02	; 2
    3106:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    3108:	80 81       	ld	r24, Z
    310a:	81 60       	ori	r24, 0x01	; 1
    310c:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    310e:	80 81       	ld	r24, Z
    3110:	80 68       	ori	r24, 0x80	; 128
    3112:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    3114:	10 92 c1 00 	sts	0x00C1, r1
    3118:	08 95       	ret

0000311a <analogRead>:
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#endif
	pin = analogPinToChannel(pin);
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
    311a:	86 33       	cpi	r24, 0x36	; 54
    311c:	08 f0       	brcs	.+2      	; 0x3120 <analogRead+0x6>
    311e:	86 53       	subi	r24, 0x36	; 54
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
    3120:	eb e7       	ldi	r30, 0x7B	; 123
    3122:	f0 e0       	ldi	r31, 0x00	; 0
    3124:	90 81       	ld	r25, Z
    3126:	28 2f       	mov	r18, r24
    3128:	28 70       	andi	r18, 0x08	; 8
    312a:	97 7f       	andi	r25, 0xF7	; 247
    312c:	92 2b       	or	r25, r18
    312e:	90 83       	st	Z, r25
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    3130:	87 70       	andi	r24, 0x07	; 7
    3132:	20 91 1a 02 	lds	r18, 0x021A
    3136:	40 e4       	ldi	r20, 0x40	; 64
    3138:	24 9f       	mul	r18, r20
    313a:	90 01       	movw	r18, r0
    313c:	11 24       	eor	r1, r1
    313e:	28 2b       	or	r18, r24
    3140:	20 93 7c 00 	sts	0x007C, r18
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    3144:	ea e7       	ldi	r30, 0x7A	; 122
    3146:	f0 e0       	ldi	r31, 0x00	; 0
    3148:	80 81       	ld	r24, Z
    314a:	80 64       	ori	r24, 0x40	; 64
    314c:	80 83       	st	Z, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    314e:	80 81       	ld	r24, Z
    3150:	86 fd       	sbrc	r24, 6
    3152:	fd cf       	rjmp	.-6      	; 0x314e <analogRead+0x34>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    3154:	20 91 78 00 	lds	r18, 0x0078
	high = ADCH;
    3158:	30 91 79 00 	lds	r19, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    315c:	93 2f       	mov	r25, r19
    315e:	80 e0       	ldi	r24, 0x00	; 0
    3160:	ac 01       	movw	r20, r24
    3162:	42 2b       	or	r20, r18
    3164:	9a 01       	movw	r18, r20
}
    3166:	82 2f       	mov	r24, r18
    3168:	93 2f       	mov	r25, r19
    316a:	08 95       	ret

0000316c <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    316c:	89 30       	cpi	r24, 0x09	; 9
    316e:	09 f4       	brne	.+2      	; 0x3172 <turnOffPWM+0x6>
    3170:	4c c0       	rjmp	.+152    	; 0x320a <turnOffPWM+0x9e>
    3172:	88 f4       	brcc	.+34     	; 0x3196 <turnOffPWM+0x2a>
    3174:	84 30       	cpi	r24, 0x04	; 4
    3176:	49 f1       	breq	.+82     	; 0x31ca <turnOffPWM+0x5e>
    3178:	38 f4       	brcc	.+14     	; 0x3188 <turnOffPWM+0x1c>
    317a:	82 30       	cpi	r24, 0x02	; 2
    317c:	81 f1       	breq	.+96     	; 0x31de <turnOffPWM+0x72>
    317e:	f8 f4       	brcc	.+62     	; 0x31be <turnOffPWM+0x52>
    3180:	81 30       	cpi	r24, 0x01	; 1
    3182:	09 f0       	breq	.+2      	; 0x3186 <turnOffPWM+0x1a>
    3184:	71 c0       	rjmp	.+226    	; 0x3268 <turnOffPWM+0xfc>
    3186:	27 c0       	rjmp	.+78     	; 0x31d6 <turnOffPWM+0x6a>
    3188:	87 30       	cpi	r24, 0x07	; 7
    318a:	99 f1       	breq	.+102    	; 0x31f2 <turnOffPWM+0x86>
    318c:	c0 f5       	brcc	.+112    	; 0x31fe <turnOffPWM+0x92>
    318e:	86 30       	cpi	r24, 0x06	; 6
    3190:	09 f0       	breq	.+2      	; 0x3194 <turnOffPWM+0x28>
    3192:	6a c0       	rjmp	.+212    	; 0x3268 <turnOffPWM+0xfc>
    3194:	28 c0       	rjmp	.+80     	; 0x31e6 <turnOffPWM+0x7a>
    3196:	8d 30       	cpi	r24, 0x0D	; 13
    3198:	09 f4       	brne	.+2      	; 0x319c <turnOffPWM+0x30>
    319a:	4f c0       	rjmp	.+158    	; 0x323a <turnOffPWM+0xce>
    319c:	30 f4       	brcc	.+12     	; 0x31aa <turnOffPWM+0x3e>
    319e:	8b 30       	cpi	r24, 0x0B	; 11
    31a0:	09 f4       	brne	.+2      	; 0x31a4 <turnOffPWM+0x38>
    31a2:	3f c0       	rjmp	.+126    	; 0x3222 <turnOffPWM+0xb6>
    31a4:	08 f0       	brcs	.+2      	; 0x31a8 <turnOffPWM+0x3c>
    31a6:	43 c0       	rjmp	.+134    	; 0x322e <turnOffPWM+0xc2>
    31a8:	36 c0       	rjmp	.+108    	; 0x3216 <turnOffPWM+0xaa>
    31aa:	80 31       	cpi	r24, 0x10	; 16
    31ac:	09 f4       	brne	.+2      	; 0x31b0 <turnOffPWM+0x44>
    31ae:	51 c0       	rjmp	.+162    	; 0x3252 <turnOffPWM+0xe6>
    31b0:	81 31       	cpi	r24, 0x11	; 17
    31b2:	09 f4       	brne	.+2      	; 0x31b6 <turnOffPWM+0x4a>
    31b4:	54 c0       	rjmp	.+168    	; 0x325e <turnOffPWM+0xf2>
    31b6:	8f 30       	cpi	r24, 0x0F	; 15
    31b8:	09 f0       	breq	.+2      	; 0x31bc <turnOffPWM+0x50>
    31ba:	56 c0       	rjmp	.+172    	; 0x3268 <turnOffPWM+0xfc>
    31bc:	44 c0       	rjmp	.+136    	; 0x3246 <turnOffPWM+0xda>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    31be:	e0 e8       	ldi	r30, 0x80	; 128
    31c0:	f0 e0       	ldi	r31, 0x00	; 0
    31c2:	80 81       	ld	r24, Z
    31c4:	8f 77       	andi	r24, 0x7F	; 127
    31c6:	80 83       	st	Z, r24
    31c8:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    31ca:	e0 e8       	ldi	r30, 0x80	; 128
    31cc:	f0 e0       	ldi	r31, 0x00	; 0
    31ce:	80 81       	ld	r24, Z
    31d0:	8f 7d       	andi	r24, 0xDF	; 223
    31d2:	80 83       	st	Z, r24
    31d4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    31d6:	84 b5       	in	r24, 0x24	; 36
    31d8:	8f 77       	andi	r24, 0x7F	; 127
    31da:	84 bd       	out	0x24, r24	; 36
    31dc:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    31de:	84 b5       	in	r24, 0x24	; 36
    31e0:	8f 7d       	andi	r24, 0xDF	; 223
    31e2:	84 bd       	out	0x24, r24	; 36
    31e4:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    31e6:	e0 eb       	ldi	r30, 0xB0	; 176
    31e8:	f0 e0       	ldi	r31, 0x00	; 0
    31ea:	80 81       	ld	r24, Z
    31ec:	8f 77       	andi	r24, 0x7F	; 127
    31ee:	80 83       	st	Z, r24
    31f0:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    31f2:	e0 eb       	ldi	r30, 0xB0	; 176
    31f4:	f0 e0       	ldi	r31, 0x00	; 0
    31f6:	80 81       	ld	r24, Z
    31f8:	8f 7d       	andi	r24, 0xDF	; 223
    31fa:	80 83       	st	Z, r24
    31fc:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    31fe:	e0 e9       	ldi	r30, 0x90	; 144
    3200:	f0 e0       	ldi	r31, 0x00	; 0
    3202:	80 81       	ld	r24, Z
    3204:	8f 77       	andi	r24, 0x7F	; 127
    3206:	80 83       	st	Z, r24
    3208:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    320a:	e0 e9       	ldi	r30, 0x90	; 144
    320c:	f0 e0       	ldi	r31, 0x00	; 0
    320e:	80 81       	ld	r24, Z
    3210:	8f 7d       	andi	r24, 0xDF	; 223
    3212:	80 83       	st	Z, r24
    3214:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    3216:	e0 e9       	ldi	r30, 0x90	; 144
    3218:	f0 e0       	ldi	r31, 0x00	; 0
    321a:	80 81       	ld	r24, Z
    321c:	87 7f       	andi	r24, 0xF7	; 247
    321e:	80 83       	st	Z, r24
    3220:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    3222:	e0 ea       	ldi	r30, 0xA0	; 160
    3224:	f0 e0       	ldi	r31, 0x00	; 0
    3226:	80 81       	ld	r24, Z
    3228:	8f 77       	andi	r24, 0x7F	; 127
    322a:	80 83       	st	Z, r24
    322c:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    322e:	e0 ea       	ldi	r30, 0xA0	; 160
    3230:	f0 e0       	ldi	r31, 0x00	; 0
    3232:	80 81       	ld	r24, Z
    3234:	8f 7d       	andi	r24, 0xDF	; 223
    3236:	80 83       	st	Z, r24
    3238:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    323a:	e0 ea       	ldi	r30, 0xA0	; 160
    323c:	f0 e0       	ldi	r31, 0x00	; 0
    323e:	80 81       	ld	r24, Z
    3240:	87 7f       	andi	r24, 0xF7	; 247
    3242:	80 83       	st	Z, r24
    3244:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3246:	e0 e2       	ldi	r30, 0x20	; 32
    3248:	f1 e0       	ldi	r31, 0x01	; 1
    324a:	80 81       	ld	r24, Z
    324c:	8f 77       	andi	r24, 0x7F	; 127
    324e:	80 83       	st	Z, r24
    3250:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3252:	e0 e2       	ldi	r30, 0x20	; 32
    3254:	f1 e0       	ldi	r31, 0x01	; 1
    3256:	80 81       	ld	r24, Z
    3258:	8f 7d       	andi	r24, 0xDF	; 223
    325a:	80 83       	st	Z, r24
    325c:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    325e:	e0 e2       	ldi	r30, 0x20	; 32
    3260:	f1 e0       	ldi	r31, 0x01	; 1
    3262:	80 81       	ld	r24, Z
    3264:	87 7f       	andi	r24, 0xF7	; 247
    3266:	80 83       	st	Z, r24
    3268:	08 95       	ret

0000326a <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    326a:	cf 93       	push	r28
    326c:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	fc 01       	movw	r30, r24
    3272:	e6 5d       	subi	r30, 0xD6	; 214
    3274:	fe 4f       	sbci	r31, 0xFE	; 254
    3276:	44 91       	lpm	r20, Z
	uint8_t port = digitalPinToPort(pin);
    3278:	fc 01       	movw	r30, r24
    327a:	e0 59       	subi	r30, 0x90	; 144
    327c:	fe 4f       	sbci	r31, 0xFE	; 254
    327e:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3280:	88 23       	and	r24, r24
    3282:	91 f1       	breq	.+100    	; 0x32e8 <pinMode+0x7e>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	88 0f       	add	r24, r24
    3288:	99 1f       	adc	r25, r25
    328a:	fc 01       	movw	r30, r24
    328c:	e6 51       	subi	r30, 0x16	; 22
    328e:	fe 4f       	sbci	r31, 0xFE	; 254
    3290:	25 91       	lpm	r18, Z+
    3292:	34 91       	lpm	r19, Z
    3294:	a2 2f       	mov	r26, r18
    3296:	b3 2f       	mov	r27, r19
	out = portOutputRegister(port);
    3298:	80 53       	subi	r24, 0x30	; 48
    329a:	9e 4f       	sbci	r25, 0xFE	; 254
    329c:	fc 01       	movw	r30, r24
    329e:	85 91       	lpm	r24, Z+
    32a0:	94 91       	lpm	r25, Z
    32a2:	c8 2f       	mov	r28, r24
    32a4:	d9 2f       	mov	r29, r25

	if (mode == INPUT) { 
    32a6:	61 11       	cpse	r22, r1
    32a8:	0b c0       	rjmp	.+22     	; 0x32c0 <pinMode+0x56>
		uint8_t oldSREG = SREG;
    32aa:	8f b7       	in	r24, 0x3f	; 63
                cli();
    32ac:	f8 94       	cli
		*reg &= ~bit;
    32ae:	9c 91       	ld	r25, X
    32b0:	40 95       	com	r20
    32b2:	94 23       	and	r25, r20
    32b4:	9c 93       	st	X, r25
		*out &= ~bit;
    32b6:	e8 81       	ld	r30, Y
    32b8:	4e 23       	and	r20, r30
    32ba:	48 83       	st	Y, r20
		SREG = oldSREG;
    32bc:	8f bf       	out	0x3f, r24	; 63
    32be:	14 c0       	rjmp	.+40     	; 0x32e8 <pinMode+0x7e>
	} else if (mode == INPUT_PULLUP) {
    32c0:	62 30       	cpi	r22, 0x02	; 2
    32c2:	61 f4       	brne	.+24     	; 0x32dc <pinMode+0x72>
		uint8_t oldSREG = SREG;
    32c4:	8f b7       	in	r24, 0x3f	; 63
                cli();
    32c6:	f8 94       	cli
		*reg &= ~bit;
    32c8:	2c 91       	ld	r18, X
    32ca:	94 2f       	mov	r25, r20
    32cc:	90 95       	com	r25
    32ce:	92 23       	and	r25, r18
    32d0:	9c 93       	st	X, r25
		*out |= bit;
    32d2:	e8 81       	ld	r30, Y
    32d4:	4e 2b       	or	r20, r30
    32d6:	48 83       	st	Y, r20
		SREG = oldSREG;
    32d8:	8f bf       	out	0x3f, r24	; 63
    32da:	06 c0       	rjmp	.+12     	; 0x32e8 <pinMode+0x7e>
	} else {
		uint8_t oldSREG = SREG;
    32dc:	8f b7       	in	r24, 0x3f	; 63
                cli();
    32de:	f8 94       	cli
		*reg |= bit;
    32e0:	ec 91       	ld	r30, X
    32e2:	4e 2b       	or	r20, r30
    32e4:	4c 93       	st	X, r20
		SREG = oldSREG;
    32e6:	8f bf       	out	0x3f, r24	; 63
	}
}
    32e8:	df 91       	pop	r29
    32ea:	cf 91       	pop	r28
    32ec:	08 95       	ret

000032ee <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    32ee:	1f 93       	push	r17
    32f0:	cf 93       	push	r28
    32f2:	df 93       	push	r29
    32f4:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    32f6:	28 2f       	mov	r18, r24
    32f8:	30 e0       	ldi	r19, 0x00	; 0
    32fa:	f9 01       	movw	r30, r18
    32fc:	ec 51       	subi	r30, 0x1C	; 28
    32fe:	ff 4f       	sbci	r31, 0xFF	; 255
    3300:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    3302:	f9 01       	movw	r30, r18
    3304:	e6 5d       	subi	r30, 0xD6	; 214
    3306:	fe 4f       	sbci	r31, 0xFE	; 254
    3308:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    330a:	f9 01       	movw	r30, r18
    330c:	e0 59       	subi	r30, 0x90	; 144
    330e:	fe 4f       	sbci	r31, 0xFE	; 254
    3310:	14 91       	lpm	r17, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    3312:	11 23       	and	r17, r17
    3314:	d1 f0       	breq	.+52     	; 0x334a <digitalWrite+0x5c>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    3316:	81 11       	cpse	r24, r1
    3318:	29 df       	rcall	.-430    	; 0x316c <turnOffPWM>

	out = portOutputRegister(port);
    331a:	21 2f       	mov	r18, r17
    331c:	30 e0       	ldi	r19, 0x00	; 0
    331e:	f9 01       	movw	r30, r18
    3320:	ee 0f       	add	r30, r30
    3322:	ff 1f       	adc	r31, r31
    3324:	e0 53       	subi	r30, 0x30	; 48
    3326:	fe 4f       	sbci	r31, 0xFE	; 254
    3328:	85 91       	lpm	r24, Z+
    332a:	94 91       	lpm	r25, Z
    332c:	a8 2f       	mov	r26, r24
    332e:	b9 2f       	mov	r27, r25

	uint8_t oldSREG = SREG;
    3330:	8f b7       	in	r24, 0x3f	; 63
	cli();
    3332:	f8 94       	cli

	if (val == LOW) {
    3334:	c1 11       	cpse	r28, r1
    3336:	05 c0       	rjmp	.+10     	; 0x3342 <digitalWrite+0x54>
		*out &= ~bit;
    3338:	ec 91       	ld	r30, X
    333a:	d0 95       	com	r29
    333c:	de 23       	and	r29, r30
    333e:	dc 93       	st	X, r29
    3340:	03 c0       	rjmp	.+6      	; 0x3348 <digitalWrite+0x5a>
	} else {
		*out |= bit;
    3342:	ec 91       	ld	r30, X
    3344:	de 2b       	or	r29, r30
    3346:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    3348:	8f bf       	out	0x3f, r24	; 63
}
    334a:	df 91       	pop	r29
    334c:	cf 91       	pop	r28
    334e:	1f 91       	pop	r17
    3350:	08 95       	ret

00003352 <pulseIn>:
/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
 * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
 * to 3 minutes in length, but must be called at least a few dozen microseconds
 * before the start of the pulse. */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3352:	4f 92       	push	r4
    3354:	5f 92       	push	r5
    3356:	6f 92       	push	r6
    3358:	7f 92       	push	r7
    335a:	8f 92       	push	r8
    335c:	9f 92       	push	r9
    335e:	af 92       	push	r10
    3360:	bf 92       	push	r11
    3362:	cf 92       	push	r12
    3364:	df 92       	push	r13
    3366:	ef 92       	push	r14
    3368:	ff 92       	push	r15
    336a:	0f 93       	push	r16
    336c:	1f 93       	push	r17
    336e:	cf 93       	push	r28
    3370:	df 93       	push	r29
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	fc 01       	movw	r30, r24
    3376:	e6 5d       	subi	r30, 0xD6	; 214
    3378:	fe 4f       	sbci	r31, 0xFE	; 254
    337a:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    337c:	fc 01       	movw	r30, r24
    337e:	e0 59       	subi	r30, 0x90	; 144
    3380:	fe 4f       	sbci	r31, 0xFE	; 254
    3382:	c4 91       	lpm	r28, Z
	uint8_t stateMask = (state ? bit : 0);
    3384:	61 11       	cpse	r22, r1
    3386:	02 c0       	rjmp	.+4      	; 0x338c <pulseIn+0x3a>
    3388:	00 e0       	ldi	r16, 0x00	; 0
    338a:	01 c0       	rjmp	.+2      	; 0x338e <pulseIn+0x3c>
    338c:	01 2f       	mov	r16, r17
	unsigned long width = 0; // keep initialization out of time critical area
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
    338e:	0f 2e       	mov	r0, r31
    3390:	cc 24       	eor	r12, r12
    3392:	ca 94       	dec	r12
    3394:	dc 2c       	mov	r13, r12
    3396:	ec 2c       	mov	r14, r12
    3398:	ff e0       	ldi	r31, 0x0F	; 15
    339a:	ff 2e       	mov	r15, r31
    339c:	f0 2d       	mov	r31, r0
    339e:	c2 22       	and	r12, r18
    33a0:	d3 22       	and	r13, r19
    33a2:	e4 22       	and	r14, r20
    33a4:	f5 22       	and	r15, r21
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    33a6:	d0 e0       	ldi	r29, 0x00	; 0
    33a8:	cc 0f       	add	r28, r28
    33aa:	dd 1f       	adc	r29, r29
    33ac:	ca 54       	subi	r28, 0x4A	; 74
    33ae:	de 4f       	sbci	r29, 0xFE	; 254
	uint8_t stateMask = (state ? bit : 0);
	unsigned long width = 0; // keep initialization out of time critical area
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
    33b0:	41 2c       	mov	r4, r1
    33b2:	51 2c       	mov	r5, r1
    33b4:	32 01       	movw	r6, r4
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    33b6:	fe 01       	movw	r30, r28
    33b8:	65 91       	lpm	r22, Z+
    33ba:	74 91       	lpm	r23, Z
    33bc:	0d c0       	rjmp	.+26     	; 0x33d8 <pulseIn+0x86>
		if (numloops++ == maxloops)
    33be:	d3 01       	movw	r26, r6
    33c0:	c2 01       	movw	r24, r4
    33c2:	01 96       	adiw	r24, 0x01	; 1
    33c4:	a1 1d       	adc	r26, r1
    33c6:	b1 1d       	adc	r27, r1
    33c8:	4c 14       	cp	r4, r12
    33ca:	5d 04       	cpc	r5, r13
    33cc:	6e 04       	cpc	r6, r14
    33ce:	7f 04       	cpc	r7, r15
    33d0:	09 f4       	brne	.+2      	; 0x33d4 <pulseIn+0x82>
    33d2:	80 c0       	rjmp	.+256    	; 0x34d4 <pulseIn+0x182>
    33d4:	2c 01       	movw	r4, r24
    33d6:	3d 01       	movw	r6, r26
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    33d8:	e6 2f       	mov	r30, r22
    33da:	f7 2f       	mov	r31, r23
    33dc:	80 81       	ld	r24, Z
    33de:	81 23       	and	r24, r17
    33e0:	08 17       	cp	r16, r24
    33e2:	69 f3       	breq	.-38     	; 0x33be <pulseIn+0x6c>
    33e4:	11 c0       	rjmp	.+34     	; 0x3408 <pulseIn+0xb6>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
    33e6:	81 2c       	mov	r8, r1
    33e8:	91 2c       	mov	r9, r1
    33ea:	54 01       	movw	r10, r8
    33ec:	83 94       	inc	r8
    33ee:	84 0c       	add	r8, r4
    33f0:	95 1c       	adc	r9, r5
    33f2:	a6 1c       	adc	r10, r6
    33f4:	b7 1c       	adc	r11, r7
    33f6:	4c 14       	cp	r4, r12
    33f8:	5d 04       	cpc	r5, r13
    33fa:	6e 04       	cpc	r6, r14
    33fc:	7f 04       	cpc	r7, r15
    33fe:	09 f4       	brne	.+2      	; 0x3402 <pulseIn+0xb0>
    3400:	6d c0       	rjmp	.+218    	; 0x34dc <pulseIn+0x18a>
    3402:	24 01       	movw	r4, r8
    3404:	35 01       	movw	r6, r10
    3406:	03 c0       	rjmp	.+6      	; 0x340e <pulseIn+0xbc>
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
    3408:	fe 01       	movw	r30, r28
    340a:	85 91       	lpm	r24, Z+
    340c:	94 91       	lpm	r25, Z
    340e:	e8 2f       	mov	r30, r24
    3410:	f9 2f       	mov	r31, r25
    3412:	60 81       	ld	r22, Z
    3414:	61 23       	and	r22, r17
    3416:	06 13       	cpse	r16, r22
    3418:	e6 cf       	rjmp	.-52     	; 0x33e6 <pulseIn+0x94>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
    341a:	fe 01       	movw	r30, r28
    341c:	85 91       	lpm	r24, Z+
    341e:	94 91       	lpm	r25, Z
    3420:	e8 2f       	mov	r30, r24
    3422:	f9 2f       	mov	r31, r25
    3424:	80 81       	ld	r24, Z
    3426:	81 23       	and	r24, r17
    3428:	08 13       	cpse	r16, r24
    342a:	25 c0       	rjmp	.+74     	; 0x3476 <pulseIn+0x124>
		if (numloops++ == maxloops)
    342c:	4c 14       	cp	r4, r12
    342e:	5d 04       	cpc	r5, r13
    3430:	6e 04       	cpc	r6, r14
    3432:	7f 04       	cpc	r7, r15
    3434:	09 f4       	brne	.+2      	; 0x3438 <pulseIn+0xe6>
    3436:	56 c0       	rjmp	.+172    	; 0x34e4 <pulseIn+0x192>
    3438:	81 2c       	mov	r8, r1
    343a:	91 2c       	mov	r9, r1
    343c:	54 01       	movw	r10, r8
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
    343e:	fe 01       	movw	r30, r28
    3440:	85 91       	lpm	r24, Z+
    3442:	94 91       	lpm	r25, Z
    3444:	0c c0       	rjmp	.+24     	; 0x345e <pulseIn+0x10c>
		if (numloops++ == maxloops)
    3446:	b3 01       	movw	r22, r6
    3448:	a2 01       	movw	r20, r4
    344a:	48 0d       	add	r20, r8
    344c:	59 1d       	adc	r21, r9
    344e:	6a 1d       	adc	r22, r10
    3450:	7b 1d       	adc	r23, r11
    3452:	c4 16       	cp	r12, r20
    3454:	d5 06       	cpc	r13, r21
    3456:	e6 06       	cpc	r14, r22
    3458:	f7 06       	cpc	r15, r23
    345a:	09 f4       	brne	.+2      	; 0x345e <pulseIn+0x10c>
    345c:	47 c0       	rjmp	.+142    	; 0x34ec <pulseIn+0x19a>
			return 0;
		width++;
    345e:	2f ef       	ldi	r18, 0xFF	; 255
    3460:	82 1a       	sub	r8, r18
    3462:	92 0a       	sbc	r9, r18
    3464:	a2 0a       	sbc	r10, r18
    3466:	b2 0a       	sbc	r11, r18
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
    3468:	e8 2f       	mov	r30, r24
    346a:	f9 2f       	mov	r31, r25
    346c:	60 81       	ld	r22, Z
    346e:	61 23       	and	r22, r17
    3470:	06 17       	cp	r16, r22
    3472:	49 f3       	breq	.-46     	; 0x3446 <pulseIn+0xf4>
    3474:	03 c0       	rjmp	.+6      	; 0x347c <pulseIn+0x12a>
    3476:	81 2c       	mov	r8, r1
    3478:	91 2c       	mov	r9, r1
    347a:	54 01       	movw	r10, r8

	// convert the reading to microseconds. The loop has been determined
	// to be 20 clock cycles long and have about 16 clocks between the edge
	// and the start of the loop. There will be some error introduced by
	// the interrupt handlers.
	return clockCyclesToMicroseconds(width * 21 + 16); 
    347c:	d5 01       	movw	r26, r10
    347e:	c4 01       	movw	r24, r8
    3480:	88 0f       	add	r24, r24
    3482:	99 1f       	adc	r25, r25
    3484:	aa 1f       	adc	r26, r26
    3486:	bb 1f       	adc	r27, r27
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	aa 1f       	adc	r26, r26
    348e:	bb 1f       	adc	r27, r27
    3490:	6c 01       	movw	r12, r24
    3492:	7d 01       	movw	r14, r26
    3494:	cc 0c       	add	r12, r12
    3496:	dd 1c       	adc	r13, r13
    3498:	ee 1c       	adc	r14, r14
    349a:	ff 1c       	adc	r15, r15
    349c:	cc 0c       	add	r12, r12
    349e:	dd 1c       	adc	r13, r13
    34a0:	ee 1c       	adc	r14, r14
    34a2:	ff 1c       	adc	r15, r15
    34a4:	8c 0d       	add	r24, r12
    34a6:	9d 1d       	adc	r25, r13
    34a8:	ae 1d       	adc	r26, r14
    34aa:	bf 1d       	adc	r27, r15
    34ac:	88 0e       	add	r8, r24
    34ae:	99 1e       	adc	r9, r25
    34b0:	aa 1e       	adc	r10, r26
    34b2:	bb 1e       	adc	r11, r27
    34b4:	80 e1       	ldi	r24, 0x10	; 16
    34b6:	88 0e       	add	r8, r24
    34b8:	91 1c       	adc	r9, r1
    34ba:	a1 1c       	adc	r10, r1
    34bc:	b1 1c       	adc	r11, r1
    34be:	75 01       	movw	r14, r10
    34c0:	64 01       	movw	r12, r8
    34c2:	68 94       	set
    34c4:	13 f8       	bld	r1, 3
    34c6:	f6 94       	lsr	r15
    34c8:	e7 94       	ror	r14
    34ca:	d7 94       	ror	r13
    34cc:	c7 94       	ror	r12
    34ce:	16 94       	lsr	r1
    34d0:	d1 f7       	brne	.-12     	; 0x34c6 <pulseIn+0x174>
    34d2:	0f c0       	rjmp	.+30     	; 0x34f2 <pulseIn+0x1a0>
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
    34d4:	c1 2c       	mov	r12, r1
    34d6:	d1 2c       	mov	r13, r1
    34d8:	76 01       	movw	r14, r12
    34da:	0b c0       	rjmp	.+22     	; 0x34f2 <pulseIn+0x1a0>
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
    34dc:	c1 2c       	mov	r12, r1
    34de:	d1 2c       	mov	r13, r1
    34e0:	76 01       	movw	r14, r12
    34e2:	07 c0       	rjmp	.+14     	; 0x34f2 <pulseIn+0x1a0>
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
		if (numloops++ == maxloops)
			return 0;
    34e4:	c1 2c       	mov	r12, r1
    34e6:	d1 2c       	mov	r13, r1
    34e8:	76 01       	movw	r14, r12
    34ea:	03 c0       	rjmp	.+6      	; 0x34f2 <pulseIn+0x1a0>
    34ec:	c1 2c       	mov	r12, r1
    34ee:	d1 2c       	mov	r13, r1
    34f0:	76 01       	movw	r14, r12
	// convert the reading to microseconds. The loop has been determined
	// to be 20 clock cycles long and have about 16 clocks between the edge
	// and the start of the loop. There will be some error introduced by
	// the interrupt handlers.
	return clockCyclesToMicroseconds(width * 21 + 16); 
}
    34f2:	6c 2d       	mov	r22, r12
    34f4:	7d 2d       	mov	r23, r13
    34f6:	8e 2d       	mov	r24, r14
    34f8:	9f 2d       	mov	r25, r15
    34fa:	df 91       	pop	r29
    34fc:	cf 91       	pop	r28
    34fe:	1f 91       	pop	r17
    3500:	0f 91       	pop	r16
    3502:	ff 90       	pop	r15
    3504:	ef 90       	pop	r14
    3506:	df 90       	pop	r13
    3508:	cf 90       	pop	r12
    350a:	bf 90       	pop	r11
    350c:	af 90       	pop	r10
    350e:	9f 90       	pop	r9
    3510:	8f 90       	pop	r8
    3512:	7f 90       	pop	r7
    3514:	6f 90       	pop	r6
    3516:	5f 90       	pop	r5
    3518:	4f 90       	pop	r4
    351a:	08 95       	ret

0000351c <__divmodhi4>:
    351c:	97 fb       	bst	r25, 7
    351e:	07 2e       	mov	r0, r23
    3520:	16 f4       	brtc	.+4      	; 0x3526 <__divmodhi4+0xa>
    3522:	00 94       	com	r0
    3524:	06 d0       	rcall	.+12     	; 0x3532 <__divmodhi4_neg1>
    3526:	77 fd       	sbrc	r23, 7
    3528:	08 d0       	rcall	.+16     	; 0x353a <__divmodhi4_neg2>
    352a:	3d d0       	rcall	.+122    	; 0x35a6 <__udivmodhi4>
    352c:	07 fc       	sbrc	r0, 7
    352e:	05 d0       	rcall	.+10     	; 0x353a <__divmodhi4_neg2>
    3530:	3e f4       	brtc	.+14     	; 0x3540 <__divmodhi4_exit>

00003532 <__divmodhi4_neg1>:
    3532:	90 95       	com	r25
    3534:	81 95       	neg	r24
    3536:	9f 4f       	sbci	r25, 0xFF	; 255
    3538:	08 95       	ret

0000353a <__divmodhi4_neg2>:
    353a:	70 95       	com	r23
    353c:	61 95       	neg	r22
    353e:	7f 4f       	sbci	r23, 0xFF	; 255

00003540 <__divmodhi4_exit>:
    3540:	08 95       	ret

00003542 <__udivmodsi4>:
    3542:	a1 e2       	ldi	r26, 0x21	; 33
    3544:	1a 2e       	mov	r1, r26
    3546:	aa 1b       	sub	r26, r26
    3548:	bb 1b       	sub	r27, r27
    354a:	fd 01       	movw	r30, r26
    354c:	0d c0       	rjmp	.+26     	; 0x3568 <__udivmodsi4_ep>

0000354e <__udivmodsi4_loop>:
    354e:	aa 1f       	adc	r26, r26
    3550:	bb 1f       	adc	r27, r27
    3552:	ee 1f       	adc	r30, r30
    3554:	ff 1f       	adc	r31, r31
    3556:	a2 17       	cp	r26, r18
    3558:	b3 07       	cpc	r27, r19
    355a:	e4 07       	cpc	r30, r20
    355c:	f5 07       	cpc	r31, r21
    355e:	20 f0       	brcs	.+8      	; 0x3568 <__udivmodsi4_ep>
    3560:	a2 1b       	sub	r26, r18
    3562:	b3 0b       	sbc	r27, r19
    3564:	e4 0b       	sbc	r30, r20
    3566:	f5 0b       	sbc	r31, r21

00003568 <__udivmodsi4_ep>:
    3568:	66 1f       	adc	r22, r22
    356a:	77 1f       	adc	r23, r23
    356c:	88 1f       	adc	r24, r24
    356e:	99 1f       	adc	r25, r25
    3570:	1a 94       	dec	r1
    3572:	69 f7       	brne	.-38     	; 0x354e <__udivmodsi4_loop>
    3574:	60 95       	com	r22
    3576:	70 95       	com	r23
    3578:	80 95       	com	r24
    357a:	90 95       	com	r25
    357c:	9b 01       	movw	r18, r22
    357e:	ac 01       	movw	r20, r24
    3580:	bd 01       	movw	r22, r26
    3582:	cf 01       	movw	r24, r30
    3584:	08 95       	ret

00003586 <__umulhisi3>:
    3586:	a2 9f       	mul	r26, r18
    3588:	b0 01       	movw	r22, r0
    358a:	b3 9f       	mul	r27, r19
    358c:	c0 01       	movw	r24, r0
    358e:	a3 9f       	mul	r26, r19
    3590:	01 d0       	rcall	.+2      	; 0x3594 <__umulhisi3+0xe>
    3592:	b2 9f       	mul	r27, r18
    3594:	70 0d       	add	r23, r0
    3596:	81 1d       	adc	r24, r1
    3598:	11 24       	eor	r1, r1
    359a:	91 1d       	adc	r25, r1
    359c:	08 95       	ret

0000359e <__tablejump_elpm__>:
    359e:	07 90       	elpm	r0, Z+
    35a0:	f6 91       	elpm	r31, Z
    35a2:	e0 2d       	mov	r30, r0
    35a4:	19 94       	eijmp

000035a6 <__udivmodhi4>:
    35a6:	aa 1b       	sub	r26, r26
    35a8:	bb 1b       	sub	r27, r27
    35aa:	51 e1       	ldi	r21, 0x11	; 17
    35ac:	07 c0       	rjmp	.+14     	; 0x35bc <__udivmodhi4_ep>

000035ae <__udivmodhi4_loop>:
    35ae:	aa 1f       	adc	r26, r26
    35b0:	bb 1f       	adc	r27, r27
    35b2:	a6 17       	cp	r26, r22
    35b4:	b7 07       	cpc	r27, r23
    35b6:	10 f0       	brcs	.+4      	; 0x35bc <__udivmodhi4_ep>
    35b8:	a6 1b       	sub	r26, r22
    35ba:	b7 0b       	sbc	r27, r23

000035bc <__udivmodhi4_ep>:
    35bc:	88 1f       	adc	r24, r24
    35be:	99 1f       	adc	r25, r25
    35c0:	5a 95       	dec	r21
    35c2:	a9 f7       	brne	.-22     	; 0x35ae <__udivmodhi4_loop>
    35c4:	80 95       	com	r24
    35c6:	90 95       	com	r25
    35c8:	bc 01       	movw	r22, r24
    35ca:	cd 01       	movw	r24, r26
    35cc:	08 95       	ret

000035ce <memcpy>:
    35ce:	fb 01       	movw	r30, r22
    35d0:	dc 01       	movw	r26, r24
    35d2:	02 c0       	rjmp	.+4      	; 0x35d8 <memcpy+0xa>
    35d4:	01 90       	ld	r0, Z+
    35d6:	0d 92       	st	X+, r0
    35d8:	41 50       	subi	r20, 0x01	; 1
    35da:	50 40       	sbci	r21, 0x00	; 0
    35dc:	d8 f7       	brcc	.-10     	; 0x35d4 <memcpy+0x6>
    35de:	08 95       	ret

000035e0 <__do_global_dtors>:
    35e0:	12 e0       	ldi	r17, 0x02	; 2
    35e2:	c8 e0       	ldi	r28, 0x08	; 8
    35e4:	d2 e0       	ldi	r29, 0x02	; 2
    35e6:	00 e0       	ldi	r16, 0x00	; 0
    35e8:	05 c0       	rjmp	.+10     	; 0x35f4 <__do_global_dtors+0x14>
    35ea:	22 97       	sbiw	r28, 0x02	; 2
    35ec:	01 09       	sbc	r16, r1
    35ee:	fe 01       	movw	r30, r28
    35f0:	0b bf       	out	0x3b, r16	; 59
    35f2:	d5 df       	rcall	.-86     	; 0x359e <__tablejump_elpm__>
    35f4:	ca 30       	cpi	r28, 0x0A	; 10
    35f6:	d1 07       	cpc	r29, r17
    35f8:	80 e0       	ldi	r24, 0x00	; 0
    35fa:	08 07       	cpc	r16, r24
    35fc:	b1 f7       	brne	.-20     	; 0x35ea <__do_global_dtors+0xa>
    35fe:	f8 94       	cli

00003600 <__stop_program>:
    3600:	ff cf       	rjmp	.-2      	; 0x3600 <__stop_program>
